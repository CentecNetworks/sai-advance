/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "switch_sai_rpc.h"

namespace switch_sai {


switch_sai_rpc_sai_thrift_set_port_attribute_args::~switch_sai_rpc_sai_thrift_set_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_port_attribute_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_port_attribute_pargs::~switch_sai_rpc_sai_thrift_set_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_port_attribute_result::~switch_sai_rpc_sai_thrift_set_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_port_attribute_presult::~switch_sai_rpc_sai_thrift_set_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_attribute_args::~switch_sai_rpc_sai_thrift_get_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_attribute_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_attribute_pargs::~switch_sai_rpc_sai_thrift_get_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_attribute_result::~switch_sai_rpc_sai_thrift_get_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_attribute_presult::~switch_sai_rpc_sai_thrift_get_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_args::~switch_sai_rpc_sai_thrift_get_port_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->counter_ids.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += iprot->readI32(this->counter_ids[_i148]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter149;
    for (_iter149 = this->counter_ids.begin(); _iter149 != this->counter_ids.end(); ++_iter149)
    {
      xfer += oprot->writeI32((*_iter149));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_pargs::~switch_sai_rpc_sai_thrift_get_port_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter150;
    for (_iter150 = (*(this->counter_ids)).begin(); _iter150 != (*(this->counter_ids)).end(); ++_iter150)
    {
      xfer += oprot->writeI32((*_iter150));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_result::~switch_sai_rpc_sai_thrift_get_port_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readListBegin(_etype154, _size151);
            this->success.resize(_size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              xfer += iprot->readI64(this->success[_i155]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter156;
      for (_iter156 = this->success.begin(); _iter156 != this->success.end(); ++_iter156)
      {
        xfer += oprot->writeI64((*_iter156));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_presult::~switch_sai_rpc_sai_thrift_get_port_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size157;
            ::apache::thrift::protocol::TType _etype160;
            xfer += iprot->readListBegin(_etype160, _size157);
            (*(this->success)).resize(_size157);
            uint32_t _i161;
            for (_i161 = 0; _i161 < _size157; ++_i161)
            {
              xfer += iprot->readI64((*(this->success))[_i161]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_ext_args::~switch_sai_rpc_sai_thrift_get_port_stats_ext_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_ext_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readListBegin(_etype165, _size162);
            this->counter_ids.resize(_size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              xfer += iprot->readI32(this->counter_ids[_i166]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_stats_ext_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_ext_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter167;
    for (_iter167 = this->counter_ids.begin(); _iter167 != this->counter_ids.end(); ++_iter167)
    {
      xfer += oprot->writeI32((*_iter167));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_ext_pargs::~switch_sai_rpc_sai_thrift_get_port_stats_ext_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_ext_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_ext_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter168;
    for (_iter168 = (*(this->counter_ids)).begin(); _iter168 != (*(this->counter_ids)).end(); ++_iter168)
    {
      xfer += oprot->writeI32((*_iter168));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_ext_result::~switch_sai_rpc_sai_thrift_get_port_stats_ext_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_ext_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->success.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += iprot->readI64(this->success[_i173]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_stats_ext_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_ext_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter174;
      for (_iter174 = this->success.begin(); _iter174 != this->success.end(); ++_iter174)
      {
        xfer += oprot->writeI64((*_iter174));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_ext_presult::~switch_sai_rpc_sai_thrift_get_port_stats_ext_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_ext_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size175;
            ::apache::thrift::protocol::TType _etype178;
            xfer += iprot->readListBegin(_etype178, _size175);
            (*(this->success)).resize(_size175);
            uint32_t _i179;
            for (_i179 = 0; _i179 < _size175; ++_i179)
            {
              xfer += iprot->readI64((*(this->success))[_i179]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_all_stats_args::~switch_sai_rpc_sai_thrift_clear_port_all_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_all_stats_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs::~switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_all_stats_result::~switch_sai_rpc_sai_thrift_clear_port_all_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_all_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_all_stats_presult::~switch_sai_rpc_sai_thrift_clear_port_all_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_stats_args::~switch_sai_rpc_sai_thrift_clear_port_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->counter_ids.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += iprot->readI32(this->counter_ids[_i184]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_port_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_stats_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter185;
    for (_iter185 = this->counter_ids.begin(); _iter185 != this->counter_ids.end(); ++_iter185)
    {
      xfer += oprot->writeI32((*_iter185));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_stats_pargs::~switch_sai_rpc_sai_thrift_clear_port_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_stats_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter186;
    for (_iter186 = (*(this->counter_ids)).begin(); _iter186 != (*(this->counter_ids)).end(); ++_iter186)
    {
      xfer += oprot->writeI32((*_iter186));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_stats_result::~switch_sai_rpc_sai_thrift_clear_port_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_port_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_stats_presult::~switch_sai_rpc_sai_thrift_clear_port_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_fdb_entry_args::~switch_sai_rpc_sai_thrift_create_fdb_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_fdb_entry.read(iprot);
          this->__isset.thrift_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size187;
            ::apache::thrift::protocol::TType _etype190;
            xfer += iprot->readListBegin(_etype190, _size187);
            this->thrift_attr_list.resize(_size187);
            uint32_t _i191;
            for (_i191 = 0; _i191 < _size187; ++_i191)
            {
              xfer += this->thrift_attr_list[_i191].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_fdb_entry_args");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter192;
    for (_iter192 = this->thrift_attr_list.begin(); _iter192 != this->thrift_attr_list.end(); ++_iter192)
    {
      xfer += (*_iter192).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_fdb_entry_pargs::~switch_sai_rpc_sai_thrift_create_fdb_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_fdb_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter193;
    for (_iter193 = (*(this->thrift_attr_list)).begin(); _iter193 != (*(this->thrift_attr_list)).end(); ++_iter193)
    {
      xfer += (*_iter193).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_fdb_entry_result::~switch_sai_rpc_sai_thrift_create_fdb_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_fdb_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_fdb_entry_presult::~switch_sai_rpc_sai_thrift_create_fdb_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_delete_fdb_entry_args::~switch_sai_rpc_sai_thrift_delete_fdb_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_fdb_entry.read(iprot);
          this->__isset.thrift_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_delete_fdb_entry_args");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs::~switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_delete_fdb_entry_result::~switch_sai_rpc_sai_thrift_delete_fdb_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_delete_fdb_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_delete_fdb_entry_presult::~switch_sai_rpc_sai_thrift_delete_fdb_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_flush_fdb_entries_args::~switch_sai_rpc_sai_thrift_flush_fdb_entries_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _etype197;
            xfer += iprot->readListBegin(_etype197, _size194);
            this->thrift_attr_list.resize(_size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              xfer += this->thrift_attr_list[_i198].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_flush_fdb_entries_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter199;
    for (_iter199 = this->thrift_attr_list.begin(); _iter199 != this->thrift_attr_list.end(); ++_iter199)
    {
      xfer += (*_iter199).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs::~switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter200;
    for (_iter200 = (*(this->thrift_attr_list)).begin(); _iter200 != (*(this->thrift_attr_list)).end(); ++_iter200)
    {
      xfer += (*_iter200).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_flush_fdb_entries_result::~switch_sai_rpc_sai_thrift_flush_fdb_entries_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_flush_fdb_entries_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_flush_fdb_entries_presult::~switch_sai_rpc_sai_thrift_flush_fdb_entries_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_fdb_entry.read(iprot);
          this->__isset.thrift_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_fdb_entry.read(iprot);
          this->__isset.thrift_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_args::~switch_sai_rpc_sai_thrift_create_vlan_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size201;
            ::apache::thrift::protocol::TType _etype204;
            xfer += iprot->readListBegin(_etype204, _size201);
            this->thrift_attr_list.resize(_size201);
            uint32_t _i205;
            for (_i205 = 0; _i205 < _size201; ++_i205)
            {
              xfer += this->thrift_attr_list[_i205].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter206;
    for (_iter206 = this->thrift_attr_list.begin(); _iter206 != this->thrift_attr_list.end(); ++_iter206)
    {
      xfer += (*_iter206).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_pargs::~switch_sai_rpc_sai_thrift_create_vlan_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter207;
    for (_iter207 = (*(this->thrift_attr_list)).begin(); _iter207 != (*(this->thrift_attr_list)).end(); ++_iter207)
    {
      xfer += (*_iter207).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_result::~switch_sai_rpc_sai_thrift_create_vlan_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_presult::~switch_sai_rpc_sai_thrift_create_vlan_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_args::~switch_sai_rpc_sai_thrift_remove_vlan_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_oid);
          this->__isset.vlan_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_args");

  xfer += oprot->writeFieldBegin("vlan_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_pargs::~switch_sai_rpc_sai_thrift_remove_vlan_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_pargs");

  xfer += oprot->writeFieldBegin("vlan_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_result::~switch_sai_rpc_sai_thrift_remove_vlan_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_presult::~switch_sai_rpc_sai_thrift_remove_vlan_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_args::~switch_sai_rpc_sai_thrift_get_vlan_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size208;
            ::apache::thrift::protocol::TType _etype211;
            xfer += iprot->readListBegin(_etype211, _size208);
            this->counter_ids.resize(_size208);
            uint32_t _i212;
            for (_i212 = 0; _i212 < _size208; ++_i212)
            {
              xfer += iprot->readI32(this->counter_ids[_i212]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_vlan_stat_counter_t> ::const_iterator _iter213;
    for (_iter213 = this->counter_ids.begin(); _iter213 != this->counter_ids.end(); ++_iter213)
    {
      xfer += oprot->writeI32((*_iter213));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_pargs::~switch_sai_rpc_sai_thrift_get_vlan_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_vlan_stat_counter_t> ::const_iterator _iter214;
    for (_iter214 = (*(this->counter_ids)).begin(); _iter214 != (*(this->counter_ids)).end(); ++_iter214)
    {
      xfer += oprot->writeI32((*_iter214));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_result::~switch_sai_rpc_sai_thrift_get_vlan_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size215;
            ::apache::thrift::protocol::TType _etype218;
            xfer += iprot->readListBegin(_etype218, _size215);
            this->success.resize(_size215);
            uint32_t _i219;
            for (_i219 = 0; _i219 < _size215; ++_i219)
            {
              xfer += iprot->readI64(this->success[_i219]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter220;
      for (_iter220 = this->success.begin(); _iter220 != this->success.end(); ++_iter220)
      {
        xfer += oprot->writeI64((*_iter220));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_presult::~switch_sai_rpc_sai_thrift_get_vlan_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size221;
            ::apache::thrift::protocol::TType _etype224;
            xfer += iprot->readListBegin(_etype224, _size221);
            (*(this->success)).resize(_size221);
            uint32_t _i225;
            for (_i225 = 0; _i225 < _size221; ++_i225)
            {
              xfer += iprot->readI64((*(this->success))[_i225]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_ext_args::~switch_sai_rpc_sai_thrift_get_vlan_stats_ext_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_ext_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _etype229;
            xfer += iprot->readListBegin(_etype229, _size226);
            this->thrift_counter_ids.resize(_size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i230]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_ext_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_ext_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_vlan_stat_counter_t> ::const_iterator _iter231;
    for (_iter231 = this->thrift_counter_ids.begin(); _iter231 != this->thrift_counter_ids.end(); ++_iter231)
    {
      xfer += oprot->writeI32((*_iter231));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_ext_pargs::~switch_sai_rpc_sai_thrift_get_vlan_stats_ext_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_ext_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_ext_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_vlan_stat_counter_t> ::const_iterator _iter232;
    for (_iter232 = (*(this->thrift_counter_ids)).begin(); _iter232 != (*(this->thrift_counter_ids)).end(); ++_iter232)
    {
      xfer += oprot->writeI32((*_iter232));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_ext_result::~switch_sai_rpc_sai_thrift_get_vlan_stats_ext_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_ext_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readListBegin(_etype236, _size233);
            this->success.resize(_size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              xfer += iprot->readI64(this->success[_i237]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_ext_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_ext_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter238;
      for (_iter238 = this->success.begin(); _iter238 != this->success.end(); ++_iter238)
      {
        xfer += oprot->writeI64((*_iter238));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_ext_presult::~switch_sai_rpc_sai_thrift_get_vlan_stats_ext_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_ext_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            (*(this->success)).resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += iprot->readI64((*(this->success))[_i243]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_vlan_stats_args::~switch_sai_rpc_sai_thrift_clear_vlan_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_vlan_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size244;
            ::apache::thrift::protocol::TType _etype247;
            xfer += iprot->readListBegin(_etype247, _size244);
            this->thrift_counter_ids.resize(_size244);
            uint32_t _i248;
            for (_i248 = 0; _i248 < _size244; ++_i248)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i248]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_vlan_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_vlan_stats_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_vlan_stat_counter_t> ::const_iterator _iter249;
    for (_iter249 = this->thrift_counter_ids.begin(); _iter249 != this->thrift_counter_ids.end(); ++_iter249)
    {
      xfer += oprot->writeI32((*_iter249));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_vlan_stats_pargs::~switch_sai_rpc_sai_thrift_clear_vlan_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_vlan_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_vlan_stats_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_vlan_stat_counter_t> ::const_iterator _iter250;
    for (_iter250 = (*(this->thrift_counter_ids)).begin(); _iter250 != (*(this->thrift_counter_ids)).end(); ++_iter250)
    {
      xfer += oprot->writeI32((*_iter250));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_vlan_stats_result::~switch_sai_rpc_sai_thrift_clear_vlan_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_vlan_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_vlan_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_vlan_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_vlan_stats_presult::~switch_sai_rpc_sai_thrift_clear_vlan_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_vlan_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_member_args::~switch_sai_rpc_sai_thrift_create_vlan_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size251;
            ::apache::thrift::protocol::TType _etype254;
            xfer += iprot->readListBegin(_etype254, _size251);
            this->thrift_attr_list.resize(_size251);
            uint32_t _i255;
            for (_i255 = 0; _i255 < _size251; ++_i255)
            {
              xfer += this->thrift_attr_list[_i255].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter256;
    for (_iter256 = this->thrift_attr_list.begin(); _iter256 != this->thrift_attr_list.end(); ++_iter256)
    {
      xfer += (*_iter256).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_member_pargs::~switch_sai_rpc_sai_thrift_create_vlan_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter257;
    for (_iter257 = (*(this->thrift_attr_list)).begin(); _iter257 != (*(this->thrift_attr_list)).end(); ++_iter257)
    {
      xfer += (*_iter257).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_member_result::~switch_sai_rpc_sai_thrift_create_vlan_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_member_presult::~switch_sai_rpc_sai_thrift_create_vlan_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args::~switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_member_id);
          this->__isset.vlan_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result::~switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_member_args::~switch_sai_rpc_sai_thrift_remove_vlan_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_member_id);
          this->__isset.vlan_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_member_args");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_member_pargs::~switch_sai_rpc_sai_thrift_remove_vlan_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_member_pargs");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_member_result::~switch_sai_rpc_sai_thrift_remove_vlan_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_member_presult::~switch_sai_rpc_sai_thrift_remove_vlan_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_attribute_args::~switch_sai_rpc_sai_thrift_set_vlan_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_attribute_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs::~switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_attribute_result::~switch_sai_rpc_sai_thrift_set_vlan_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_attribute_presult::~switch_sai_rpc_sai_thrift_set_vlan_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_member_attribute_args::~switch_sai_rpc_sai_thrift_set_vlan_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_member_id);
          this->__isset.vlan_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_vlan_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_member_attribute_args");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_member_attribute_pargs::~switch_sai_rpc_sai_thrift_set_vlan_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_member_attribute_result::~switch_sai_rpc_sai_thrift_set_vlan_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_vlan_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_member_attribute_presult::~switch_sai_rpc_sai_thrift_set_vlan_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_attribute_args::~switch_sai_rpc_sai_thrift_get_vlan_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_attribute_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs::~switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_attribute_result::~switch_sai_rpc_sai_thrift_get_vlan_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_attribute_presult::~switch_sai_rpc_sai_thrift_get_vlan_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_id_args::~switch_sai_rpc_sai_thrift_get_vlan_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_id_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_id_pargs::~switch_sai_rpc_sai_thrift_get_vlan_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_id_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_id_result::~switch_sai_rpc_sai_thrift_get_vlan_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_id_presult::~switch_sai_rpc_sai_thrift_get_vlan_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_members_args::~switch_sai_rpc_sai_thrift_create_vlan_members_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_members_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_lists.clear();
            uint32_t _size258;
            ::apache::thrift::protocol::TType _etype261;
            xfer += iprot->readListBegin(_etype261, _size258);
            this->thrift_attr_lists.resize(_size258);
            uint32_t _i262;
            for (_i262 = 0; _i262 < _size258; ++_i262)
            {
              xfer += this->thrift_attr_lists[_i262].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_count_lists.clear();
            uint32_t _size263;
            ::apache::thrift::protocol::TType _etype266;
            xfer += iprot->readListBegin(_etype266, _size263);
            this->thrift_attr_count_lists.resize(_size263);
            uint32_t _i267;
            for (_i267 = 0; _i267 < _size263; ++_i267)
            {
              xfer += iprot->readI32(this->thrift_attr_count_lists[_i267]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_count_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_members_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_members_args");

  xfer += oprot->writeFieldBegin("thrift_attr_lists", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_lists.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter268;
    for (_iter268 = this->thrift_attr_lists.begin(); _iter268 != this->thrift_attr_lists.end(); ++_iter268)
    {
      xfer += (*_iter268).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_count_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_count_lists.size()));
    std::vector<int32_t> ::const_iterator _iter269;
    for (_iter269 = this->thrift_attr_count_lists.begin(); _iter269 != this->thrift_attr_count_lists.end(); ++_iter269)
    {
      xfer += oprot->writeI32((*_iter269));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_members_pargs::~switch_sai_rpc_sai_thrift_create_vlan_members_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_members_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_members_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_lists", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_lists)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter270;
    for (_iter270 = (*(this->thrift_attr_lists)).begin(); _iter270 != (*(this->thrift_attr_lists)).end(); ++_iter270)
    {
      xfer += (*_iter270).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_count_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_count_lists)).size()));
    std::vector<int32_t> ::const_iterator _iter271;
    for (_iter271 = (*(this->thrift_attr_count_lists)).begin(); _iter271 != (*(this->thrift_attr_count_lists)).end(); ++_iter271)
    {
      xfer += oprot->writeI32((*_iter271));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_members_result::~switch_sai_rpc_sai_thrift_create_vlan_members_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_members_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_members_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_members_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_members_presult::~switch_sai_rpc_sai_thrift_create_vlan_members_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_members_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_members_args::~switch_sai_rpc_sai_thrift_remove_vlan_members_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_members_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_object_id_list.clear();
            uint32_t _size272;
            ::apache::thrift::protocol::TType _etype275;
            xfer += iprot->readListBegin(_etype275, _size272);
            this->thrift_object_id_list.resize(_size272);
            uint32_t _i276;
            for (_i276 = 0; _i276 < _size272; ++_i276)
            {
              xfer += iprot->readI64(this->thrift_object_id_list[_i276]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_object_id_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_members_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_members_args");

  xfer += oprot->writeFieldBegin("thrift_object_id_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->thrift_object_id_list.size()));
    std::vector<sai_thrift_object_id_t> ::const_iterator _iter277;
    for (_iter277 = this->thrift_object_id_list.begin(); _iter277 != this->thrift_object_id_list.end(); ++_iter277)
    {
      xfer += oprot->writeI64((*_iter277));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_members_pargs::~switch_sai_rpc_sai_thrift_remove_vlan_members_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_members_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_members_pargs");

  xfer += oprot->writeFieldBegin("thrift_object_id_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->thrift_object_id_list)).size()));
    std::vector<sai_thrift_object_id_t> ::const_iterator _iter278;
    for (_iter278 = (*(this->thrift_object_id_list)).begin(); _iter278 != (*(this->thrift_object_id_list)).end(); ++_iter278)
    {
      xfer += oprot->writeI64((*_iter278));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_members_result::~switch_sai_rpc_sai_thrift_remove_vlan_members_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_members_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_members_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_members_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_members_presult::~switch_sai_rpc_sai_thrift_remove_vlan_members_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_members_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_virtual_router_args::~switch_sai_rpc_sai_thrift_create_virtual_router_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size279;
            ::apache::thrift::protocol::TType _etype282;
            xfer += iprot->readListBegin(_etype282, _size279);
            this->thrift_attr_list.resize(_size279);
            uint32_t _i283;
            for (_i283 = 0; _i283 < _size279; ++_i283)
            {
              xfer += this->thrift_attr_list[_i283].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_virtual_router_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter284;
    for (_iter284 = this->thrift_attr_list.begin(); _iter284 != this->thrift_attr_list.end(); ++_iter284)
    {
      xfer += (*_iter284).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_virtual_router_pargs::~switch_sai_rpc_sai_thrift_create_virtual_router_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_virtual_router_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter285;
    for (_iter285 = (*(this->thrift_attr_list)).begin(); _iter285 != (*(this->thrift_attr_list)).end(); ++_iter285)
    {
      xfer += (*_iter285).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_virtual_router_result::~switch_sai_rpc_sai_thrift_create_virtual_router_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_virtual_router_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_virtual_router_presult::~switch_sai_rpc_sai_thrift_create_virtual_router_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_virtual_router_args::~switch_sai_rpc_sai_thrift_remove_virtual_router_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vr_id);
          this->__isset.vr_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_virtual_router_args");

  xfer += oprot->writeFieldBegin("vr_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vr_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_virtual_router_pargs::~switch_sai_rpc_sai_thrift_remove_virtual_router_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_virtual_router_pargs");

  xfer += oprot->writeFieldBegin("vr_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vr_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_virtual_router_result::~switch_sai_rpc_sai_thrift_remove_virtual_router_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_virtual_router_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_virtual_router_presult::~switch_sai_rpc_sai_thrift_remove_virtual_router_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_virtual_router_attribute_args::~switch_sai_rpc_sai_thrift_set_virtual_router_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_virtual_router_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vr_id);
          this->__isset.vr_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_virtual_router_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_virtual_router_attribute_args");

  xfer += oprot->writeFieldBegin("vr_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vr_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_virtual_router_attribute_pargs::~switch_sai_rpc_sai_thrift_set_virtual_router_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_virtual_router_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_virtual_router_attribute_pargs");

  xfer += oprot->writeFieldBegin("vr_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vr_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_virtual_router_attribute_result::~switch_sai_rpc_sai_thrift_set_virtual_router_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_virtual_router_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_virtual_router_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_virtual_router_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_virtual_router_attribute_presult::~switch_sai_rpc_sai_thrift_set_virtual_router_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_virtual_router_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_virtual_router_attribute_args::~switch_sai_rpc_sai_thrift_get_virtual_router_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_virtual_router_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vr_id);
          this->__isset.vr_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_virtual_router_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_virtual_router_attribute_args");

  xfer += oprot->writeFieldBegin("vr_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vr_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_virtual_router_attribute_pargs::~switch_sai_rpc_sai_thrift_get_virtual_router_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_virtual_router_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_virtual_router_attribute_pargs");

  xfer += oprot->writeFieldBegin("vr_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vr_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_virtual_router_attribute_result::~switch_sai_rpc_sai_thrift_get_virtual_router_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_virtual_router_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_virtual_router_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_virtual_router_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_virtual_router_attribute_presult::~switch_sai_rpc_sai_thrift_get_virtual_router_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_virtual_router_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_route_args::~switch_sai_rpc_sai_thrift_create_route_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_route_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_route_entry.read(iprot);
          this->__isset.thrift_route_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size286;
            ::apache::thrift::protocol::TType _etype289;
            xfer += iprot->readListBegin(_etype289, _size286);
            this->thrift_attr_list.resize(_size286);
            uint32_t _i290;
            for (_i290 = 0; _i290 < _size286; ++_i290)
            {
              xfer += this->thrift_attr_list[_i290].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_route_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_route_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_route_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter291;
    for (_iter291 = this->thrift_attr_list.begin(); _iter291 != this->thrift_attr_list.end(); ++_iter291)
    {
      xfer += (*_iter291).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_route_pargs::~switch_sai_rpc_sai_thrift_create_route_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_route_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_route_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_route_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter292;
    for (_iter292 = (*(this->thrift_attr_list)).begin(); _iter292 != (*(this->thrift_attr_list)).end(); ++_iter292)
    {
      xfer += (*_iter292).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_route_result::~switch_sai_rpc_sai_thrift_create_route_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_route_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_route_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_route_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_route_presult::~switch_sai_rpc_sai_thrift_create_route_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_route_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_route_args::~switch_sai_rpc_sai_thrift_remove_route_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_route_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_route_entry.read(iprot);
          this->__isset.thrift_route_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_route_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_route_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_route_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_route_pargs::~switch_sai_rpc_sai_thrift_remove_route_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_route_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_route_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_route_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_route_result::~switch_sai_rpc_sai_thrift_remove_route_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_route_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_route_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_route_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_route_presult::~switch_sai_rpc_sai_thrift_remove_route_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_route_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_route_attribute_args::~switch_sai_rpc_sai_thrift_set_route_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_route_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_route_entry.read(iprot);
          this->__isset.thrift_route_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_route_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_route_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_route_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_route_attribute_pargs::~switch_sai_rpc_sai_thrift_set_route_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_route_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_route_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_route_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_route_attribute_result::~switch_sai_rpc_sai_thrift_set_route_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_route_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_route_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_route_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_route_attribute_presult::~switch_sai_rpc_sai_thrift_set_route_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_route_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_route_attribute_args::~switch_sai_rpc_sai_thrift_get_route_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_route_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_route_entry.read(iprot);
          this->__isset.thrift_route_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_route_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_route_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_route_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_route_attribute_pargs::~switch_sai_rpc_sai_thrift_get_route_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_route_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_route_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_route_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_route_attribute_result::~switch_sai_rpc_sai_thrift_get_route_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_route_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_route_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_route_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_route_attribute_presult::~switch_sai_rpc_sai_thrift_get_route_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_route_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_routes_args::~switch_sai_rpc_sai_thrift_create_routes_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_routes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_route_entry_list.clear();
            uint32_t _size293;
            ::apache::thrift::protocol::TType _etype296;
            xfer += iprot->readListBegin(_etype296, _size293);
            this->thrift_route_entry_list.resize(_size293);
            uint32_t _i297;
            for (_i297 = 0; _i297 < _size293; ++_i297)
            {
              xfer += this->thrift_route_entry_list[_i297].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_route_entry_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size298;
            ::apache::thrift::protocol::TType _etype301;
            xfer += iprot->readListBegin(_etype301, _size298);
            this->thrift_attr_list.resize(_size298);
            uint32_t _i302;
            for (_i302 = 0; _i302 < _size298; ++_i302)
            {
              xfer += this->thrift_attr_list[_i302].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_count_lists.clear();
            uint32_t _size303;
            ::apache::thrift::protocol::TType _etype306;
            xfer += iprot->readListBegin(_etype306, _size303);
            this->thrift_attr_count_lists.resize(_size303);
            uint32_t _i307;
            for (_i307 = 0; _i307 < _size303; ++_i307)
            {
              xfer += iprot->readI32(this->thrift_attr_count_lists[_i307]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_count_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_routes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_routes_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_route_entry_list.size()));
    std::vector<sai_thrift_route_entry_t> ::const_iterator _iter308;
    for (_iter308 = this->thrift_route_entry_list.begin(); _iter308 != this->thrift_route_entry_list.end(); ++_iter308)
    {
      xfer += (*_iter308).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter309;
    for (_iter309 = this->thrift_attr_list.begin(); _iter309 != this->thrift_attr_list.end(); ++_iter309)
    {
      xfer += (*_iter309).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_count_lists", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_count_lists.size()));
    std::vector<int32_t> ::const_iterator _iter310;
    for (_iter310 = this->thrift_attr_count_lists.begin(); _iter310 != this->thrift_attr_count_lists.end(); ++_iter310)
    {
      xfer += oprot->writeI32((*_iter310));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_routes_pargs::~switch_sai_rpc_sai_thrift_create_routes_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_routes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_routes_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_route_entry_list)).size()));
    std::vector<sai_thrift_route_entry_t> ::const_iterator _iter311;
    for (_iter311 = (*(this->thrift_route_entry_list)).begin(); _iter311 != (*(this->thrift_route_entry_list)).end(); ++_iter311)
    {
      xfer += (*_iter311).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter312;
    for (_iter312 = (*(this->thrift_attr_list)).begin(); _iter312 != (*(this->thrift_attr_list)).end(); ++_iter312)
    {
      xfer += (*_iter312).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_count_lists", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_count_lists)).size()));
    std::vector<int32_t> ::const_iterator _iter313;
    for (_iter313 = (*(this->thrift_attr_count_lists)).begin(); _iter313 != (*(this->thrift_attr_count_lists)).end(); ++_iter313)
    {
      xfer += oprot->writeI32((*_iter313));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_routes_result::~switch_sai_rpc_sai_thrift_create_routes_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_routes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_routes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_routes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_routes_presult::~switch_sai_rpc_sai_thrift_create_routes_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_routes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_routes_args::~switch_sai_rpc_sai_thrift_remove_routes_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_routes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_route_entry_list.clear();
            uint32_t _size314;
            ::apache::thrift::protocol::TType _etype317;
            xfer += iprot->readListBegin(_etype317, _size314);
            this->thrift_route_entry_list.resize(_size314);
            uint32_t _i318;
            for (_i318 = 0; _i318 < _size314; ++_i318)
            {
              xfer += this->thrift_route_entry_list[_i318].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_route_entry_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_routes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_routes_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_route_entry_list.size()));
    std::vector<sai_thrift_route_entry_t> ::const_iterator _iter319;
    for (_iter319 = this->thrift_route_entry_list.begin(); _iter319 != this->thrift_route_entry_list.end(); ++_iter319)
    {
      xfer += (*_iter319).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_routes_pargs::~switch_sai_rpc_sai_thrift_remove_routes_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_routes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_routes_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_route_entry_list)).size()));
    std::vector<sai_thrift_route_entry_t> ::const_iterator _iter320;
    for (_iter320 = (*(this->thrift_route_entry_list)).begin(); _iter320 != (*(this->thrift_route_entry_list)).end(); ++_iter320)
    {
      xfer += (*_iter320).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_routes_result::~switch_sai_rpc_sai_thrift_remove_routes_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_routes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_routes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_routes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_routes_presult::~switch_sai_rpc_sai_thrift_remove_routes_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_routes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_routes_attribute_args::~switch_sai_rpc_sai_thrift_set_routes_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_routes_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_route_entry_list.clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            this->thrift_route_entry_list.resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              xfer += this->thrift_route_entry_list[_i325].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_route_entry_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size326;
            ::apache::thrift::protocol::TType _etype329;
            xfer += iprot->readListBegin(_etype329, _size326);
            this->thrift_attr_list.resize(_size326);
            uint32_t _i330;
            for (_i330 = 0; _i330 < _size326; ++_i330)
            {
              xfer += this->thrift_attr_list[_i330].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_routes_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_routes_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_route_entry_list.size()));
    std::vector<sai_thrift_route_entry_t> ::const_iterator _iter331;
    for (_iter331 = this->thrift_route_entry_list.begin(); _iter331 != this->thrift_route_entry_list.end(); ++_iter331)
    {
      xfer += (*_iter331).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter332;
    for (_iter332 = this->thrift_attr_list.begin(); _iter332 != this->thrift_attr_list.end(); ++_iter332)
    {
      xfer += (*_iter332).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_routes_attribute_pargs::~switch_sai_rpc_sai_thrift_set_routes_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_routes_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_routes_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_route_entry_list)).size()));
    std::vector<sai_thrift_route_entry_t> ::const_iterator _iter333;
    for (_iter333 = (*(this->thrift_route_entry_list)).begin(); _iter333 != (*(this->thrift_route_entry_list)).end(); ++_iter333)
    {
      xfer += (*_iter333).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter334;
    for (_iter334 = (*(this->thrift_attr_list)).begin(); _iter334 != (*(this->thrift_attr_list)).end(); ++_iter334)
    {
      xfer += (*_iter334).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_routes_attribute_result::~switch_sai_rpc_sai_thrift_set_routes_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_routes_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_routes_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_routes_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_routes_attribute_presult::~switch_sai_rpc_sai_thrift_set_routes_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_routes_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_routes_attribute_args::~switch_sai_rpc_sai_thrift_get_routes_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_routes_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_route_entry_list.clear();
            uint32_t _size335;
            ::apache::thrift::protocol::TType _etype338;
            xfer += iprot->readListBegin(_etype338, _size335);
            this->thrift_route_entry_list.resize(_size335);
            uint32_t _i339;
            for (_i339 = 0; _i339 < _size335; ++_i339)
            {
              xfer += this->thrift_route_entry_list[_i339].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_route_entry_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_routes_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_routes_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_route_entry_list.size()));
    std::vector<sai_thrift_route_entry_t> ::const_iterator _iter340;
    for (_iter340 = this->thrift_route_entry_list.begin(); _iter340 != this->thrift_route_entry_list.end(); ++_iter340)
    {
      xfer += (*_iter340).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_routes_attribute_pargs::~switch_sai_rpc_sai_thrift_get_routes_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_routes_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_routes_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_route_entry_list)).size()));
    std::vector<sai_thrift_route_entry_t> ::const_iterator _iter341;
    for (_iter341 = (*(this->thrift_route_entry_list)).begin(); _iter341 != (*(this->thrift_route_entry_list)).end(); ++_iter341)
    {
      xfer += (*_iter341).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_routes_attribute_result::~switch_sai_rpc_sai_thrift_get_routes_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_routes_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_routes_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_routes_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_routes_attribute_presult::~switch_sai_rpc_sai_thrift_get_routes_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_routes_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_router_interface_args::~switch_sai_rpc_sai_thrift_create_router_interface_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_router_interface_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size342;
            ::apache::thrift::protocol::TType _etype345;
            xfer += iprot->readListBegin(_etype345, _size342);
            this->thrift_attr_list.resize(_size342);
            uint32_t _i346;
            for (_i346 = 0; _i346 < _size342; ++_i346)
            {
              xfer += this->thrift_attr_list[_i346].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_router_interface_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_router_interface_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter347;
    for (_iter347 = this->thrift_attr_list.begin(); _iter347 != this->thrift_attr_list.end(); ++_iter347)
    {
      xfer += (*_iter347).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_router_interface_pargs::~switch_sai_rpc_sai_thrift_create_router_interface_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_router_interface_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_router_interface_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter348;
    for (_iter348 = (*(this->thrift_attr_list)).begin(); _iter348 != (*(this->thrift_attr_list)).end(); ++_iter348)
    {
      xfer += (*_iter348).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_router_interface_result::~switch_sai_rpc_sai_thrift_create_router_interface_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_router_interface_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_router_interface_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_router_interface_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_router_interface_presult::~switch_sai_rpc_sai_thrift_create_router_interface_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_router_interface_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_router_interface_args::~switch_sai_rpc_sai_thrift_remove_router_interface_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rif_id);
          this->__isset.rif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_router_interface_args");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_router_interface_pargs::~switch_sai_rpc_sai_thrift_remove_router_interface_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_router_interface_pargs");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->rif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_router_interface_result::~switch_sai_rpc_sai_thrift_remove_router_interface_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_router_interface_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_router_interface_presult::~switch_sai_rpc_sai_thrift_remove_router_interface_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_router_interface_attribute_args::~switch_sai_rpc_sai_thrift_set_router_interface_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rif_id);
          this->__isset.rif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_router_interface_attribute_args");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs::~switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->rif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_router_interface_attribute_result::~switch_sai_rpc_sai_thrift_set_router_interface_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_router_interface_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult::~switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_router_interface_attribute_args::~switch_sai_rpc_sai_thrift_get_router_interface_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_router_interface_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rif_id);
          this->__isset.rif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_router_interface_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_router_interface_attribute_args");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_router_interface_attribute_pargs::~switch_sai_rpc_sai_thrift_get_router_interface_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_router_interface_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_router_interface_attribute_pargs");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->rif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_router_interface_attribute_result::~switch_sai_rpc_sai_thrift_get_router_interface_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_router_interface_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_router_interface_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_router_interface_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_router_interface_attribute_presult::~switch_sai_rpc_sai_thrift_get_router_interface_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_router_interface_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_get_stats_args::~switch_sai_rpc_sai_thrift_router_interface_get_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rif_id);
          this->__isset.rif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size349;
            ::apache::thrift::protocol::TType _etype352;
            xfer += iprot->readListBegin(_etype352, _size349);
            this->thrift_counter_ids.resize(_size349);
            uint32_t _i353;
            for (_i353 = 0; _i353 < _size349; ++_i353)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i353]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_get_stats_args");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_router_interface_stat_counter_t> ::const_iterator _iter354;
    for (_iter354 = this->thrift_counter_ids.begin(); _iter354 != this->thrift_counter_ids.end(); ++_iter354)
    {
      xfer += oprot->writeI32((*_iter354));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_get_stats_pargs::~switch_sai_rpc_sai_thrift_router_interface_get_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_get_stats_pargs");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->rif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_router_interface_stat_counter_t> ::const_iterator _iter355;
    for (_iter355 = (*(this->thrift_counter_ids)).begin(); _iter355 != (*(this->thrift_counter_ids)).end(); ++_iter355)
    {
      xfer += oprot->writeI32((*_iter355));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_get_stats_result::~switch_sai_rpc_sai_thrift_router_interface_get_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size356;
            ::apache::thrift::protocol::TType _etype359;
            xfer += iprot->readListBegin(_etype359, _size356);
            this->success.resize(_size356);
            uint32_t _i360;
            for (_i360 = 0; _i360 < _size356; ++_i360)
            {
              xfer += iprot->readI64(this->success[_i360]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_get_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter361;
      for (_iter361 = this->success.begin(); _iter361 != this->success.end(); ++_iter361)
      {
        xfer += oprot->writeI64((*_iter361));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_get_stats_presult::~switch_sai_rpc_sai_thrift_router_interface_get_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _etype365;
            xfer += iprot->readListBegin(_etype365, _size362);
            (*(this->success)).resize(_size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              xfer += iprot->readI64((*(this->success))[_i366]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_args::~switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rif_id);
          this->__isset.rif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size367;
            ::apache::thrift::protocol::TType _etype370;
            xfer += iprot->readListBegin(_etype370, _size367);
            this->thrift_counter_ids.resize(_size367);
            uint32_t _i371;
            for (_i371 = 0; _i371 < _size367; ++_i371)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i371]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_args");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_router_interface_stat_counter_t> ::const_iterator _iter372;
    for (_iter372 = this->thrift_counter_ids.begin(); _iter372 != this->thrift_counter_ids.end(); ++_iter372)
    {
      xfer += oprot->writeI32((*_iter372));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_pargs::~switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_pargs");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->rif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_router_interface_stat_counter_t> ::const_iterator _iter373;
    for (_iter373 = (*(this->thrift_counter_ids)).begin(); _iter373 != (*(this->thrift_counter_ids)).end(); ++_iter373)
    {
      xfer += oprot->writeI32((*_iter373));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_result::~switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size374;
            ::apache::thrift::protocol::TType _etype377;
            xfer += iprot->readListBegin(_etype377, _size374);
            this->success.resize(_size374);
            uint32_t _i378;
            for (_i378 = 0; _i378 < _size374; ++_i378)
            {
              xfer += iprot->readI64(this->success[_i378]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter379;
      for (_iter379 = this->success.begin(); _iter379 != this->success.end(); ++_iter379)
      {
        xfer += oprot->writeI64((*_iter379));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_presult::~switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size380;
            ::apache::thrift::protocol::TType _etype383;
            xfer += iprot->readListBegin(_etype383, _size380);
            (*(this->success)).resize(_size380);
            uint32_t _i384;
            for (_i384 = 0; _i384 < _size380; ++_i384)
            {
              xfer += iprot->readI64((*(this->success))[_i384]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_clear_stats_args::~switch_sai_rpc_sai_thrift_router_interface_clear_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_clear_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rif_id);
          this->__isset.rif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size385;
            ::apache::thrift::protocol::TType _etype388;
            xfer += iprot->readListBegin(_etype388, _size385);
            this->thrift_counter_ids.resize(_size385);
            uint32_t _i389;
            for (_i389 = 0; _i389 < _size385; ++_i389)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i389]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_router_interface_clear_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_clear_stats_args");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_router_interface_stat_counter_t> ::const_iterator _iter390;
    for (_iter390 = this->thrift_counter_ids.begin(); _iter390 != this->thrift_counter_ids.end(); ++_iter390)
    {
      xfer += oprot->writeI32((*_iter390));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_clear_stats_pargs::~switch_sai_rpc_sai_thrift_router_interface_clear_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_clear_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_clear_stats_pargs");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->rif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_router_interface_stat_counter_t> ::const_iterator _iter391;
    for (_iter391 = (*(this->thrift_counter_ids)).begin(); _iter391 != (*(this->thrift_counter_ids)).end(); ++_iter391)
    {
      xfer += oprot->writeI32((*_iter391));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_clear_stats_result::~switch_sai_rpc_sai_thrift_router_interface_clear_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_clear_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_router_interface_clear_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_router_interface_clear_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_router_interface_clear_stats_presult::~switch_sai_rpc_sai_thrift_router_interface_clear_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_router_interface_clear_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_args::~switch_sai_rpc_sai_thrift_create_next_hop_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size392;
            ::apache::thrift::protocol::TType _etype395;
            xfer += iprot->readListBegin(_etype395, _size392);
            this->thrift_attr_list.resize(_size392);
            uint32_t _i396;
            for (_i396 = 0; _i396 < _size392; ++_i396)
            {
              xfer += this->thrift_attr_list[_i396].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter397;
    for (_iter397 = this->thrift_attr_list.begin(); _iter397 != this->thrift_attr_list.end(); ++_iter397)
    {
      xfer += (*_iter397).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_pargs::~switch_sai_rpc_sai_thrift_create_next_hop_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter398;
    for (_iter398 = (*(this->thrift_attr_list)).begin(); _iter398 != (*(this->thrift_attr_list)).end(); ++_iter398)
    {
      xfer += (*_iter398).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_result::~switch_sai_rpc_sai_thrift_create_next_hop_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_presult::~switch_sai_rpc_sai_thrift_create_next_hop_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_args::~switch_sai_rpc_sai_thrift_remove_next_hop_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->next_hop_id);
          this->__isset.next_hop_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_args");

  xfer += oprot->writeFieldBegin("next_hop_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->next_hop_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_pargs::~switch_sai_rpc_sai_thrift_remove_next_hop_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_pargs");

  xfer += oprot->writeFieldBegin("next_hop_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->next_hop_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_result::~switch_sai_rpc_sai_thrift_remove_next_hop_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_presult::~switch_sai_rpc_sai_thrift_remove_next_hop_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_attribute_args::~switch_sai_rpc_sai_thrift_get_next_hop_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->next_hop_id);
          this->__isset.next_hop_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_next_hop_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_attribute_args");

  xfer += oprot->writeFieldBegin("next_hop_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->next_hop_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_attribute_pargs::~switch_sai_rpc_sai_thrift_get_next_hop_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_attribute_pargs");

  xfer += oprot->writeFieldBegin("next_hop_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->next_hop_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_attribute_result::~switch_sai_rpc_sai_thrift_get_next_hop_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_next_hop_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_attribute_presult::~switch_sai_rpc_sai_thrift_get_next_hop_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_args::~switch_sai_rpc_sai_thrift_create_next_hop_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size399;
            ::apache::thrift::protocol::TType _etype402;
            xfer += iprot->readListBegin(_etype402, _size399);
            this->thrift_attr_list.resize(_size399);
            uint32_t _i403;
            for (_i403 = 0; _i403 < _size399; ++_i403)
            {
              xfer += this->thrift_attr_list[_i403].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter404;
    for (_iter404 = this->thrift_attr_list.begin(); _iter404 != this->thrift_attr_list.end(); ++_iter404)
    {
      xfer += (*_iter404).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_pargs::~switch_sai_rpc_sai_thrift_create_next_hop_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter405;
    for (_iter405 = (*(this->thrift_attr_list)).begin(); _iter405 != (*(this->thrift_attr_list)).end(); ++_iter405)
    {
      xfer += (*_iter405).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_result::~switch_sai_rpc_sai_thrift_create_next_hop_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_presult::~switch_sai_rpc_sai_thrift_create_next_hop_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_args::~switch_sai_rpc_sai_thrift_remove_next_hop_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nhop_group_oid);
          this->__isset.nhop_group_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_args");

  xfer += oprot->writeFieldBegin("nhop_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nhop_group_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs::~switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs");

  xfer += oprot->writeFieldBegin("nhop_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nhop_group_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_result::~switch_sai_rpc_sai_thrift_remove_next_hop_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_presult::~switch_sai_rpc_sai_thrift_remove_next_hop_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_args::~switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nhop_group_oid);
          this->__isset.nhop_group_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_args");

  xfer += oprot->writeFieldBegin("nhop_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nhop_group_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_pargs::~switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("nhop_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nhop_group_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_result::~switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_presult::~switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_args::~switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nhop_group_oid);
          this->__isset.nhop_group_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_args");

  xfer += oprot->writeFieldBegin("nhop_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nhop_group_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("nhop_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nhop_group_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_result::~switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_member_args::~switch_sai_rpc_sai_thrift_create_next_hop_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size406;
            ::apache::thrift::protocol::TType _etype409;
            xfer += iprot->readListBegin(_etype409, _size406);
            this->thrift_attr_list.resize(_size406);
            uint32_t _i410;
            for (_i410 = 0; _i410 < _size406; ++_i410)
            {
              xfer += this->thrift_attr_list[_i410].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter411;
    for (_iter411 = this->thrift_attr_list.begin(); _iter411 != this->thrift_attr_list.end(); ++_iter411)
    {
      xfer += (*_iter411).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs::~switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter412;
    for (_iter412 = (*(this->thrift_attr_list)).begin(); _iter412 != (*(this->thrift_attr_list)).end(); ++_iter412)
    {
      xfer += (*_iter412).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_member_result::~switch_sai_rpc_sai_thrift_create_next_hop_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult::~switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args::~switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nhop_group_member_oid);
          this->__isset.nhop_group_member_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args");

  xfer += oprot->writeFieldBegin("nhop_group_member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nhop_group_member_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs::~switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs");

  xfer += oprot->writeFieldBegin("nhop_group_member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nhop_group_member_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result::~switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult::~switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_args::~switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nhop_group_member_oid);
          this->__isset.nhop_group_member_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_args");

  xfer += oprot->writeFieldBegin("nhop_group_member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nhop_group_member_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("nhop_group_member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nhop_group_member_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_result::~switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_args::~switch_sai_rpc_sai_thrift_create_lag_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size413;
            ::apache::thrift::protocol::TType _etype416;
            xfer += iprot->readListBegin(_etype416, _size413);
            this->thrift_attr_list.resize(_size413);
            uint32_t _i417;
            for (_i417 = 0; _i417 < _size413; ++_i417)
            {
              xfer += this->thrift_attr_list[_i417].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_lag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter418;
    for (_iter418 = this->thrift_attr_list.begin(); _iter418 != this->thrift_attr_list.end(); ++_iter418)
    {
      xfer += (*_iter418).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_pargs::~switch_sai_rpc_sai_thrift_create_lag_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter419;
    for (_iter419 = (*(this->thrift_attr_list)).begin(); _iter419 != (*(this->thrift_attr_list)).end(); ++_iter419)
    {
      xfer += (*_iter419).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_result::~switch_sai_rpc_sai_thrift_create_lag_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_lag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_presult::~switch_sai_rpc_sai_thrift_create_lag_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_args::~switch_sai_rpc_sai_thrift_remove_lag_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_id);
          this->__isset.lag_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_lag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_args");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_pargs::~switch_sai_rpc_sai_thrift_remove_lag_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_pargs");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_result::~switch_sai_rpc_sai_thrift_remove_lag_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_lag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_presult::~switch_sai_rpc_sai_thrift_remove_lag_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_attribute_args::~switch_sai_rpc_sai_thrift_set_lag_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_id);
          this->__isset.lag_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_attribute_args");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_attribute_pargs::~switch_sai_rpc_sai_thrift_set_lag_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_attribute_pargs");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_attribute_result::~switch_sai_rpc_sai_thrift_set_lag_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_attribute_presult::~switch_sai_rpc_sai_thrift_set_lag_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_attribute_args::~switch_sai_rpc_sai_thrift_get_lag_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_id);
          this->__isset.lag_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_lag_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_attribute_args");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_attribute_pargs::~switch_sai_rpc_sai_thrift_get_lag_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_attribute_pargs");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_attribute_result::~switch_sai_rpc_sai_thrift_get_lag_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_lag_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_attribute_presult::~switch_sai_rpc_sai_thrift_get_lag_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_member_args::~switch_sai_rpc_sai_thrift_create_lag_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size420;
            ::apache::thrift::protocol::TType _etype423;
            xfer += iprot->readListBegin(_etype423, _size420);
            this->thrift_attr_list.resize(_size420);
            uint32_t _i424;
            for (_i424 = 0; _i424 < _size420; ++_i424)
            {
              xfer += this->thrift_attr_list[_i424].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_lag_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter425;
    for (_iter425 = this->thrift_attr_list.begin(); _iter425 != this->thrift_attr_list.end(); ++_iter425)
    {
      xfer += (*_iter425).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_member_pargs::~switch_sai_rpc_sai_thrift_create_lag_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter426;
    for (_iter426 = (*(this->thrift_attr_list)).begin(); _iter426 != (*(this->thrift_attr_list)).end(); ++_iter426)
    {
      xfer += (*_iter426).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_member_result::~switch_sai_rpc_sai_thrift_create_lag_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_lag_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_member_presult::~switch_sai_rpc_sai_thrift_create_lag_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_member_args::~switch_sai_rpc_sai_thrift_remove_lag_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_member_id);
          this->__isset.lag_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_member_args");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_member_pargs::~switch_sai_rpc_sai_thrift_remove_lag_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_member_pargs");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_member_result::~switch_sai_rpc_sai_thrift_remove_lag_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_member_presult::~switch_sai_rpc_sai_thrift_remove_lag_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_member_attribute_args::~switch_sai_rpc_sai_thrift_set_lag_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_member_id);
          this->__isset.lag_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_lag_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_member_attribute_args");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_member_attribute_pargs::~switch_sai_rpc_sai_thrift_set_lag_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_member_attribute_result::~switch_sai_rpc_sai_thrift_set_lag_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_lag_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_member_attribute_presult::~switch_sai_rpc_sai_thrift_set_lag_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_member_attribute_args::~switch_sai_rpc_sai_thrift_get_lag_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_member_id);
          this->__isset.lag_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_member_attribute_args");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_member_attribute_result::~switch_sai_rpc_sai_thrift_get_lag_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_entry_args::~switch_sai_rpc_sai_thrift_create_stp_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size427;
            ::apache::thrift::protocol::TType _etype430;
            xfer += iprot->readListBegin(_etype430, _size427);
            this->thrift_attr_list.resize(_size427);
            uint32_t _i431;
            for (_i431 = 0; _i431 < _size427; ++_i431)
            {
              xfer += this->thrift_attr_list[_i431].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter432;
    for (_iter432 = this->thrift_attr_list.begin(); _iter432 != this->thrift_attr_list.end(); ++_iter432)
    {
      xfer += (*_iter432).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_entry_pargs::~switch_sai_rpc_sai_thrift_create_stp_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter433;
    for (_iter433 = (*(this->thrift_attr_list)).begin(); _iter433 != (*(this->thrift_attr_list)).end(); ++_iter433)
    {
      xfer += (*_iter433).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_entry_result::~switch_sai_rpc_sai_thrift_create_stp_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_entry_presult::~switch_sai_rpc_sai_thrift_create_stp_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_entry_args::~switch_sai_rpc_sai_thrift_remove_stp_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_id);
          this->__isset.stp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_entry_args");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_entry_pargs::~switch_sai_rpc_sai_thrift_remove_stp_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_entry_pargs");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_entry_result::~switch_sai_rpc_sai_thrift_remove_stp_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_entry_presult::~switch_sai_rpc_sai_thrift_remove_stp_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_attribute_args::~switch_sai_rpc_sai_thrift_get_stp_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_id);
          this->__isset.stp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_stp_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_attribute_args");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_attribute_pargs::~switch_sai_rpc_sai_thrift_get_stp_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_attribute_pargs");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_attribute_result::~switch_sai_rpc_sai_thrift_get_stp_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_stp_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_attribute_presult::~switch_sai_rpc_sai_thrift_get_stp_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_port_args::~switch_sai_rpc_sai_thrift_create_stp_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size434;
            ::apache::thrift::protocol::TType _etype437;
            xfer += iprot->readListBegin(_etype437, _size434);
            this->thrift_attr_list.resize(_size434);
            uint32_t _i438;
            for (_i438 = 0; _i438 < _size434; ++_i438)
            {
              xfer += this->thrift_attr_list[_i438].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_stp_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_port_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter439;
    for (_iter439 = this->thrift_attr_list.begin(); _iter439 != this->thrift_attr_list.end(); ++_iter439)
    {
      xfer += (*_iter439).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_port_pargs::~switch_sai_rpc_sai_thrift_create_stp_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_port_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter440;
    for (_iter440 = (*(this->thrift_attr_list)).begin(); _iter440 != (*(this->thrift_attr_list)).end(); ++_iter440)
    {
      xfer += (*_iter440).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_port_result::~switch_sai_rpc_sai_thrift_create_stp_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_stp_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_port_presult::~switch_sai_rpc_sai_thrift_create_stp_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_port_args::~switch_sai_rpc_sai_thrift_remove_stp_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_port_id);
          this->__isset.stp_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_stp_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_port_args");

  xfer += oprot->writeFieldBegin("stp_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_port_pargs::~switch_sai_rpc_sai_thrift_remove_stp_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_port_pargs");

  xfer += oprot->writeFieldBegin("stp_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_port_result::~switch_sai_rpc_sai_thrift_remove_stp_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_stp_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_port_presult::~switch_sai_rpc_sai_thrift_remove_stp_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_attribute_args::~switch_sai_rpc_sai_thrift_get_stp_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_port_id);
          this->__isset.stp_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_stp_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_attribute_args");

  xfer += oprot->writeFieldBegin("stp_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_attribute_pargs::~switch_sai_rpc_sai_thrift_get_stp_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("stp_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_attribute_result::~switch_sai_rpc_sai_thrift_get_stp_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_stp_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_attribute_presult::~switch_sai_rpc_sai_thrift_get_stp_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_stp_port_state_args::~switch_sai_rpc_sai_thrift_set_stp_port_state_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_id);
          this->__isset.stp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->stp_port_state);
          this->__isset.stp_port_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_stp_port_state_args");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stp_port_state", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->stp_port_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_stp_port_state_pargs::~switch_sai_rpc_sai_thrift_set_stp_port_state_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_stp_port_state_pargs");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stp_port_state", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->stp_port_state)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_stp_port_state_result::~switch_sai_rpc_sai_thrift_set_stp_port_state_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_stp_port_state_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_stp_port_state_presult::~switch_sai_rpc_sai_thrift_set_stp_port_state_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_state_args::~switch_sai_rpc_sai_thrift_get_stp_port_state_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_id);
          this->__isset.stp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_state_args");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_state_pargs::~switch_sai_rpc_sai_thrift_get_stp_port_state_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_state_pargs");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_state_result::~switch_sai_rpc_sai_thrift_get_stp_port_state_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_state_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BYTE, 0);
    xfer += oprot->writeByte(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_state_presult::~switch_sai_rpc_sai_thrift_get_stp_port_state_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_ports_args::~switch_sai_rpc_sai_thrift_create_stp_ports_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_ports_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_lists.clear();
            uint32_t _size441;
            ::apache::thrift::protocol::TType _etype444;
            xfer += iprot->readListBegin(_etype444, _size441);
            this->thrift_attr_lists.resize(_size441);
            uint32_t _i445;
            for (_i445 = 0; _i445 < _size441; ++_i445)
            {
              xfer += this->thrift_attr_lists[_i445].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_count_lists.clear();
            uint32_t _size446;
            ::apache::thrift::protocol::TType _etype449;
            xfer += iprot->readListBegin(_etype449, _size446);
            this->thrift_attr_count_lists.resize(_size446);
            uint32_t _i450;
            for (_i450 = 0; _i450 < _size446; ++_i450)
            {
              xfer += iprot->readI32(this->thrift_attr_count_lists[_i450]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_count_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_stp_ports_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_ports_args");

  xfer += oprot->writeFieldBegin("thrift_attr_lists", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_lists.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter451;
    for (_iter451 = this->thrift_attr_lists.begin(); _iter451 != this->thrift_attr_lists.end(); ++_iter451)
    {
      xfer += (*_iter451).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_count_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_count_lists.size()));
    std::vector<int32_t> ::const_iterator _iter452;
    for (_iter452 = this->thrift_attr_count_lists.begin(); _iter452 != this->thrift_attr_count_lists.end(); ++_iter452)
    {
      xfer += oprot->writeI32((*_iter452));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_ports_pargs::~switch_sai_rpc_sai_thrift_create_stp_ports_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_ports_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_ports_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_lists", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_lists)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter453;
    for (_iter453 = (*(this->thrift_attr_lists)).begin(); _iter453 != (*(this->thrift_attr_lists)).end(); ++_iter453)
    {
      xfer += (*_iter453).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_count_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_count_lists)).size()));
    std::vector<int32_t> ::const_iterator _iter454;
    for (_iter454 = (*(this->thrift_attr_count_lists)).begin(); _iter454 != (*(this->thrift_attr_count_lists)).end(); ++_iter454)
    {
      xfer += oprot->writeI32((*_iter454));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_ports_result::~switch_sai_rpc_sai_thrift_create_stp_ports_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_ports_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_stp_ports_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_ports_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_ports_presult::~switch_sai_rpc_sai_thrift_create_stp_ports_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_ports_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_ports_args::~switch_sai_rpc_sai_thrift_remove_stp_ports_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_ports_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_object_id_list.clear();
            uint32_t _size455;
            ::apache::thrift::protocol::TType _etype458;
            xfer += iprot->readListBegin(_etype458, _size455);
            this->thrift_object_id_list.resize(_size455);
            uint32_t _i459;
            for (_i459 = 0; _i459 < _size455; ++_i459)
            {
              xfer += iprot->readI64(this->thrift_object_id_list[_i459]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_object_id_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_stp_ports_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_ports_args");

  xfer += oprot->writeFieldBegin("thrift_object_id_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->thrift_object_id_list.size()));
    std::vector<sai_thrift_object_id_t> ::const_iterator _iter460;
    for (_iter460 = this->thrift_object_id_list.begin(); _iter460 != this->thrift_object_id_list.end(); ++_iter460)
    {
      xfer += oprot->writeI64((*_iter460));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_ports_pargs::~switch_sai_rpc_sai_thrift_remove_stp_ports_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_ports_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_ports_pargs");

  xfer += oprot->writeFieldBegin("thrift_object_id_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->thrift_object_id_list)).size()));
    std::vector<sai_thrift_object_id_t> ::const_iterator _iter461;
    for (_iter461 = (*(this->thrift_object_id_list)).begin(); _iter461 != (*(this->thrift_object_id_list)).end(); ++_iter461)
    {
      xfer += oprot->writeI64((*_iter461));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_ports_result::~switch_sai_rpc_sai_thrift_remove_stp_ports_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_ports_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_stp_ports_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_ports_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_ports_presult::~switch_sai_rpc_sai_thrift_remove_stp_ports_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_ports_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_neighbor_entry_args::~switch_sai_rpc_sai_thrift_create_neighbor_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_neighbor_entry.read(iprot);
          this->__isset.thrift_neighbor_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size462;
            ::apache::thrift::protocol::TType _etype465;
            xfer += iprot->readListBegin(_etype465, _size462);
            this->thrift_attr_list.resize(_size462);
            uint32_t _i466;
            for (_i466 = 0; _i466 < _size462; ++_i466)
            {
              xfer += this->thrift_attr_list[_i466].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_neighbor_entry_args");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_neighbor_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter467;
    for (_iter467 = this->thrift_attr_list.begin(); _iter467 != this->thrift_attr_list.end(); ++_iter467)
    {
      xfer += (*_iter467).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs::~switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_neighbor_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter468;
    for (_iter468 = (*(this->thrift_attr_list)).begin(); _iter468 != (*(this->thrift_attr_list)).end(); ++_iter468)
    {
      xfer += (*_iter468).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_neighbor_entry_result::~switch_sai_rpc_sai_thrift_create_neighbor_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_neighbor_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_neighbor_entry_presult::~switch_sai_rpc_sai_thrift_create_neighbor_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_neighbor_entry_args::~switch_sai_rpc_sai_thrift_remove_neighbor_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_neighbor_entry.read(iprot);
          this->__isset.thrift_neighbor_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_neighbor_entry_args");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_neighbor_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs::~switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_neighbor_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_neighbor_entry_result::~switch_sai_rpc_sai_thrift_remove_neighbor_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_neighbor_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult::~switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_args::~switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_pargs::~switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_result::~switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_presult::~switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_neighbor_entry.read(iprot);
          this->__isset.thrift_neighbor_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_neighbor_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_neighbor_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_neighbor_entry.read(iprot);
          this->__isset.thrift_neighbor_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_neighbor_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_neighbor_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_attribute_args::~switch_sai_rpc_sai_thrift_get_switch_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_ids.clear();
            uint32_t _size469;
            ::apache::thrift::protocol::TType _etype472;
            xfer += iprot->readListBegin(_etype472, _size469);
            this->thrift_attr_ids.resize(_size469);
            uint32_t _i473;
            for (_i473 = 0; _i473 < _size469; ++_i473)
            {
              xfer += iprot->readI32(this->thrift_attr_ids[_i473]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_ids.size()));
    std::vector<int32_t> ::const_iterator _iter474;
    for (_iter474 = this->thrift_attr_ids.begin(); _iter474 != this->thrift_attr_ids.end(); ++_iter474)
    {
      xfer += oprot->writeI32((*_iter474));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_attribute_pargs::~switch_sai_rpc_sai_thrift_get_switch_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_ids)).size()));
    std::vector<int32_t> ::const_iterator _iter475;
    for (_iter475 = (*(this->thrift_attr_ids)).begin(); _iter475 != (*(this->thrift_attr_ids)).end(); ++_iter475)
    {
      xfer += oprot->writeI32((*_iter475));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_attribute_result::~switch_sai_rpc_sai_thrift_get_switch_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_attribute_presult::~switch_sai_rpc_sai_thrift_get_switch_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args::~switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs::~switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result::~switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult::~switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_port_id_args::~switch_sai_rpc_sai_thrift_get_cpu_port_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_port_id_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs::~switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_port_id_result::~switch_sai_rpc_sai_thrift_get_cpu_port_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_port_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_port_id_presult::~switch_sai_rpc_sai_thrift_get_cpu_port_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_trap_group_args::~switch_sai_rpc_sai_thrift_get_default_trap_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_trap_group_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_trap_group_pargs::~switch_sai_rpc_sai_thrift_get_default_trap_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_trap_group_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_trap_group_result::~switch_sai_rpc_sai_thrift_get_default_trap_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_trap_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_trap_group_presult::~switch_sai_rpc_sai_thrift_get_default_trap_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_router_id_args::~switch_sai_rpc_sai_thrift_get_default_router_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_router_id_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_router_id_pargs::~switch_sai_rpc_sai_thrift_get_default_router_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_router_id_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_router_id_result::~switch_sai_rpc_sai_thrift_get_default_router_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_router_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_router_id_presult::~switch_sai_rpc_sai_thrift_get_default_router_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args::~switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs::~switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result::~switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult::~switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_vlan_id_args::~switch_sai_rpc_sai_thrift_get_default_vlan_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_vlan_id_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs::~switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_vlan_id_result::~switch_sai_rpc_sai_thrift_get_default_vlan_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_vlan_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_vlan_id_presult::~switch_sai_rpc_sai_thrift_get_default_vlan_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args::~switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port_name);
          this->__isset.port_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args");

  xfer += oprot->writeFieldBegin("port_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->port_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs::~switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs");

  xfer += oprot->writeFieldBegin("port_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->port_name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result::~switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult::~switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_switch_attribute_args::~switch_sai_rpc_sai_thrift_set_switch_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attribute.read(iprot);
          this->__isset.attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_switch_attribute_args");

  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->attribute.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_switch_attribute_pargs::~switch_sai_rpc_sai_thrift_set_switch_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_switch_attribute_pargs");

  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->attribute)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_switch_attribute_result::~switch_sai_rpc_sai_thrift_set_switch_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_switch_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_switch_attribute_presult::~switch_sai_rpc_sai_thrift_set_switch_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_switch_args::~switch_sai_rpc_sai_thrift_create_switch_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_switch_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_switch_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_switch_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_switch_pargs::~switch_sai_rpc_sai_thrift_create_switch_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_switch_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_switch_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_switch_result::~switch_sai_rpc_sai_thrift_create_switch_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_switch_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_switch_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_switch_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_switch_presult::~switch_sai_rpc_sai_thrift_create_switch_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_switch_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_switch_args::~switch_sai_rpc_sai_thrift_remove_switch_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_switch_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_switch_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_switch_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_switch_pargs::~switch_sai_rpc_sai_thrift_remove_switch_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_switch_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_switch_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_switch_result::~switch_sai_rpc_sai_thrift_remove_switch_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_switch_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_switch_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_switch_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_switch_presult::~switch_sai_rpc_sai_thrift_remove_switch_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_switch_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_args::~switch_sai_rpc_sai_thrift_get_switch_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size476;
            ::apache::thrift::protocol::TType _etype479;
            xfer += iprot->readListBegin(_etype479, _size476);
            this->counter_ids.resize(_size476);
            uint32_t _i480;
            for (_i480 = 0; _i480 < _size476; ++_i480)
            {
              xfer += iprot->readI32(this->counter_ids[_i480]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_args");

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter481;
    for (_iter481 = this->counter_ids.begin(); _iter481 != this->counter_ids.end(); ++_iter481)
    {
      xfer += oprot->writeI32((*_iter481));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_pargs::~switch_sai_rpc_sai_thrift_get_switch_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_pargs");

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter482;
    for (_iter482 = (*(this->counter_ids)).begin(); _iter482 != (*(this->counter_ids)).end(); ++_iter482)
    {
      xfer += oprot->writeI32((*_iter482));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_result::~switch_sai_rpc_sai_thrift_get_switch_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size483;
            ::apache::thrift::protocol::TType _etype486;
            xfer += iprot->readListBegin(_etype486, _size483);
            this->success.resize(_size483);
            uint32_t _i487;
            for (_i487 = 0; _i487 < _size483; ++_i487)
            {
              xfer += iprot->readI64(this->success[_i487]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter488;
      for (_iter488 = this->success.begin(); _iter488 != this->success.end(); ++_iter488)
      {
        xfer += oprot->writeI64((*_iter488));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_presult::~switch_sai_rpc_sai_thrift_get_switch_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size489;
            ::apache::thrift::protocol::TType _etype492;
            xfer += iprot->readListBegin(_etype492, _size489);
            (*(this->success)).resize(_size489);
            uint32_t _i493;
            for (_i493 = 0; _i493 < _size489; ++_i493)
            {
              xfer += iprot->readI64((*(this->success))[_i493]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_ext_args::~switch_sai_rpc_sai_thrift_get_switch_stats_ext_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_ext_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size494;
            ::apache::thrift::protocol::TType _etype497;
            xfer += iprot->readListBegin(_etype497, _size494);
            this->counter_ids.resize(_size494);
            uint32_t _i498;
            for (_i498 = 0; _i498 < _size494; ++_i498)
            {
              xfer += iprot->readI32(this->counter_ids[_i498]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_ext_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_ext_args");

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter499;
    for (_iter499 = this->counter_ids.begin(); _iter499 != this->counter_ids.end(); ++_iter499)
    {
      xfer += oprot->writeI32((*_iter499));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_ext_pargs::~switch_sai_rpc_sai_thrift_get_switch_stats_ext_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_ext_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_ext_pargs");

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter500;
    for (_iter500 = (*(this->counter_ids)).begin(); _iter500 != (*(this->counter_ids)).end(); ++_iter500)
    {
      xfer += oprot->writeI32((*_iter500));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_ext_result::~switch_sai_rpc_sai_thrift_get_switch_stats_ext_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_ext_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size501;
            ::apache::thrift::protocol::TType _etype504;
            xfer += iprot->readListBegin(_etype504, _size501);
            this->success.resize(_size501);
            uint32_t _i505;
            for (_i505 = 0; _i505 < _size501; ++_i505)
            {
              xfer += iprot->readI64(this->success[_i505]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_ext_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_ext_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter506;
      for (_iter506 = this->success.begin(); _iter506 != this->success.end(); ++_iter506)
      {
        xfer += oprot->writeI64((*_iter506));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_ext_presult::~switch_sai_rpc_sai_thrift_get_switch_stats_ext_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_ext_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size507;
            ::apache::thrift::protocol::TType _etype510;
            xfer += iprot->readListBegin(_etype510, _size507);
            (*(this->success)).resize(_size507);
            uint32_t _i511;
            for (_i511 = 0; _i511 < _size507; ++_i511)
            {
              xfer += iprot->readI64((*(this->success))[_i511]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_switch_stats_args::~switch_sai_rpc_sai_thrift_clear_switch_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_switch_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size512;
            ::apache::thrift::protocol::TType _etype515;
            xfer += iprot->readListBegin(_etype515, _size512);
            this->counter_ids.resize(_size512);
            uint32_t _i516;
            for (_i516 = 0; _i516 < _size512; ++_i516)
            {
              xfer += iprot->readI32(this->counter_ids[_i516]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_switch_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_switch_stats_args");

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter517;
    for (_iter517 = this->counter_ids.begin(); _iter517 != this->counter_ids.end(); ++_iter517)
    {
      xfer += oprot->writeI32((*_iter517));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_switch_stats_pargs::~switch_sai_rpc_sai_thrift_clear_switch_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_switch_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_switch_stats_pargs");

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter518;
    for (_iter518 = (*(this->counter_ids)).begin(); _iter518 != (*(this->counter_ids)).end(); ++_iter518)
    {
      xfer += oprot->writeI32((*_iter518));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_switch_stats_result::~switch_sai_rpc_sai_thrift_clear_switch_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_switch_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_switch_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_switch_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_switch_stats_presult::~switch_sai_rpc_sai_thrift_clear_switch_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_switch_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_port_args::~switch_sai_rpc_sai_thrift_create_bridge_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size519;
            ::apache::thrift::protocol::TType _etype522;
            xfer += iprot->readListBegin(_etype522, _size519);
            this->thrift_attr_list.resize(_size519);
            uint32_t _i523;
            for (_i523 = 0; _i523 < _size519; ++_i523)
            {
              xfer += this->thrift_attr_list[_i523].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_port_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter524;
    for (_iter524 = this->thrift_attr_list.begin(); _iter524 != this->thrift_attr_list.end(); ++_iter524)
    {
      xfer += (*_iter524).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_port_pargs::~switch_sai_rpc_sai_thrift_create_bridge_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_port_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter525;
    for (_iter525 = (*(this->thrift_attr_list)).begin(); _iter525 != (*(this->thrift_attr_list)).end(); ++_iter525)
    {
      xfer += (*_iter525).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_port_result::~switch_sai_rpc_sai_thrift_create_bridge_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_port_presult::~switch_sai_rpc_sai_thrift_create_bridge_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_port_args::~switch_sai_rpc_sai_thrift_remove_bridge_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_port_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_port_pargs::~switch_sai_rpc_sai_thrift_remove_bridge_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_port_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_port_result::~switch_sai_rpc_sai_thrift_remove_bridge_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_port_presult::~switch_sai_rpc_sai_thrift_remove_bridge_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_list_args::~switch_sai_rpc_sai_thrift_get_bridge_port_list_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_id);
          this->__isset.bridge_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_list_args");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs::~switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_list_result::~switch_sai_rpc_sai_thrift_get_bridge_port_list_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_list_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_list_presult::~switch_sai_rpc_sai_thrift_get_bridge_port_list_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args::~switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs::~switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result::~switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult::~switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args::~switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs::~switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result::~switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult::~switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_args::~switch_sai_rpc_sai_thrift_create_bridge_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size526;
            ::apache::thrift::protocol::TType _etype529;
            xfer += iprot->readListBegin(_etype529, _size526);
            this->thrift_attr_list.resize(_size526);
            uint32_t _i530;
            for (_i530 = 0; _i530 < _size526; ++_i530)
            {
              xfer += this->thrift_attr_list[_i530].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bridge_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter531;
    for (_iter531 = this->thrift_attr_list.begin(); _iter531 != this->thrift_attr_list.end(); ++_iter531)
    {
      xfer += (*_iter531).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_pargs::~switch_sai_rpc_sai_thrift_create_bridge_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter532;
    for (_iter532 = (*(this->thrift_attr_list)).begin(); _iter532 != (*(this->thrift_attr_list)).end(); ++_iter532)
    {
      xfer += (*_iter532).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_result::~switch_sai_rpc_sai_thrift_create_bridge_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bridge_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_presult::~switch_sai_rpc_sai_thrift_create_bridge_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_args::~switch_sai_rpc_sai_thrift_remove_bridge_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_id);
          this->__isset.bridge_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bridge_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_args");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_pargs::~switch_sai_rpc_sai_thrift_remove_bridge_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_pargs");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_result::~switch_sai_rpc_sai_thrift_remove_bridge_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bridge_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_presult::~switch_sai_rpc_sai_thrift_remove_bridge_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_attribute_args::~switch_sai_rpc_sai_thrift_get_bridge_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_id);
          this->__isset.bridge_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_attribute_args");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_attribute_pargs::~switch_sai_rpc_sai_thrift_get_bridge_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_attribute_pargs");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_attribute_result::~switch_sai_rpc_sai_thrift_get_bridge_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_attribute_presult::~switch_sai_rpc_sai_thrift_get_bridge_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_attribute_args::~switch_sai_rpc_sai_thrift_set_bridge_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_id);
          this->__isset.bridge_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_bridge_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_attribute_args");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_attribute_pargs::~switch_sai_rpc_sai_thrift_set_bridge_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_attribute_pargs");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_attribute_result::~switch_sai_rpc_sai_thrift_set_bridge_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_bridge_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_attribute_presult::~switch_sai_rpc_sai_thrift_set_bridge_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_stats_args::~switch_sai_rpc_sai_thrift_get_bridge_port_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size533;
            ::apache::thrift::protocol::TType _etype536;
            xfer += iprot->readListBegin(_etype536, _size533);
            this->counter_ids.resize(_size533);
            uint32_t _i537;
            for (_i537 = 0; _i537 < _size533; ++_i537)
            {
              xfer += iprot->readI32(this->counter_ids[_i537]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_stats_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_bridge_port_stat_counter_t> ::const_iterator _iter538;
    for (_iter538 = this->counter_ids.begin(); _iter538 != this->counter_ids.end(); ++_iter538)
    {
      xfer += oprot->writeI32((*_iter538));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_stats_pargs::~switch_sai_rpc_sai_thrift_get_bridge_port_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_stats_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_bridge_port_stat_counter_t> ::const_iterator _iter539;
    for (_iter539 = (*(this->counter_ids)).begin(); _iter539 != (*(this->counter_ids)).end(); ++_iter539)
    {
      xfer += oprot->writeI32((*_iter539));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_stats_result::~switch_sai_rpc_sai_thrift_get_bridge_port_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size540;
            ::apache::thrift::protocol::TType _etype543;
            xfer += iprot->readListBegin(_etype543, _size540);
            this->success.resize(_size540);
            uint32_t _i544;
            for (_i544 = 0; _i544 < _size540; ++_i544)
            {
              xfer += iprot->readI64(this->success[_i544]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter545;
      for (_iter545 = this->success.begin(); _iter545 != this->success.end(); ++_iter545)
      {
        xfer += oprot->writeI64((*_iter545));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_stats_presult::~switch_sai_rpc_sai_thrift_get_bridge_port_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size546;
            ::apache::thrift::protocol::TType _etype549;
            xfer += iprot->readListBegin(_etype549, _size546);
            (*(this->success)).resize(_size546);
            uint32_t _i550;
            for (_i550 = 0; _i550 < _size546; ++_i550)
            {
              xfer += iprot->readI64((*(this->success))[_i550]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_args::~switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size551;
            ::apache::thrift::protocol::TType _etype554;
            xfer += iprot->readListBegin(_etype554, _size551);
            this->thrift_counter_ids.resize(_size551);
            uint32_t _i555;
            for (_i555 = 0; _i555 < _size551; ++_i555)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i555]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_bridge_port_stat_counter_t> ::const_iterator _iter556;
    for (_iter556 = this->thrift_counter_ids.begin(); _iter556 != this->thrift_counter_ids.end(); ++_iter556)
    {
      xfer += oprot->writeI32((*_iter556));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_pargs::~switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_bridge_port_stat_counter_t> ::const_iterator _iter557;
    for (_iter557 = (*(this->thrift_counter_ids)).begin(); _iter557 != (*(this->thrift_counter_ids)).end(); ++_iter557)
    {
      xfer += oprot->writeI32((*_iter557));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_result::~switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size558;
            ::apache::thrift::protocol::TType _etype561;
            xfer += iprot->readListBegin(_etype561, _size558);
            this->success.resize(_size558);
            uint32_t _i562;
            for (_i562 = 0; _i562 < _size558; ++_i562)
            {
              xfer += iprot->readI64(this->success[_i562]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter563;
      for (_iter563 = this->success.begin(); _iter563 != this->success.end(); ++_iter563)
      {
        xfer += oprot->writeI64((*_iter563));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_presult::~switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size564;
            ::apache::thrift::protocol::TType _etype567;
            xfer += iprot->readListBegin(_etype567, _size564);
            (*(this->success)).resize(_size564);
            uint32_t _i568;
            for (_i568 = 0; _i568 < _size564; ++_i568)
            {
              xfer += iprot->readI64((*(this->success))[_i568]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_bridge_port_stats_args::~switch_sai_rpc_sai_thrift_clear_bridge_port_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_bridge_port_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size569;
            ::apache::thrift::protocol::TType _etype572;
            xfer += iprot->readListBegin(_etype572, _size569);
            this->thrift_counter_ids.resize(_size569);
            uint32_t _i573;
            for (_i573 = 0; _i573 < _size569; ++_i573)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i573]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_bridge_port_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_bridge_port_stats_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_bridge_port_stat_counter_t> ::const_iterator _iter574;
    for (_iter574 = this->thrift_counter_ids.begin(); _iter574 != this->thrift_counter_ids.end(); ++_iter574)
    {
      xfer += oprot->writeI32((*_iter574));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_bridge_port_stats_pargs::~switch_sai_rpc_sai_thrift_clear_bridge_port_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_bridge_port_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_bridge_port_stats_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_bridge_port_stat_counter_t> ::const_iterator _iter575;
    for (_iter575 = (*(this->thrift_counter_ids)).begin(); _iter575 != (*(this->thrift_counter_ids)).end(); ++_iter575)
    {
      xfer += oprot->writeI32((*_iter575));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_bridge_port_stats_result::~switch_sai_rpc_sai_thrift_clear_bridge_port_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_bridge_port_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_bridge_port_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_bridge_port_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_bridge_port_stats_presult::~switch_sai_rpc_sai_thrift_clear_bridge_port_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_bridge_port_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_args::~switch_sai_rpc_sai_thrift_create_hostif_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size576;
            ::apache::thrift::protocol::TType _etype579;
            xfer += iprot->readListBegin(_etype579, _size576);
            this->thrift_attr_list.resize(_size576);
            uint32_t _i580;
            for (_i580 = 0; _i580 < _size576; ++_i580)
            {
              xfer += this->thrift_attr_list[_i580].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter581;
    for (_iter581 = this->thrift_attr_list.begin(); _iter581 != this->thrift_attr_list.end(); ++_iter581)
    {
      xfer += (*_iter581).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_pargs::~switch_sai_rpc_sai_thrift_create_hostif_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter582;
    for (_iter582 = (*(this->thrift_attr_list)).begin(); _iter582 != (*(this->thrift_attr_list)).end(); ++_iter582)
    {
      xfer += (*_iter582).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_result::~switch_sai_rpc_sai_thrift_create_hostif_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_presult::~switch_sai_rpc_sai_thrift_create_hostif_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_args::~switch_sai_rpc_sai_thrift_remove_hostif_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hif_id);
          this->__isset.thrift_hif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_args");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_pargs::~switch_sai_rpc_sai_thrift_remove_hostif_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_pargs");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_result::~switch_sai_rpc_sai_thrift_remove_hostif_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_presult::~switch_sai_rpc_sai_thrift_remove_hostif_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_attribute_args::~switch_sai_rpc_sai_thrift_get_hostif_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hif_id);
          this->__isset.thrift_hif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hostif_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_attribute_pargs::~switch_sai_rpc_sai_thrift_get_hostif_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_attribute_result::~switch_sai_rpc_sai_thrift_get_hostif_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hostif_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_attribute_presult::~switch_sai_rpc_sai_thrift_get_hostif_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_attribute_args::~switch_sai_rpc_sai_thrift_set_hostif_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hif_id);
          this->__isset.thrift_hif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_attribute_result::~switch_sai_rpc_sai_thrift_set_hostif_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_attribute_presult::~switch_sai_rpc_sai_thrift_set_hostif_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_table_entry_args::~switch_sai_rpc_sai_thrift_create_hostif_table_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size583;
            ::apache::thrift::protocol::TType _etype586;
            xfer += iprot->readListBegin(_etype586, _size583);
            this->thrift_attr_list.resize(_size583);
            uint32_t _i587;
            for (_i587 = 0; _i587 < _size583; ++_i587)
            {
              xfer += this->thrift_attr_list[_i587].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_table_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter588;
    for (_iter588 = this->thrift_attr_list.begin(); _iter588 != this->thrift_attr_list.end(); ++_iter588)
    {
      xfer += (*_iter588).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs::~switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter589;
    for (_iter589 = (*(this->thrift_attr_list)).begin(); _iter589 != (*(this->thrift_attr_list)).end(); ++_iter589)
    {
      xfer += (*_iter589).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_table_entry_result::~switch_sai_rpc_sai_thrift_create_hostif_table_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_table_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult::~switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args::~switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_table_entry_id);
          this->__isset.thrift_hostif_table_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_table_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs::~switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_table_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result::~switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult::~switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_table_entry_id);
          this->__isset.thrift_hostif_table_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_table_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_table_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_table_entry_id);
          this->__isset.thrift_hostif_table_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_table_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_table_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_group_args::~switch_sai_rpc_sai_thrift_create_hostif_trap_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size590;
            ::apache::thrift::protocol::TType _etype593;
            xfer += iprot->readListBegin(_etype593, _size590);
            this->thrift_attr_list.resize(_size590);
            uint32_t _i594;
            for (_i594 = 0; _i594 < _size590; ++_i594)
            {
              xfer += this->thrift_attr_list[_i594].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter595;
    for (_iter595 = this->thrift_attr_list.begin(); _iter595 != this->thrift_attr_list.end(); ++_iter595)
    {
      xfer += (*_iter595).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs::~switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter596;
    for (_iter596 = (*(this->thrift_attr_list)).begin(); _iter596 != (*(this->thrift_attr_list)).end(); ++_iter596)
    {
      xfer += (*_iter596).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_group_result::~switch_sai_rpc_sai_thrift_create_hostif_trap_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult::~switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args::~switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_group_id);
          this->__isset.thrift_hostif_trap_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs::~switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result::~switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult::~switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_args::~switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_group_id);
          this->__isset.thrift_hostif_trap_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_result::~switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args::~switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_group_id);
          this->__isset.thrift_hostif_trap_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result::~switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult::~switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_args::~switch_sai_rpc_sai_thrift_create_hostif_trap_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size597;
            ::apache::thrift::protocol::TType _etype600;
            xfer += iprot->readListBegin(_etype600, _size597);
            this->thrift_attr_list.resize(_size597);
            uint32_t _i601;
            for (_i601 = 0; _i601 < _size597; ++_i601)
            {
              xfer += this->thrift_attr_list[_i601].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter602;
    for (_iter602 = this->thrift_attr_list.begin(); _iter602 != this->thrift_attr_list.end(); ++_iter602)
    {
      xfer += (*_iter602).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_pargs::~switch_sai_rpc_sai_thrift_create_hostif_trap_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter603;
    for (_iter603 = (*(this->thrift_attr_list)).begin(); _iter603 != (*(this->thrift_attr_list)).end(); ++_iter603)
    {
      xfer += (*_iter603).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_result::~switch_sai_rpc_sai_thrift_create_hostif_trap_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_presult::~switch_sai_rpc_sai_thrift_create_hostif_trap_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_args::~switch_sai_rpc_sai_thrift_remove_hostif_trap_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_id);
          this->__isset.thrift_hostif_trap_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs::~switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_result::~switch_sai_rpc_sai_thrift_remove_hostif_trap_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_presult::~switch_sai_rpc_sai_thrift_remove_hostif_trap_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_args::~switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_id);
          this->__isset.thrift_hostif_trap_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_pargs::~switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_result::~switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_presult::~switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args::~switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_id);
          this->__isset.thrift_hostif_trap_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result::~switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult::~switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_send_hostif_packet_args::~switch_sai_rpc_sai_thrift_send_hostif_packet_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_send_hostif_packet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hif_id);
          this->__isset.thrift_hif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packet_data);
          this->__isset.packet_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size604;
            ::apache::thrift::protocol::TType _etype607;
            xfer += iprot->readListBegin(_etype607, _size604);
            this->thrift_attr_list.resize(_size604);
            uint32_t _i608;
            for (_i608 = 0; _i608 < _size604; ++_i608)
            {
              xfer += this->thrift_attr_list[_i608].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_send_hostif_packet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_send_hostif_packet_args");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packet_data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->packet_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter609;
    for (_iter609 = this->thrift_attr_list.begin(); _iter609 != this->thrift_attr_list.end(); ++_iter609)
    {
      xfer += (*_iter609).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_send_hostif_packet_pargs::~switch_sai_rpc_sai_thrift_send_hostif_packet_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_send_hostif_packet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_send_hostif_packet_pargs");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packet_data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->packet_data)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter610;
    for (_iter610 = (*(this->thrift_attr_list)).begin(); _iter610 != (*(this->thrift_attr_list)).end(); ++_iter610)
    {
      xfer += (*_iter610).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_send_hostif_packet_result::~switch_sai_rpc_sai_thrift_send_hostif_packet_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_send_hostif_packet_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_send_hostif_packet_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_send_hostif_packet_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_send_hostif_packet_presult::~switch_sai_rpc_sai_thrift_send_hostif_packet_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_send_hostif_packet_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_args::~switch_sai_rpc_sai_thrift_create_acl_table_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size611;
            ::apache::thrift::protocol::TType _etype614;
            xfer += iprot->readListBegin(_etype614, _size611);
            this->thrift_attr_list.resize(_size611);
            uint32_t _i615;
            for (_i615 = 0; _i615 < _size611; ++_i615)
            {
              xfer += this->thrift_attr_list[_i615].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter616;
    for (_iter616 = this->thrift_attr_list.begin(); _iter616 != this->thrift_attr_list.end(); ++_iter616)
    {
      xfer += (*_iter616).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_pargs::~switch_sai_rpc_sai_thrift_create_acl_table_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter617;
    for (_iter617 = (*(this->thrift_attr_list)).begin(); _iter617 != (*(this->thrift_attr_list)).end(); ++_iter617)
    {
      xfer += (*_iter617).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_result::~switch_sai_rpc_sai_thrift_create_acl_table_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_presult::~switch_sai_rpc_sai_thrift_create_acl_table_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_args::~switch_sai_rpc_sai_thrift_remove_acl_table_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_id);
          this->__isset.acl_table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_args");

  xfer += oprot->writeFieldBegin("acl_table_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_pargs::~switch_sai_rpc_sai_thrift_remove_acl_table_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_pargs");

  xfer += oprot->writeFieldBegin("acl_table_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_result::~switch_sai_rpc_sai_thrift_remove_acl_table_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_presult::~switch_sai_rpc_sai_thrift_remove_acl_table_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_attribute_args::~switch_sai_rpc_sai_thrift_get_acl_table_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_id);
          this->__isset.acl_table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_ids.clear();
            uint32_t _size618;
            ::apache::thrift::protocol::TType _etype621;
            xfer += iprot->readListBegin(_etype621, _size618);
            this->thrift_attr_ids.resize(_size618);
            uint32_t _i622;
            for (_i622 = 0; _i622 < _size618; ++_i622)
            {
              xfer += iprot->readI32(this->thrift_attr_ids[_i622]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_table_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_attribute_args");

  xfer += oprot->writeFieldBegin("acl_table_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_ids.size()));
    std::vector<int32_t> ::const_iterator _iter623;
    for (_iter623 = this->thrift_attr_ids.begin(); _iter623 != this->thrift_attr_ids.end(); ++_iter623)
    {
      xfer += oprot->writeI32((*_iter623));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_attribute_pargs::~switch_sai_rpc_sai_thrift_get_acl_table_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_attribute_pargs");

  xfer += oprot->writeFieldBegin("acl_table_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_ids)).size()));
    std::vector<int32_t> ::const_iterator _iter624;
    for (_iter624 = (*(this->thrift_attr_ids)).begin(); _iter624 != (*(this->thrift_attr_ids)).end(); ++_iter624)
    {
      xfer += oprot->writeI32((*_iter624));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_attribute_result::~switch_sai_rpc_sai_thrift_get_acl_table_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_table_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_attribute_presult::~switch_sai_rpc_sai_thrift_get_acl_table_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_entry_args::~switch_sai_rpc_sai_thrift_create_acl_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size625;
            ::apache::thrift::protocol::TType _etype628;
            xfer += iprot->readListBegin(_etype628, _size625);
            this->thrift_attr_list.resize(_size625);
            uint32_t _i629;
            for (_i629 = 0; _i629 < _size625; ++_i629)
            {
              xfer += this->thrift_attr_list[_i629].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter630;
    for (_iter630 = this->thrift_attr_list.begin(); _iter630 != this->thrift_attr_list.end(); ++_iter630)
    {
      xfer += (*_iter630).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_entry_pargs::~switch_sai_rpc_sai_thrift_create_acl_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter631;
    for (_iter631 = (*(this->thrift_attr_list)).begin(); _iter631 != (*(this->thrift_attr_list)).end(); ++_iter631)
    {
      xfer += (*_iter631).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_entry_result::~switch_sai_rpc_sai_thrift_create_acl_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_entry_presult::~switch_sai_rpc_sai_thrift_create_acl_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_entry_args::~switch_sai_rpc_sai_thrift_remove_acl_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_entry);
          this->__isset.acl_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_entry_args");

  xfer += oprot->writeFieldBegin("acl_entry", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_entry);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_entry_pargs::~switch_sai_rpc_sai_thrift_remove_acl_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_entry_pargs");

  xfer += oprot->writeFieldBegin("acl_entry", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_entry)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_entry_result::~switch_sai_rpc_sai_thrift_remove_acl_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_entry_presult::~switch_sai_rpc_sai_thrift_remove_acl_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_acl_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_acl_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_acl_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_entry_id);
          this->__isset.acl_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_acl_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_acl_entry_attribute_args");

  xfer += oprot->writeFieldBegin("acl_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_acl_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_acl_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_acl_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_acl_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("acl_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_acl_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_acl_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_acl_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_acl_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_acl_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_acl_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_acl_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_acl_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_acl_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_entry_id);
          this->__isset.acl_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_ids.clear();
            uint32_t _size632;
            ::apache::thrift::protocol::TType _etype635;
            xfer += iprot->readListBegin(_etype635, _size632);
            this->thrift_attr_ids.resize(_size632);
            uint32_t _i636;
            for (_i636 = 0; _i636 < _size632; ++_i636)
            {
              xfer += iprot->readI32(this->thrift_attr_ids[_i636]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_entry_attribute_args");

  xfer += oprot->writeFieldBegin("acl_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_ids.size()));
    std::vector<int32_t> ::const_iterator _iter637;
    for (_iter637 = this->thrift_attr_ids.begin(); _iter637 != this->thrift_attr_ids.end(); ++_iter637)
    {
      xfer += oprot->writeI32((*_iter637));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_acl_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("acl_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_ids)).size()));
    std::vector<int32_t> ::const_iterator _iter638;
    for (_iter638 = (*(this->thrift_attr_ids)).begin(); _iter638 != (*(this->thrift_attr_ids)).end(); ++_iter638)
    {
      xfer += oprot->writeI32((*_iter638));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_acl_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_acl_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_args::~switch_sai_rpc_sai_thrift_create_acl_table_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size639;
            ::apache::thrift::protocol::TType _etype642;
            xfer += iprot->readListBegin(_etype642, _size639);
            this->thrift_attr_list.resize(_size639);
            uint32_t _i643;
            for (_i643 = 0; _i643 < _size639; ++_i643)
            {
              xfer += this->thrift_attr_list[_i643].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter644;
    for (_iter644 = this->thrift_attr_list.begin(); _iter644 != this->thrift_attr_list.end(); ++_iter644)
    {
      xfer += (*_iter644).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_pargs::~switch_sai_rpc_sai_thrift_create_acl_table_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter645;
    for (_iter645 = (*(this->thrift_attr_list)).begin(); _iter645 != (*(this->thrift_attr_list)).end(); ++_iter645)
    {
      xfer += (*_iter645).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_result::~switch_sai_rpc_sai_thrift_create_acl_table_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_presult::~switch_sai_rpc_sai_thrift_create_acl_table_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_args::~switch_sai_rpc_sai_thrift_remove_acl_table_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_group_id);
          this->__isset.acl_table_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_args");

  xfer += oprot->writeFieldBegin("acl_table_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs::~switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs");

  xfer += oprot->writeFieldBegin("acl_table_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_result::~switch_sai_rpc_sai_thrift_remove_acl_table_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_presult::~switch_sai_rpc_sai_thrift_remove_acl_table_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_args::~switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_group_id);
          this->__isset.acl_table_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_args");

  xfer += oprot->writeFieldBegin("acl_table_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("acl_table_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_result::~switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_member_args::~switch_sai_rpc_sai_thrift_create_acl_table_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size646;
            ::apache::thrift::protocol::TType _etype649;
            xfer += iprot->readListBegin(_etype649, _size646);
            this->thrift_attr_list.resize(_size646);
            uint32_t _i650;
            for (_i650 = 0; _i650 < _size646; ++_i650)
            {
              xfer += this->thrift_attr_list[_i650].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter651;
    for (_iter651 = this->thrift_attr_list.begin(); _iter651 != this->thrift_attr_list.end(); ++_iter651)
    {
      xfer += (*_iter651).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs::~switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter652;
    for (_iter652 = (*(this->thrift_attr_list)).begin(); _iter652 != (*(this->thrift_attr_list)).end(); ++_iter652)
    {
      xfer += (*_iter652).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_member_result::~switch_sai_rpc_sai_thrift_create_acl_table_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult::~switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args::~switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_group_member_id);
          this->__isset.acl_table_group_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args");

  xfer += oprot->writeFieldBegin("acl_table_group_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_group_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs::~switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs");

  xfer += oprot->writeFieldBegin("acl_table_group_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_group_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result::~switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult::~switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_args::~switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_group_member_id);
          this->__isset.acl_table_group_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_args");

  xfer += oprot->writeFieldBegin("acl_table_group_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_group_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("acl_table_group_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_group_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_result::~switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_counter_args::~switch_sai_rpc_sai_thrift_create_acl_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size653;
            ::apache::thrift::protocol::TType _etype656;
            xfer += iprot->readListBegin(_etype656, _size653);
            this->thrift_attr_list.resize(_size653);
            uint32_t _i657;
            for (_i657 = 0; _i657 < _size653; ++_i657)
            {
              xfer += this->thrift_attr_list[_i657].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_counter_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter658;
    for (_iter658 = this->thrift_attr_list.begin(); _iter658 != this->thrift_attr_list.end(); ++_iter658)
    {
      xfer += (*_iter658).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_counter_pargs::~switch_sai_rpc_sai_thrift_create_acl_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_counter_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter659;
    for (_iter659 = (*(this->thrift_attr_list)).begin(); _iter659 != (*(this->thrift_attr_list)).end(); ++_iter659)
    {
      xfer += (*_iter659).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_counter_result::~switch_sai_rpc_sai_thrift_create_acl_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_counter_presult::~switch_sai_rpc_sai_thrift_create_acl_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_counter_args::~switch_sai_rpc_sai_thrift_remove_acl_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_counter_id);
          this->__isset.acl_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_counter_args");

  xfer += oprot->writeFieldBegin("acl_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_counter_pargs::~switch_sai_rpc_sai_thrift_remove_acl_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_counter_pargs");

  xfer += oprot->writeFieldBegin("acl_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_counter_result::~switch_sai_rpc_sai_thrift_remove_acl_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_counter_presult::~switch_sai_rpc_sai_thrift_remove_acl_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args::~switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_counter_id);
          this->__isset.acl_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_ids.clear();
            uint32_t _size660;
            ::apache::thrift::protocol::TType _etype663;
            xfer += iprot->readListBegin(_etype663, _size660);
            this->thrift_attr_ids.resize(_size660);
            uint32_t _i664;
            for (_i664 = 0; _i664 < _size660; ++_i664)
            {
              xfer += iprot->readI32(this->thrift_attr_ids[_i664]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args");

  xfer += oprot->writeFieldBegin("acl_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_ids.size()));
    std::vector<int32_t> ::const_iterator _iter665;
    for (_iter665 = this->thrift_attr_ids.begin(); _iter665 != this->thrift_attr_ids.end(); ++_iter665)
    {
      xfer += oprot->writeI32((*_iter665));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs::~switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs");

  xfer += oprot->writeFieldBegin("acl_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_ids)).size()));
    std::vector<int32_t> ::const_iterator _iter666;
    for (_iter666 = (*(this->thrift_attr_ids)).begin(); _iter666 != (*(this->thrift_attr_ids)).end(); ++_iter666)
    {
      xfer += oprot->writeI32((*_iter666));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result::~switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size667;
            ::apache::thrift::protocol::TType _etype670;
            xfer += iprot->readListBegin(_etype670, _size667);
            this->success.resize(_size667);
            uint32_t _i671;
            for (_i671 = 0; _i671 < _size667; ++_i671)
            {
              xfer += this->success[_i671].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<sai_thrift_attribute_value_t> ::const_iterator _iter672;
      for (_iter672 = this->success.begin(); _iter672 != this->success.end(); ++_iter672)
      {
        xfer += (*_iter672).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult::~switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size673;
            ::apache::thrift::protocol::TType _etype676;
            xfer += iprot->readListBegin(_etype676, _size673);
            (*(this->success)).resize(_size673);
            uint32_t _i677;
            for (_i677 = 0; _i677 < _size673; ++_i677)
            {
              xfer += (*(this->success))[_i677].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_range_args::~switch_sai_rpc_sai_thrift_create_acl_range_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_range_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size678;
            ::apache::thrift::protocol::TType _etype681;
            xfer += iprot->readListBegin(_etype681, _size678);
            this->thrift_attr_list.resize(_size678);
            uint32_t _i682;
            for (_i682 = 0; _i682 < _size678; ++_i682)
            {
              xfer += this->thrift_attr_list[_i682].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_range_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_range_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter683;
    for (_iter683 = this->thrift_attr_list.begin(); _iter683 != this->thrift_attr_list.end(); ++_iter683)
    {
      xfer += (*_iter683).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_range_pargs::~switch_sai_rpc_sai_thrift_create_acl_range_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_range_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_range_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter684;
    for (_iter684 = (*(this->thrift_attr_list)).begin(); _iter684 != (*(this->thrift_attr_list)).end(); ++_iter684)
    {
      xfer += (*_iter684).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_range_result::~switch_sai_rpc_sai_thrift_create_acl_range_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_range_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_range_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_range_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_range_presult::~switch_sai_rpc_sai_thrift_create_acl_range_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_range_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_range_args::~switch_sai_rpc_sai_thrift_remove_acl_range_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_range_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_range_id);
          this->__isset.acl_range_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_range_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_range_args");

  xfer += oprot->writeFieldBegin("acl_range_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_range_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_range_pargs::~switch_sai_rpc_sai_thrift_remove_acl_range_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_range_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_range_pargs");

  xfer += oprot->writeFieldBegin("acl_range_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_range_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_range_result::~switch_sai_rpc_sai_thrift_remove_acl_range_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_range_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_range_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_range_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_range_presult::~switch_sai_rpc_sai_thrift_remove_acl_range_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_range_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hash_args::~switch_sai_rpc_sai_thrift_create_hash_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hash_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size685;
            ::apache::thrift::protocol::TType _etype688;
            xfer += iprot->readListBegin(_etype688, _size685);
            this->thrift_attr_list.resize(_size685);
            uint32_t _i689;
            for (_i689 = 0; _i689 < _size685; ++_i689)
            {
              xfer += this->thrift_attr_list[_i689].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hash_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hash_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter690;
    for (_iter690 = this->thrift_attr_list.begin(); _iter690 != this->thrift_attr_list.end(); ++_iter690)
    {
      xfer += (*_iter690).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hash_pargs::~switch_sai_rpc_sai_thrift_create_hash_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hash_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hash_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter691;
    for (_iter691 = (*(this->thrift_attr_list)).begin(); _iter691 != (*(this->thrift_attr_list)).end(); ++_iter691)
    {
      xfer += (*_iter691).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hash_result::~switch_sai_rpc_sai_thrift_create_hash_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hash_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hash_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hash_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hash_presult::~switch_sai_rpc_sai_thrift_create_hash_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hash_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hash_args::~switch_sai_rpc_sai_thrift_remove_hash_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hash_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hash_id);
          this->__isset.hash_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hash_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hash_args");

  xfer += oprot->writeFieldBegin("hash_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->hash_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hash_pargs::~switch_sai_rpc_sai_thrift_remove_hash_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hash_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hash_pargs");

  xfer += oprot->writeFieldBegin("hash_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->hash_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hash_result::~switch_sai_rpc_sai_thrift_remove_hash_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hash_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hash_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hash_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hash_presult::~switch_sai_rpc_sai_thrift_remove_hash_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hash_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hash_attribute_args::~switch_sai_rpc_sai_thrift_set_hash_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hash_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hash_id);
          this->__isset.thrift_hash_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hash_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hash_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hash_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hash_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hash_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hash_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hash_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hash_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hash_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hash_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hash_attribute_result::~switch_sai_rpc_sai_thrift_set_hash_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hash_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hash_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hash_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hash_attribute_presult::~switch_sai_rpc_sai_thrift_set_hash_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hash_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_hash_attribute_args::~switch_sai_rpc_sai_thrift_get_hash_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hash_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hash_id);
          this->__isset.thrift_hash_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hash_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hash_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hash_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hash_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hash_attribute_pargs::~switch_sai_rpc_sai_thrift_get_hash_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hash_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hash_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hash_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hash_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hash_attribute_result::~switch_sai_rpc_sai_thrift_get_hash_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hash_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_hash_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_hash_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_hash_attribute_presult::~switch_sai_rpc_sai_thrift_get_hash_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_hash_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_group_args::~switch_sai_rpc_sai_thrift_create_udf_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size692;
            ::apache::thrift::protocol::TType _etype695;
            xfer += iprot->readListBegin(_etype695, _size692);
            this->thrift_attr_list.resize(_size692);
            uint32_t _i696;
            for (_i696 = 0; _i696 < _size692; ++_i696)
            {
              xfer += this->thrift_attr_list[_i696].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_udf_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter697;
    for (_iter697 = this->thrift_attr_list.begin(); _iter697 != this->thrift_attr_list.end(); ++_iter697)
    {
      xfer += (*_iter697).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_group_pargs::~switch_sai_rpc_sai_thrift_create_udf_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter698;
    for (_iter698 = (*(this->thrift_attr_list)).begin(); _iter698 != (*(this->thrift_attr_list)).end(); ++_iter698)
    {
      xfer += (*_iter698).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_group_result::~switch_sai_rpc_sai_thrift_create_udf_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_udf_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_group_presult::~switch_sai_rpc_sai_thrift_create_udf_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_group_args::~switch_sai_rpc_sai_thrift_remove_udf_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->udf_group_id);
          this->__isset.udf_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_udf_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_group_args");

  xfer += oprot->writeFieldBegin("udf_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->udf_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_group_pargs::~switch_sai_rpc_sai_thrift_remove_udf_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_group_pargs");

  xfer += oprot->writeFieldBegin("udf_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->udf_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_group_result::~switch_sai_rpc_sai_thrift_remove_udf_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_udf_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_group_presult::~switch_sai_rpc_sai_thrift_remove_udf_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_group_attribute_args::~switch_sai_rpc_sai_thrift_get_udf_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_udf_group_id);
          this->__isset.thrift_udf_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_udf_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_group_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_udf_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_udf_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_udf_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_udf_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_udf_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_group_attribute_result::~switch_sai_rpc_sai_thrift_get_udf_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_udf_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_udf_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_match_args::~switch_sai_rpc_sai_thrift_create_udf_match_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_match_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size699;
            ::apache::thrift::protocol::TType _etype702;
            xfer += iprot->readListBegin(_etype702, _size699);
            this->thrift_attr_list.resize(_size699);
            uint32_t _i703;
            for (_i703 = 0; _i703 < _size699; ++_i703)
            {
              xfer += this->thrift_attr_list[_i703].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_udf_match_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_match_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter704;
    for (_iter704 = this->thrift_attr_list.begin(); _iter704 != this->thrift_attr_list.end(); ++_iter704)
    {
      xfer += (*_iter704).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_match_pargs::~switch_sai_rpc_sai_thrift_create_udf_match_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_match_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_match_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter705;
    for (_iter705 = (*(this->thrift_attr_list)).begin(); _iter705 != (*(this->thrift_attr_list)).end(); ++_iter705)
    {
      xfer += (*_iter705).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_match_result::~switch_sai_rpc_sai_thrift_create_udf_match_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_match_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_udf_match_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_match_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_match_presult::~switch_sai_rpc_sai_thrift_create_udf_match_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_match_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_match_args::~switch_sai_rpc_sai_thrift_remove_udf_match_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_match_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->udf_match_id);
          this->__isset.udf_match_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_udf_match_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_match_args");

  xfer += oprot->writeFieldBegin("udf_match_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->udf_match_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_match_pargs::~switch_sai_rpc_sai_thrift_remove_udf_match_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_match_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_match_pargs");

  xfer += oprot->writeFieldBegin("udf_match_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->udf_match_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_match_result::~switch_sai_rpc_sai_thrift_remove_udf_match_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_match_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_udf_match_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_match_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_match_presult::~switch_sai_rpc_sai_thrift_remove_udf_match_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_match_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_match_attribute_args::~switch_sai_rpc_sai_thrift_get_udf_match_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_match_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_udf_match_id);
          this->__isset.thrift_udf_match_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_udf_match_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_match_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_udf_match_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_udf_match_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_match_attribute_pargs::~switch_sai_rpc_sai_thrift_get_udf_match_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_match_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_match_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_udf_match_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_udf_match_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_match_attribute_result::~switch_sai_rpc_sai_thrift_get_udf_match_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_match_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_udf_match_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_match_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_match_attribute_presult::~switch_sai_rpc_sai_thrift_get_udf_match_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_match_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_args::~switch_sai_rpc_sai_thrift_create_udf_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size706;
            ::apache::thrift::protocol::TType _etype709;
            xfer += iprot->readListBegin(_etype709, _size706);
            this->thrift_attr_list.resize(_size706);
            uint32_t _i710;
            for (_i710 = 0; _i710 < _size706; ++_i710)
            {
              xfer += this->thrift_attr_list[_i710].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_udf_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter711;
    for (_iter711 = this->thrift_attr_list.begin(); _iter711 != this->thrift_attr_list.end(); ++_iter711)
    {
      xfer += (*_iter711).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_pargs::~switch_sai_rpc_sai_thrift_create_udf_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter712;
    for (_iter712 = (*(this->thrift_attr_list)).begin(); _iter712 != (*(this->thrift_attr_list)).end(); ++_iter712)
    {
      xfer += (*_iter712).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_result::~switch_sai_rpc_sai_thrift_create_udf_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_udf_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_udf_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_udf_presult::~switch_sai_rpc_sai_thrift_create_udf_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_udf_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_args::~switch_sai_rpc_sai_thrift_remove_udf_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->udf_id);
          this->__isset.udf_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_udf_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_args");

  xfer += oprot->writeFieldBegin("udf_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->udf_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_pargs::~switch_sai_rpc_sai_thrift_remove_udf_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_pargs");

  xfer += oprot->writeFieldBegin("udf_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->udf_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_result::~switch_sai_rpc_sai_thrift_remove_udf_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_udf_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_udf_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_udf_presult::~switch_sai_rpc_sai_thrift_remove_udf_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_udf_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_udf_attribute_args::~switch_sai_rpc_sai_thrift_set_udf_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_udf_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_udf_id);
          this->__isset.thrift_udf_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_udf_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_udf_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_udf_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_udf_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_udf_attribute_pargs::~switch_sai_rpc_sai_thrift_set_udf_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_udf_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_udf_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_udf_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_udf_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_udf_attribute_result::~switch_sai_rpc_sai_thrift_set_udf_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_udf_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_udf_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_udf_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_udf_attribute_presult::~switch_sai_rpc_sai_thrift_set_udf_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_udf_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_attribute_args::~switch_sai_rpc_sai_thrift_get_udf_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_udf_id);
          this->__isset.thrift_udf_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_udf_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_udf_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_udf_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_attribute_pargs::~switch_sai_rpc_sai_thrift_get_udf_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_udf_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_udf_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_attribute_result::~switch_sai_rpc_sai_thrift_get_udf_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_udf_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_udf_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_udf_attribute_presult::~switch_sai_rpc_sai_thrift_get_udf_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_udf_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_twamp_session_args::~switch_sai_rpc_sai_thrift_create_twamp_session_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_twamp_session_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size713;
            ::apache::thrift::protocol::TType _etype716;
            xfer += iprot->readListBegin(_etype716, _size713);
            this->thrift_attr_list.resize(_size713);
            uint32_t _i717;
            for (_i717 = 0; _i717 < _size713; ++_i717)
            {
              xfer += this->thrift_attr_list[_i717].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_twamp_session_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_twamp_session_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter718;
    for (_iter718 = this->thrift_attr_list.begin(); _iter718 != this->thrift_attr_list.end(); ++_iter718)
    {
      xfer += (*_iter718).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_twamp_session_pargs::~switch_sai_rpc_sai_thrift_create_twamp_session_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_twamp_session_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_twamp_session_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter719;
    for (_iter719 = (*(this->thrift_attr_list)).begin(); _iter719 != (*(this->thrift_attr_list)).end(); ++_iter719)
    {
      xfer += (*_iter719).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_twamp_session_result::~switch_sai_rpc_sai_thrift_create_twamp_session_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_twamp_session_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_twamp_session_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_twamp_session_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_twamp_session_presult::~switch_sai_rpc_sai_thrift_create_twamp_session_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_twamp_session_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_twamp_session_args::~switch_sai_rpc_sai_thrift_remove_twamp_session_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_twamp_session_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_twamp_session_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_twamp_session_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_twamp_session_pargs::~switch_sai_rpc_sai_thrift_remove_twamp_session_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_twamp_session_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_twamp_session_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_twamp_session_result::~switch_sai_rpc_sai_thrift_remove_twamp_session_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_twamp_session_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_twamp_session_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_twamp_session_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_twamp_session_presult::~switch_sai_rpc_sai_thrift_remove_twamp_session_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_twamp_session_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_twamp_attribute_args::~switch_sai_rpc_sai_thrift_set_twamp_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_twamp_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_twamp_session_id);
          this->__isset.thrift_twamp_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_twamp_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_twamp_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_twamp_session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_twamp_session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_twamp_attribute_pargs::~switch_sai_rpc_sai_thrift_set_twamp_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_twamp_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_twamp_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_twamp_session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_twamp_session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_twamp_attribute_result::~switch_sai_rpc_sai_thrift_set_twamp_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_twamp_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_twamp_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_twamp_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_twamp_attribute_presult::~switch_sai_rpc_sai_thrift_set_twamp_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_twamp_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_mirror_session_args::~switch_sai_rpc_sai_thrift_create_mirror_session_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size720;
            ::apache::thrift::protocol::TType _etype723;
            xfer += iprot->readListBegin(_etype723, _size720);
            this->thrift_attr_list.resize(_size720);
            uint32_t _i724;
            for (_i724 = 0; _i724 < _size720; ++_i724)
            {
              xfer += this->thrift_attr_list[_i724].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mirror_session_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter725;
    for (_iter725 = this->thrift_attr_list.begin(); _iter725 != this->thrift_attr_list.end(); ++_iter725)
    {
      xfer += (*_iter725).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mirror_session_pargs::~switch_sai_rpc_sai_thrift_create_mirror_session_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mirror_session_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter726;
    for (_iter726 = (*(this->thrift_attr_list)).begin(); _iter726 != (*(this->thrift_attr_list)).end(); ++_iter726)
    {
      xfer += (*_iter726).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mirror_session_result::~switch_sai_rpc_sai_thrift_create_mirror_session_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mirror_session_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mirror_session_presult::~switch_sai_rpc_sai_thrift_create_mirror_session_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mirror_session_args::~switch_sai_rpc_sai_thrift_remove_mirror_session_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mirror_session_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mirror_session_pargs::~switch_sai_rpc_sai_thrift_remove_mirror_session_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mirror_session_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mirror_session_result::~switch_sai_rpc_sai_thrift_remove_mirror_session_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mirror_session_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mirror_session_presult::~switch_sai_rpc_sai_thrift_remove_mirror_session_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_mirror_attribute_args::~switch_sai_rpc_sai_thrift_set_mirror_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mirror_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_mirror_id);
          this->__isset.thrift_mirror_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_mirror_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mirror_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_mirror_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_mirror_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mirror_attribute_pargs::~switch_sai_rpc_sai_thrift_set_mirror_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mirror_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mirror_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_mirror_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_mirror_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mirror_attribute_result::~switch_sai_rpc_sai_thrift_set_mirror_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mirror_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_mirror_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mirror_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mirror_attribute_presult::~switch_sai_rpc_sai_thrift_set_mirror_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mirror_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_mirror_attribute_args::~switch_sai_rpc_sai_thrift_get_mirror_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_mirror_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_mirror_id);
          this->__isset.thrift_mirror_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_mirror_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_mirror_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_mirror_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_mirror_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_mirror_attribute_pargs::~switch_sai_rpc_sai_thrift_get_mirror_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_mirror_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_mirror_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_mirror_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_mirror_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_mirror_attribute_result::~switch_sai_rpc_sai_thrift_get_mirror_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_mirror_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_mirror_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_mirror_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_mirror_attribute_presult::~switch_sai_rpc_sai_thrift_get_mirror_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_mirror_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_inseg_entry_args::~switch_sai_rpc_sai_thrift_create_inseg_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_inseg_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_inseg_entry.read(iprot);
          this->__isset.thrift_inseg_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size727;
            ::apache::thrift::protocol::TType _etype730;
            xfer += iprot->readListBegin(_etype730, _size727);
            this->thrift_attr_list.resize(_size727);
            uint32_t _i731;
            for (_i731 = 0; _i731 < _size727; ++_i731)
            {
              xfer += this->thrift_attr_list[_i731].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_inseg_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_inseg_entry_args");

  xfer += oprot->writeFieldBegin("thrift_inseg_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_inseg_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter732;
    for (_iter732 = this->thrift_attr_list.begin(); _iter732 != this->thrift_attr_list.end(); ++_iter732)
    {
      xfer += (*_iter732).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_inseg_entry_pargs::~switch_sai_rpc_sai_thrift_create_inseg_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_inseg_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_inseg_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_inseg_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_inseg_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter733;
    for (_iter733 = (*(this->thrift_attr_list)).begin(); _iter733 != (*(this->thrift_attr_list)).end(); ++_iter733)
    {
      xfer += (*_iter733).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_inseg_entry_result::~switch_sai_rpc_sai_thrift_create_inseg_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_inseg_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_inseg_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_inseg_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_inseg_entry_presult::~switch_sai_rpc_sai_thrift_create_inseg_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_inseg_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_inseg_entry_args::~switch_sai_rpc_sai_thrift_remove_inseg_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_inseg_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_inseg_entry.read(iprot);
          this->__isset.thrift_inseg_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_inseg_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_inseg_entry_args");

  xfer += oprot->writeFieldBegin("thrift_inseg_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_inseg_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_inseg_entry_pargs::~switch_sai_rpc_sai_thrift_remove_inseg_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_inseg_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_inseg_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_inseg_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_inseg_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_inseg_entry_result::~switch_sai_rpc_sai_thrift_remove_inseg_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_inseg_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_inseg_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_inseg_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_inseg_entry_presult::~switch_sai_rpc_sai_thrift_remove_inseg_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_inseg_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_inseg_entry.read(iprot);
          this->__isset.thrift_inseg_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_inseg_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_inseg_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_inseg_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_inseg_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_inseg_entry.read(iprot);
          this->__isset.thrift_inseg_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_inseg_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_inseg_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_inseg_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_inseg_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_dump_log_args::~switch_sai_rpc_sai_thrift_dump_log_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_dump_log_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dump_file_name);
          this->__isset.dump_file_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_dump_log_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_dump_log_args");

  xfer += oprot->writeFieldBegin("dump_file_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dump_file_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_dump_log_pargs::~switch_sai_rpc_sai_thrift_dump_log_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_dump_log_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_dump_log_pargs");

  xfer += oprot->writeFieldBegin("dump_file_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->dump_file_name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_dump_log_result::~switch_sai_rpc_sai_thrift_dump_log_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_dump_log_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_dump_log_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_dump_log_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_dump_log_presult::~switch_sai_rpc_sai_thrift_dump_log_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_dump_log_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_policer_args::~switch_sai_rpc_sai_thrift_create_policer_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_policer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size734;
            ::apache::thrift::protocol::TType _etype737;
            xfer += iprot->readListBegin(_etype737, _size734);
            this->thrift_attr_list.resize(_size734);
            uint32_t _i738;
            for (_i738 = 0; _i738 < _size734; ++_i738)
            {
              xfer += this->thrift_attr_list[_i738].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_policer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_policer_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter739;
    for (_iter739 = this->thrift_attr_list.begin(); _iter739 != this->thrift_attr_list.end(); ++_iter739)
    {
      xfer += (*_iter739).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_policer_pargs::~switch_sai_rpc_sai_thrift_create_policer_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_policer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_policer_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter740;
    for (_iter740 = (*(this->thrift_attr_list)).begin(); _iter740 != (*(this->thrift_attr_list)).end(); ++_iter740)
    {
      xfer += (*_iter740).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_policer_result::~switch_sai_rpc_sai_thrift_create_policer_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_policer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_policer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_policer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_policer_presult::~switch_sai_rpc_sai_thrift_create_policer_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_policer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_policer_args::~switch_sai_rpc_sai_thrift_remove_policer_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_policer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_policer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_policer_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_policer_pargs::~switch_sai_rpc_sai_thrift_remove_policer_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_policer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_policer_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_policer_result::~switch_sai_rpc_sai_thrift_remove_policer_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_policer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_policer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_policer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_policer_presult::~switch_sai_rpc_sai_thrift_remove_policer_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_policer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_attribute_args::~switch_sai_rpc_sai_thrift_get_policer_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_policer_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_attribute_pargs::~switch_sai_rpc_sai_thrift_get_policer_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_attribute_result::~switch_sai_rpc_sai_thrift_get_policer_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_policer_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_attribute_presult::~switch_sai_rpc_sai_thrift_get_policer_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_policer_attribute_args::~switch_sai_rpc_sai_thrift_set_policer_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_policer_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_policer_attribute_pargs::~switch_sai_rpc_sai_thrift_set_policer_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_policer_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_policer_attribute_result::~switch_sai_rpc_sai_thrift_set_policer_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_policer_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_policer_attribute_presult::~switch_sai_rpc_sai_thrift_set_policer_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_stats_args::~switch_sai_rpc_sai_thrift_get_policer_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size741;
            ::apache::thrift::protocol::TType _etype744;
            xfer += iprot->readListBegin(_etype744, _size741);
            this->thrift_counter_ids.resize(_size741);
            uint32_t _i745;
            for (_i745 = 0; _i745 < _size741; ++_i745)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i745]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_stats_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_policer_stat_t> ::const_iterator _iter746;
    for (_iter746 = this->thrift_counter_ids.begin(); _iter746 != this->thrift_counter_ids.end(); ++_iter746)
    {
      xfer += oprot->writeI32((*_iter746));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_stats_pargs::~switch_sai_rpc_sai_thrift_get_policer_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_stats_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_policer_stat_t> ::const_iterator _iter747;
    for (_iter747 = (*(this->thrift_counter_ids)).begin(); _iter747 != (*(this->thrift_counter_ids)).end(); ++_iter747)
    {
      xfer += oprot->writeI32((*_iter747));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_stats_result::~switch_sai_rpc_sai_thrift_get_policer_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size748;
            ::apache::thrift::protocol::TType _etype751;
            xfer += iprot->readListBegin(_etype751, _size748);
            this->success.resize(_size748);
            uint32_t _i752;
            for (_i752 = 0; _i752 < _size748; ++_i752)
            {
              xfer += iprot->readI64(this->success[_i752]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<sai_thrift_uint64_t> ::const_iterator _iter753;
      for (_iter753 = this->success.begin(); _iter753 != this->success.end(); ++_iter753)
      {
        xfer += oprot->writeI64((*_iter753));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_stats_presult::~switch_sai_rpc_sai_thrift_get_policer_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size754;
            ::apache::thrift::protocol::TType _etype757;
            xfer += iprot->readListBegin(_etype757, _size754);
            (*(this->success)).resize(_size754);
            uint32_t _i758;
            for (_i758 = 0; _i758 < _size754; ++_i758)
            {
              xfer += iprot->readI64((*(this->success))[_i758]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_policer_stats_args::~switch_sai_rpc_sai_thrift_clear_policer_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size759;
            ::apache::thrift::protocol::TType _etype762;
            xfer += iprot->readListBegin(_etype762, _size759);
            this->thrift_counter_ids.resize(_size759);
            uint32_t _i763;
            for (_i763 = 0; _i763 < _size759; ++_i763)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i763]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_policer_stats_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_policer_stat_t> ::const_iterator _iter764;
    for (_iter764 = this->thrift_counter_ids.begin(); _iter764 != this->thrift_counter_ids.end(); ++_iter764)
    {
      xfer += oprot->writeI32((*_iter764));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_policer_stats_pargs::~switch_sai_rpc_sai_thrift_clear_policer_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_policer_stats_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_policer_stat_t> ::const_iterator _iter765;
    for (_iter765 = (*(this->thrift_counter_ids)).begin(); _iter765 != (*(this->thrift_counter_ids)).end(); ++_iter765)
    {
      xfer += oprot->writeI32((*_iter765));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_policer_stats_result::~switch_sai_rpc_sai_thrift_clear_policer_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_policer_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_policer_stats_presult::~switch_sai_rpc_sai_thrift_clear_policer_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_profile_args::~switch_sai_rpc_sai_thrift_create_scheduler_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size766;
            ::apache::thrift::protocol::TType _etype769;
            xfer += iprot->readListBegin(_etype769, _size766);
            this->thrift_attr_list.resize(_size766);
            uint32_t _i770;
            for (_i770 = 0; _i770 < _size766; ++_i770)
            {
              xfer += this->thrift_attr_list[_i770].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_profile_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter771;
    for (_iter771 = this->thrift_attr_list.begin(); _iter771 != this->thrift_attr_list.end(); ++_iter771)
    {
      xfer += (*_iter771).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs::~switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter772;
    for (_iter772 = (*(this->thrift_attr_list)).begin(); _iter772 != (*(this->thrift_attr_list)).end(); ++_iter772)
    {
      xfer += (*_iter772).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_profile_result::~switch_sai_rpc_sai_thrift_create_scheduler_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_profile_presult::~switch_sai_rpc_sai_thrift_create_scheduler_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_profile_args::~switch_sai_rpc_sai_thrift_remove_scheduler_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduler_id);
          this->__isset.scheduler_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_profile_args");

  xfer += oprot->writeFieldBegin("scheduler_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduler_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs::~switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs");

  xfer += oprot->writeFieldBegin("scheduler_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scheduler_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_profile_result::~switch_sai_rpc_sai_thrift_remove_scheduler_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult::~switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_scheduler_attribute_args::~switch_sai_rpc_sai_thrift_get_scheduler_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_scheduler_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_scheduler_id);
          this->__isset.thrift_scheduler_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_scheduler_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_scheduler_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_scheduler_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_scheduler_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_scheduler_attribute_pargs::~switch_sai_rpc_sai_thrift_get_scheduler_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_scheduler_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_scheduler_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_scheduler_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_scheduler_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_scheduler_attribute_result::~switch_sai_rpc_sai_thrift_get_scheduler_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_scheduler_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_scheduler_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_scheduler_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_scheduler_attribute_presult::~switch_sai_rpc_sai_thrift_get_scheduler_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_scheduler_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_scheduler_attribute_args::~switch_sai_rpc_sai_thrift_set_scheduler_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_scheduler_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_scheduler_id);
          this->__isset.thrift_scheduler_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_scheduler_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_scheduler_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_scheduler_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_scheduler_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_scheduler_attribute_pargs::~switch_sai_rpc_sai_thrift_set_scheduler_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_scheduler_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_scheduler_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_scheduler_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_scheduler_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_scheduler_attribute_result::~switch_sai_rpc_sai_thrift_set_scheduler_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_scheduler_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_scheduler_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_scheduler_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_scheduler_attribute_presult::~switch_sai_rpc_sai_thrift_set_scheduler_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_scheduler_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_group_args::~switch_sai_rpc_sai_thrift_create_scheduler_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size773;
            ::apache::thrift::protocol::TType _etype776;
            xfer += iprot->readListBegin(_etype776, _size773);
            this->thrift_attr_list.resize(_size773);
            uint32_t _i777;
            for (_i777 = 0; _i777 < _size773; ++_i777)
            {
              xfer += this->thrift_attr_list[_i777].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_scheduler_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter778;
    for (_iter778 = this->thrift_attr_list.begin(); _iter778 != this->thrift_attr_list.end(); ++_iter778)
    {
      xfer += (*_iter778).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_group_pargs::~switch_sai_rpc_sai_thrift_create_scheduler_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter779;
    for (_iter779 = (*(this->thrift_attr_list)).begin(); _iter779 != (*(this->thrift_attr_list)).end(); ++_iter779)
    {
      xfer += (*_iter779).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_group_result::~switch_sai_rpc_sai_thrift_create_scheduler_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_scheduler_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_group_presult::~switch_sai_rpc_sai_thrift_create_scheduler_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_group_args::~switch_sai_rpc_sai_thrift_remove_scheduler_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduler_group_id);
          this->__isset.scheduler_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_group_args");

  xfer += oprot->writeFieldBegin("scheduler_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduler_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_group_pargs::~switch_sai_rpc_sai_thrift_remove_scheduler_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_group_pargs");

  xfer += oprot->writeFieldBegin("scheduler_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scheduler_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_group_result::~switch_sai_rpc_sai_thrift_remove_scheduler_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_group_presult::~switch_sai_rpc_sai_thrift_remove_scheduler_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_args::~switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduler_group_id);
          this->__isset.scheduler_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_args");

  xfer += oprot->writeFieldBegin("scheduler_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduler_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("scheduler_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scheduler_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_result::~switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_args::~switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduler_group_id);
          this->__isset.scheduler_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_args");

  xfer += oprot->writeFieldBegin("scheduler_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduler_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_pargs::~switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("scheduler_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scheduler_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_result::~switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_presult::~switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_stats_args::~switch_sai_rpc_sai_thrift_get_queue_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_id);
          this->__isset.queue_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size780;
            ::apache::thrift::protocol::TType _etype783;
            xfer += iprot->readListBegin(_etype783, _size780);
            this->counter_ids.resize(_size780);
            uint32_t _i784;
            for (_i784 = 0; _i784 < _size780; ++_i784)
            {
              xfer += iprot->readI32(this->counter_ids[_i784]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_stats_args");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queue_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter785;
    for (_iter785 = this->counter_ids.begin(); _iter785 != this->counter_ids.end(); ++_iter785)
    {
      xfer += oprot->writeI32((*_iter785));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_stats_pargs::~switch_sai_rpc_sai_thrift_get_queue_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_stats_pargs");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->queue_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter786;
    for (_iter786 = (*(this->counter_ids)).begin(); _iter786 != (*(this->counter_ids)).end(); ++_iter786)
    {
      xfer += oprot->writeI32((*_iter786));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_stats_result::~switch_sai_rpc_sai_thrift_get_queue_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size787;
            ::apache::thrift::protocol::TType _etype790;
            xfer += iprot->readListBegin(_etype790, _size787);
            this->success.resize(_size787);
            uint32_t _i791;
            for (_i791 = 0; _i791 < _size787; ++_i791)
            {
              xfer += iprot->readI64(this->success[_i791]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter792;
      for (_iter792 = this->success.begin(); _iter792 != this->success.end(); ++_iter792)
      {
        xfer += oprot->writeI64((*_iter792));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_stats_presult::~switch_sai_rpc_sai_thrift_get_queue_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size793;
            ::apache::thrift::protocol::TType _etype796;
            xfer += iprot->readListBegin(_etype796, _size793);
            (*(this->success)).resize(_size793);
            uint32_t _i797;
            for (_i797 = 0; _i797 < _size793; ++_i797)
            {
              xfer += iprot->readI64((*(this->success))[_i797]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_queue_stats_args::~switch_sai_rpc_sai_thrift_clear_queue_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_id);
          this->__isset.queue_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size798;
            ::apache::thrift::protocol::TType _etype801;
            xfer += iprot->readListBegin(_etype801, _size798);
            this->counter_ids.resize(_size798);
            uint32_t _i802;
            for (_i802 = 0; _i802 < _size798; ++_i802)
            {
              xfer += iprot->readI32(this->counter_ids[_i802]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_queue_stats_args");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queue_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter803;
    for (_iter803 = this->counter_ids.begin(); _iter803 != this->counter_ids.end(); ++_iter803)
    {
      xfer += oprot->writeI32((*_iter803));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_queue_stats_pargs::~switch_sai_rpc_sai_thrift_clear_queue_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_queue_stats_pargs");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->queue_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter804;
    for (_iter804 = (*(this->counter_ids)).begin(); _iter804 != (*(this->counter_ids)).end(); ++_iter804)
    {
      xfer += oprot->writeI32((*_iter804));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_queue_stats_result::~switch_sai_rpc_sai_thrift_clear_queue_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_queue_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_queue_stats_presult::~switch_sai_rpc_sai_thrift_clear_queue_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_queue_args::~switch_sai_rpc_sai_thrift_create_queue_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_queue_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size805;
            ::apache::thrift::protocol::TType _etype808;
            xfer += iprot->readListBegin(_etype808, _size805);
            this->thrift_attr_list.resize(_size805);
            uint32_t _i809;
            for (_i809 = 0; _i809 < _size805; ++_i809)
            {
              xfer += this->thrift_attr_list[_i809].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_queue_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_queue_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter810;
    for (_iter810 = this->thrift_attr_list.begin(); _iter810 != this->thrift_attr_list.end(); ++_iter810)
    {
      xfer += (*_iter810).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_queue_pargs::~switch_sai_rpc_sai_thrift_create_queue_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_queue_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_queue_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter811;
    for (_iter811 = (*(this->thrift_attr_list)).begin(); _iter811 != (*(this->thrift_attr_list)).end(); ++_iter811)
    {
      xfer += (*_iter811).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_queue_result::~switch_sai_rpc_sai_thrift_create_queue_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_queue_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_queue_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_queue_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_queue_presult::~switch_sai_rpc_sai_thrift_create_queue_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_queue_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_queue_args::~switch_sai_rpc_sai_thrift_remove_queue_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_queue_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_id);
          this->__isset.queue_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_queue_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_queue_args");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queue_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_queue_pargs::~switch_sai_rpc_sai_thrift_remove_queue_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_queue_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_queue_pargs");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->queue_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_queue_result::~switch_sai_rpc_sai_thrift_remove_queue_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_queue_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_queue_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_queue_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_queue_presult::~switch_sai_rpc_sai_thrift_remove_queue_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_queue_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_attribute_args::~switch_sai_rpc_sai_thrift_get_queue_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_id);
          this->__isset.queue_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_queue_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_attribute_args");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queue_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_attribute_pargs::~switch_sai_rpc_sai_thrift_get_queue_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_attribute_pargs");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->queue_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_attribute_result::~switch_sai_rpc_sai_thrift_get_queue_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_queue_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_attribute_presult::~switch_sai_rpc_sai_thrift_get_queue_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_queue_attribute_args::~switch_sai_rpc_sai_thrift_set_queue_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_id);
          this->__isset.queue_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_queue_attribute_args");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queue_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_queue_attribute_pargs::~switch_sai_rpc_sai_thrift_set_queue_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_queue_attribute_pargs");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->queue_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_queue_attribute_result::~switch_sai_rpc_sai_thrift_set_queue_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_queue_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_queue_attribute_presult::~switch_sai_rpc_sai_thrift_set_queue_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_buffer_profile_args::~switch_sai_rpc_sai_thrift_create_buffer_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size812;
            ::apache::thrift::protocol::TType _etype815;
            xfer += iprot->readListBegin(_etype815, _size812);
            this->thrift_attr_list.resize(_size812);
            uint32_t _i816;
            for (_i816 = 0; _i816 < _size812; ++_i816)
            {
              xfer += this->thrift_attr_list[_i816].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_buffer_profile_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter817;
    for (_iter817 = this->thrift_attr_list.begin(); _iter817 != this->thrift_attr_list.end(); ++_iter817)
    {
      xfer += (*_iter817).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_buffer_profile_pargs::~switch_sai_rpc_sai_thrift_create_buffer_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_buffer_profile_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter818;
    for (_iter818 = (*(this->thrift_attr_list)).begin(); _iter818 != (*(this->thrift_attr_list)).end(); ++_iter818)
    {
      xfer += (*_iter818).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_buffer_profile_result::~switch_sai_rpc_sai_thrift_create_buffer_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_buffer_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_buffer_profile_presult::~switch_sai_rpc_sai_thrift_create_buffer_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_buffer_profile_args::~switch_sai_rpc_sai_thrift_remove_buffer_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_buffer_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->buffer_profile_id);
          this->__isset.buffer_profile_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_buffer_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_buffer_profile_args");

  xfer += oprot->writeFieldBegin("buffer_profile_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->buffer_profile_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_buffer_profile_pargs::~switch_sai_rpc_sai_thrift_remove_buffer_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_buffer_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_buffer_profile_pargs");

  xfer += oprot->writeFieldBegin("buffer_profile_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->buffer_profile_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_buffer_profile_result::~switch_sai_rpc_sai_thrift_remove_buffer_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_buffer_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_buffer_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_buffer_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_buffer_profile_presult::~switch_sai_rpc_sai_thrift_remove_buffer_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_buffer_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_args::~switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->buffer_profile_id);
          this->__isset.buffer_profile_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_args");

  xfer += oprot->writeFieldBegin("buffer_profile_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->buffer_profile_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_pargs::~switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_pargs");

  xfer += oprot->writeFieldBegin("buffer_profile_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->buffer_profile_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_result::~switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_presult::~switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_args::~switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->buffer_profile_id);
          this->__isset.buffer_profile_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_args");

  xfer += oprot->writeFieldBegin("buffer_profile_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->buffer_profile_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_pargs::~switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_pargs");

  xfer += oprot->writeFieldBegin("buffer_profile_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->buffer_profile_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_result::~switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_presult::~switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_pool_profile_args::~switch_sai_rpc_sai_thrift_create_pool_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size819;
            ::apache::thrift::protocol::TType _etype822;
            xfer += iprot->readListBegin(_etype822, _size819);
            this->thrift_attr_list.resize(_size819);
            uint32_t _i823;
            for (_i823 = 0; _i823 < _size819; ++_i823)
            {
              xfer += this->thrift_attr_list[_i823].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_pool_profile_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter824;
    for (_iter824 = this->thrift_attr_list.begin(); _iter824 != this->thrift_attr_list.end(); ++_iter824)
    {
      xfer += (*_iter824).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_pool_profile_pargs::~switch_sai_rpc_sai_thrift_create_pool_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_pool_profile_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter825;
    for (_iter825 = (*(this->thrift_attr_list)).begin(); _iter825 != (*(this->thrift_attr_list)).end(); ++_iter825)
    {
      xfer += (*_iter825).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_pool_profile_result::~switch_sai_rpc_sai_thrift_create_pool_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_pool_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_pool_profile_presult::~switch_sai_rpc_sai_thrift_create_pool_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_priority_group_args::~switch_sai_rpc_sai_thrift_create_priority_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_priority_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size826;
            ::apache::thrift::protocol::TType _etype829;
            xfer += iprot->readListBegin(_etype829, _size826);
            this->thrift_attr_list.resize(_size826);
            uint32_t _i830;
            for (_i830 = 0; _i830 < _size826; ++_i830)
            {
              xfer += this->thrift_attr_list[_i830].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_priority_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_priority_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter831;
    for (_iter831 = this->thrift_attr_list.begin(); _iter831 != this->thrift_attr_list.end(); ++_iter831)
    {
      xfer += (*_iter831).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_priority_group_pargs::~switch_sai_rpc_sai_thrift_create_priority_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_priority_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_priority_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter832;
    for (_iter832 = (*(this->thrift_attr_list)).begin(); _iter832 != (*(this->thrift_attr_list)).end(); ++_iter832)
    {
      xfer += (*_iter832).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_priority_group_result::~switch_sai_rpc_sai_thrift_create_priority_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_priority_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_priority_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_priority_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_priority_group_presult::~switch_sai_rpc_sai_thrift_create_priority_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_priority_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_priority_group_args::~switch_sai_rpc_sai_thrift_remove_priority_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_priority_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->priority_group_id);
          this->__isset.priority_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_priority_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_priority_group_args");

  xfer += oprot->writeFieldBegin("priority_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->priority_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_priority_group_pargs::~switch_sai_rpc_sai_thrift_remove_priority_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_priority_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_priority_group_pargs");

  xfer += oprot->writeFieldBegin("priority_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->priority_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_priority_group_result::~switch_sai_rpc_sai_thrift_remove_priority_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_priority_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_priority_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_priority_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_priority_group_presult::~switch_sai_rpc_sai_thrift_remove_priority_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_priority_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_priority_group_attribute_args::~switch_sai_rpc_sai_thrift_get_priority_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_priority_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->priority_group_id);
          this->__isset.priority_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_priority_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_priority_group_attribute_args");

  xfer += oprot->writeFieldBegin("priority_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->priority_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_priority_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_priority_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_priority_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_priority_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("priority_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->priority_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_priority_group_attribute_result::~switch_sai_rpc_sai_thrift_get_priority_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_priority_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_priority_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_priority_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_priority_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_priority_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_priority_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_priority_group_attribute_args::~switch_sai_rpc_sai_thrift_set_priority_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pg_id);
          this->__isset.pg_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_priority_group_attribute_args");

  xfer += oprot->writeFieldBegin("pg_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->pg_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs::~switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("pg_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->pg_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_priority_group_attribute_result::~switch_sai_rpc_sai_thrift_set_priority_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_priority_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult::~switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_pg_stats_args::~switch_sai_rpc_sai_thrift_get_pg_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pg_id);
          this->__isset.pg_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size833;
            ::apache::thrift::protocol::TType _etype836;
            xfer += iprot->readListBegin(_etype836, _size833);
            this->counter_ids.resize(_size833);
            uint32_t _i837;
            for (_i837 = 0; _i837 < _size833; ++_i837)
            {
              xfer += iprot->readI32(this->counter_ids[_i837]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_pg_stats_args");

  xfer += oprot->writeFieldBegin("pg_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->pg_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_pg_stat_counter_t> ::const_iterator _iter838;
    for (_iter838 = this->counter_ids.begin(); _iter838 != this->counter_ids.end(); ++_iter838)
    {
      xfer += oprot->writeI32((*_iter838));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_pg_stats_pargs::~switch_sai_rpc_sai_thrift_get_pg_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_pg_stats_pargs");

  xfer += oprot->writeFieldBegin("pg_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->pg_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_pg_stat_counter_t> ::const_iterator _iter839;
    for (_iter839 = (*(this->counter_ids)).begin(); _iter839 != (*(this->counter_ids)).end(); ++_iter839)
    {
      xfer += oprot->writeI32((*_iter839));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_pg_stats_result::~switch_sai_rpc_sai_thrift_get_pg_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size840;
            ::apache::thrift::protocol::TType _etype843;
            xfer += iprot->readListBegin(_etype843, _size840);
            this->success.resize(_size840);
            uint32_t _i844;
            for (_i844 = 0; _i844 < _size840; ++_i844)
            {
              xfer += iprot->readI64(this->success[_i844]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_pg_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter845;
      for (_iter845 = this->success.begin(); _iter845 != this->success.end(); ++_iter845)
      {
        xfer += oprot->writeI64((*_iter845));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_pg_stats_presult::~switch_sai_rpc_sai_thrift_get_pg_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size846;
            ::apache::thrift::protocol::TType _etype849;
            xfer += iprot->readListBegin(_etype849, _size846);
            (*(this->success)).resize(_size846);
            uint32_t _i850;
            for (_i850 = 0; _i850 < _size846; ++_i850)
            {
              xfer += iprot->readI64((*(this->success))[_i850]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_wred_profile_args::~switch_sai_rpc_sai_thrift_create_wred_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size851;
            ::apache::thrift::protocol::TType _etype854;
            xfer += iprot->readListBegin(_etype854, _size851);
            this->thrift_attr_list.resize(_size851);
            uint32_t _i855;
            for (_i855 = 0; _i855 < _size851; ++_i855)
            {
              xfer += this->thrift_attr_list[_i855].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_wred_profile_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter856;
    for (_iter856 = this->thrift_attr_list.begin(); _iter856 != this->thrift_attr_list.end(); ++_iter856)
    {
      xfer += (*_iter856).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_wred_profile_pargs::~switch_sai_rpc_sai_thrift_create_wred_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_wred_profile_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter857;
    for (_iter857 = (*(this->thrift_attr_list)).begin(); _iter857 != (*(this->thrift_attr_list)).end(); ++_iter857)
    {
      xfer += (*_iter857).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_wred_profile_result::~switch_sai_rpc_sai_thrift_create_wred_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_wred_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_wred_profile_presult::~switch_sai_rpc_sai_thrift_create_wred_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_wred_profile_args::~switch_sai_rpc_sai_thrift_remove_wred_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->wred_id);
          this->__isset.wred_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_wred_profile_args");

  xfer += oprot->writeFieldBegin("wred_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->wred_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_wred_profile_pargs::~switch_sai_rpc_sai_thrift_remove_wred_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_wred_profile_pargs");

  xfer += oprot->writeFieldBegin("wred_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->wred_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_wred_profile_result::~switch_sai_rpc_sai_thrift_remove_wred_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_wred_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_wred_profile_presult::~switch_sai_rpc_sai_thrift_remove_wred_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_wred_attribute_profile_args::~switch_sai_rpc_sai_thrift_get_wred_attribute_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_wred_attribute_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->wred_id);
          this->__isset.wred_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_wred_attribute_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_wred_attribute_profile_args");

  xfer += oprot->writeFieldBegin("wred_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->wred_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_wred_attribute_profile_pargs::~switch_sai_rpc_sai_thrift_get_wred_attribute_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_wred_attribute_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_wred_attribute_profile_pargs");

  xfer += oprot->writeFieldBegin("wred_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->wred_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_wred_attribute_profile_result::~switch_sai_rpc_sai_thrift_get_wred_attribute_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_wred_attribute_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_wred_attribute_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_wred_attribute_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_wred_attribute_profile_presult::~switch_sai_rpc_sai_thrift_get_wred_attribute_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_wred_attribute_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_wred_attribute_profile_args::~switch_sai_rpc_sai_thrift_set_wred_attribute_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_wred_attribute_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->wred_id);
          this->__isset.wred_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_wred_attribute_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_wred_attribute_profile_args");

  xfer += oprot->writeFieldBegin("wred_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->wred_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_wred_attribute_profile_pargs::~switch_sai_rpc_sai_thrift_set_wred_attribute_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_wred_attribute_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_wred_attribute_profile_pargs");

  xfer += oprot->writeFieldBegin("wred_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->wred_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_wred_attribute_profile_result::~switch_sai_rpc_sai_thrift_set_wred_attribute_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_wred_attribute_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_wred_attribute_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_wred_attribute_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_wred_attribute_profile_presult::~switch_sai_rpc_sai_thrift_set_wred_attribute_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_wred_attribute_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_qos_map_args::~switch_sai_rpc_sai_thrift_create_qos_map_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_qos_map_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size858;
            ::apache::thrift::protocol::TType _etype861;
            xfer += iprot->readListBegin(_etype861, _size858);
            this->thrift_attr_list.resize(_size858);
            uint32_t _i862;
            for (_i862 = 0; _i862 < _size858; ++_i862)
            {
              xfer += this->thrift_attr_list[_i862].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_qos_map_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_qos_map_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter863;
    for (_iter863 = this->thrift_attr_list.begin(); _iter863 != this->thrift_attr_list.end(); ++_iter863)
    {
      xfer += (*_iter863).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_qos_map_pargs::~switch_sai_rpc_sai_thrift_create_qos_map_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_qos_map_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_qos_map_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter864;
    for (_iter864 = (*(this->thrift_attr_list)).begin(); _iter864 != (*(this->thrift_attr_list)).end(); ++_iter864)
    {
      xfer += (*_iter864).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_qos_map_result::~switch_sai_rpc_sai_thrift_create_qos_map_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_qos_map_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_qos_map_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_qos_map_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_qos_map_presult::~switch_sai_rpc_sai_thrift_create_qos_map_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_qos_map_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_qos_map_args::~switch_sai_rpc_sai_thrift_remove_qos_map_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->qos_map_id);
          this->__isset.qos_map_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_qos_map_args");

  xfer += oprot->writeFieldBegin("qos_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->qos_map_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_qos_map_pargs::~switch_sai_rpc_sai_thrift_remove_qos_map_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_qos_map_pargs");

  xfer += oprot->writeFieldBegin("qos_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->qos_map_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_qos_map_result::~switch_sai_rpc_sai_thrift_remove_qos_map_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_qos_map_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_qos_map_presult::~switch_sai_rpc_sai_thrift_remove_qos_map_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_qos_map_attribute_args::~switch_sai_rpc_sai_thrift_get_qos_map_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_qos_map_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->qos_map_id);
          this->__isset.qos_map_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_qos_map_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_qos_map_attribute_args");

  xfer += oprot->writeFieldBegin("qos_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->qos_map_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_qos_map_attribute_pargs::~switch_sai_rpc_sai_thrift_get_qos_map_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_qos_map_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_qos_map_attribute_pargs");

  xfer += oprot->writeFieldBegin("qos_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->qos_map_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_qos_map_attribute_result::~switch_sai_rpc_sai_thrift_get_qos_map_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_qos_map_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_qos_map_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_qos_map_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_qos_map_attribute_presult::~switch_sai_rpc_sai_thrift_get_qos_map_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_qos_map_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_qos_map_attribute_args::~switch_sai_rpc_sai_thrift_set_qos_map_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_qos_map_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->qos_map_id);
          this->__isset.qos_map_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_qos_map_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_qos_map_attribute_args");

  xfer += oprot->writeFieldBegin("qos_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->qos_map_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_qos_map_attribute_pargs::~switch_sai_rpc_sai_thrift_set_qos_map_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_qos_map_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_qos_map_attribute_pargs");

  xfer += oprot->writeFieldBegin("qos_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->qos_map_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_qos_map_attribute_result::~switch_sai_rpc_sai_thrift_set_qos_map_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_qos_map_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_qos_map_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_qos_map_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_qos_map_attribute_presult::~switch_sai_rpc_sai_thrift_set_qos_map_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_qos_map_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_group_args::~switch_sai_rpc_sai_thrift_create_l2mc_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size865;
            ::apache::thrift::protocol::TType _etype868;
            xfer += iprot->readListBegin(_etype868, _size865);
            this->thrift_attr_list.resize(_size865);
            uint32_t _i869;
            for (_i869 = 0; _i869 < _size865; ++_i869)
            {
              xfer += this->thrift_attr_list[_i869].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter870;
    for (_iter870 = this->thrift_attr_list.begin(); _iter870 != this->thrift_attr_list.end(); ++_iter870)
    {
      xfer += (*_iter870).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_group_pargs::~switch_sai_rpc_sai_thrift_create_l2mc_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter871;
    for (_iter871 = (*(this->thrift_attr_list)).begin(); _iter871 != (*(this->thrift_attr_list)).end(); ++_iter871)
    {
      xfer += (*_iter871).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_group_result::~switch_sai_rpc_sai_thrift_create_l2mc_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_group_presult::~switch_sai_rpc_sai_thrift_create_l2mc_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_group_args::~switch_sai_rpc_sai_thrift_remove_l2mc_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->grp_id);
          this->__isset.grp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_group_args");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->grp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_group_pargs::~switch_sai_rpc_sai_thrift_remove_l2mc_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_group_pargs");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->grp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_group_result::~switch_sai_rpc_sai_thrift_remove_l2mc_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_group_presult::~switch_sai_rpc_sai_thrift_remove_l2mc_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_args::~switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->grp_id);
          this->__isset.grp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_args");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->grp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->grp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_result::~switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_group_member_args::~switch_sai_rpc_sai_thrift_create_l2mc_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size872;
            ::apache::thrift::protocol::TType _etype875;
            xfer += iprot->readListBegin(_etype875, _size872);
            this->thrift_attr_list.resize(_size872);
            uint32_t _i876;
            for (_i876 = 0; _i876 < _size872; ++_i876)
            {
              xfer += this->thrift_attr_list[_i876].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_group_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter877;
    for (_iter877 = this->thrift_attr_list.begin(); _iter877 != this->thrift_attr_list.end(); ++_iter877)
    {
      xfer += (*_iter877).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_group_member_pargs::~switch_sai_rpc_sai_thrift_create_l2mc_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_group_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter878;
    for (_iter878 = (*(this->thrift_attr_list)).begin(); _iter878 != (*(this->thrift_attr_list)).end(); ++_iter878)
    {
      xfer += (*_iter878).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_group_member_result::~switch_sai_rpc_sai_thrift_create_l2mc_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_group_member_presult::~switch_sai_rpc_sai_thrift_create_l2mc_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_group_member_args::~switch_sai_rpc_sai_thrift_remove_l2mc_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_group_member_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_group_member_pargs::~switch_sai_rpc_sai_thrift_remove_l2mc_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_group_member_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_group_member_result::~switch_sai_rpc_sai_thrift_remove_l2mc_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_group_member_presult::~switch_sai_rpc_sai_thrift_remove_l2mc_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_args::~switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_pargs::~switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_result::~switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_presult::~switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_args::~switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_result::~switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_entry_args::~switch_sai_rpc_sai_thrift_create_l2mc_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_l2mc_entry.read(iprot);
          this->__isset.thrift_l2mc_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size879;
            ::apache::thrift::protocol::TType _etype882;
            xfer += iprot->readListBegin(_etype882, _size879);
            this->thrift_attr_list.resize(_size879);
            uint32_t _i883;
            for (_i883 = 0; _i883 < _size879; ++_i883)
            {
              xfer += this->thrift_attr_list[_i883].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_l2mc_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_entry_args");

  xfer += oprot->writeFieldBegin("thrift_l2mc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_l2mc_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter884;
    for (_iter884 = this->thrift_attr_list.begin(); _iter884 != this->thrift_attr_list.end(); ++_iter884)
    {
      xfer += (*_iter884).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_entry_pargs::~switch_sai_rpc_sai_thrift_create_l2mc_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_l2mc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_l2mc_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter885;
    for (_iter885 = (*(this->thrift_attr_list)).begin(); _iter885 != (*(this->thrift_attr_list)).end(); ++_iter885)
    {
      xfer += (*_iter885).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_entry_result::~switch_sai_rpc_sai_thrift_create_l2mc_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_l2mc_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_l2mc_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_l2mc_entry_presult::~switch_sai_rpc_sai_thrift_create_l2mc_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_l2mc_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_entry_args::~switch_sai_rpc_sai_thrift_remove_l2mc_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_l2mc_entry.read(iprot);
          this->__isset.thrift_l2mc_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_entry_args");

  xfer += oprot->writeFieldBegin("thrift_l2mc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_l2mc_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_entry_pargs::~switch_sai_rpc_sai_thrift_remove_l2mc_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_l2mc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_l2mc_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_entry_result::~switch_sai_rpc_sai_thrift_remove_l2mc_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_l2mc_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_l2mc_entry_presult::~switch_sai_rpc_sai_thrift_remove_l2mc_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_l2mc_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_l2mc_entry.read(iprot);
          this->__isset.thrift_l2mc_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_l2mc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_l2mc_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_l2mc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_l2mc_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_l2mc_entry.read(iprot);
          this->__isset.thrift_l2mc_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_l2mc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_l2mc_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_l2mc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_l2mc_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_args::~switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_mcast_fdb_entry.read(iprot);
          this->__isset.thrift_mcast_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size886;
            ::apache::thrift::protocol::TType _etype889;
            xfer += iprot->readListBegin(_etype889, _size886);
            this->thrift_attr_list.resize(_size886);
            uint32_t _i890;
            for (_i890 = 0; _i890 < _size886; ++_i890)
            {
              xfer += this->thrift_attr_list[_i890].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_args");

  xfer += oprot->writeFieldBegin("thrift_mcast_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_mcast_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter891;
    for (_iter891 = this->thrift_attr_list.begin(); _iter891 != this->thrift_attr_list.end(); ++_iter891)
    {
      xfer += (*_iter891).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_pargs::~switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_mcast_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_mcast_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter892;
    for (_iter892 = (*(this->thrift_attr_list)).begin(); _iter892 != (*(this->thrift_attr_list)).end(); ++_iter892)
    {
      xfer += (*_iter892).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_result::~switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_presult::~switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_args::~switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_mcast_fdb_entry.read(iprot);
          this->__isset.thrift_mcast_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_args");

  xfer += oprot->writeFieldBegin("thrift_mcast_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_mcast_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_pargs::~switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_mcast_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_mcast_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_result::~switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_presult::~switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_mcast_fdb_entry.read(iprot);
          this->__isset.thrift_mcast_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_mcast_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_mcast_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_mcast_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_mcast_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_mcast_fdb_entry.read(iprot);
          this->__isset.thrift_mcast_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_mcast_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_mcast_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_mcast_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_mcast_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_group_args::~switch_sai_rpc_sai_thrift_create_ipmc_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size893;
            ::apache::thrift::protocol::TType _etype896;
            xfer += iprot->readListBegin(_etype896, _size893);
            this->thrift_attr_list.resize(_size893);
            uint32_t _i897;
            for (_i897 = 0; _i897 < _size893; ++_i897)
            {
              xfer += this->thrift_attr_list[_i897].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter898;
    for (_iter898 = this->thrift_attr_list.begin(); _iter898 != this->thrift_attr_list.end(); ++_iter898)
    {
      xfer += (*_iter898).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_group_pargs::~switch_sai_rpc_sai_thrift_create_ipmc_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter899;
    for (_iter899 = (*(this->thrift_attr_list)).begin(); _iter899 != (*(this->thrift_attr_list)).end(); ++_iter899)
    {
      xfer += (*_iter899).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_group_result::~switch_sai_rpc_sai_thrift_create_ipmc_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_group_presult::~switch_sai_rpc_sai_thrift_create_ipmc_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_group_args::~switch_sai_rpc_sai_thrift_remove_ipmc_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->grp_id);
          this->__isset.grp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_group_args");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->grp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_group_pargs::~switch_sai_rpc_sai_thrift_remove_ipmc_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_group_pargs");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->grp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_group_result::~switch_sai_rpc_sai_thrift_remove_ipmc_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_group_presult::~switch_sai_rpc_sai_thrift_remove_ipmc_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_args::~switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->grp_id);
          this->__isset.grp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_args");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->grp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->grp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_result::~switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_group_member_args::~switch_sai_rpc_sai_thrift_create_ipmc_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size900;
            ::apache::thrift::protocol::TType _etype903;
            xfer += iprot->readListBegin(_etype903, _size900);
            this->thrift_attr_list.resize(_size900);
            uint32_t _i904;
            for (_i904 = 0; _i904 < _size900; ++_i904)
            {
              xfer += this->thrift_attr_list[_i904].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_group_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter905;
    for (_iter905 = this->thrift_attr_list.begin(); _iter905 != this->thrift_attr_list.end(); ++_iter905)
    {
      xfer += (*_iter905).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_group_member_pargs::~switch_sai_rpc_sai_thrift_create_ipmc_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_group_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter906;
    for (_iter906 = (*(this->thrift_attr_list)).begin(); _iter906 != (*(this->thrift_attr_list)).end(); ++_iter906)
    {
      xfer += (*_iter906).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_group_member_result::~switch_sai_rpc_sai_thrift_create_ipmc_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_group_member_presult::~switch_sai_rpc_sai_thrift_create_ipmc_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_group_member_args::~switch_sai_rpc_sai_thrift_remove_ipmc_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_group_member_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_group_member_pargs::~switch_sai_rpc_sai_thrift_remove_ipmc_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_group_member_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_group_member_result::~switch_sai_rpc_sai_thrift_remove_ipmc_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_group_member_presult::~switch_sai_rpc_sai_thrift_remove_ipmc_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_args::~switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_pargs::~switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_result::~switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_presult::~switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_args::~switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_result::~switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_rpf_group_args::~switch_sai_rpc_sai_thrift_create_rpf_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size907;
            ::apache::thrift::protocol::TType _etype910;
            xfer += iprot->readListBegin(_etype910, _size907);
            this->thrift_attr_list.resize(_size907);
            uint32_t _i911;
            for (_i911 = 0; _i911 < _size907; ++_i911)
            {
              xfer += this->thrift_attr_list[_i911].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_rpf_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter912;
    for (_iter912 = this->thrift_attr_list.begin(); _iter912 != this->thrift_attr_list.end(); ++_iter912)
    {
      xfer += (*_iter912).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_rpf_group_pargs::~switch_sai_rpc_sai_thrift_create_rpf_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_rpf_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter913;
    for (_iter913 = (*(this->thrift_attr_list)).begin(); _iter913 != (*(this->thrift_attr_list)).end(); ++_iter913)
    {
      xfer += (*_iter913).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_rpf_group_result::~switch_sai_rpc_sai_thrift_create_rpf_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_rpf_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_rpf_group_presult::~switch_sai_rpc_sai_thrift_create_rpf_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_rpf_group_args::~switch_sai_rpc_sai_thrift_remove_rpf_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->grp_id);
          this->__isset.grp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_rpf_group_args");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->grp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_rpf_group_pargs::~switch_sai_rpc_sai_thrift_remove_rpf_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_rpf_group_pargs");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->grp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_rpf_group_result::~switch_sai_rpc_sai_thrift_remove_rpf_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_rpf_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_rpf_group_presult::~switch_sai_rpc_sai_thrift_remove_rpf_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_rpf_group_attribute_args::~switch_sai_rpc_sai_thrift_get_rpf_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->grp_id);
          this->__isset.grp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_rpf_group_attribute_args");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->grp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_rpf_group_attribute_pargs::~switch_sai_rpc_sai_thrift_get_rpf_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_rpf_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("grp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->grp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_rpf_group_attribute_result::~switch_sai_rpc_sai_thrift_get_rpf_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_rpf_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_rpf_group_attribute_presult::~switch_sai_rpc_sai_thrift_get_rpf_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_rpf_group_member_args::~switch_sai_rpc_sai_thrift_create_rpf_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size914;
            ::apache::thrift::protocol::TType _etype917;
            xfer += iprot->readListBegin(_etype917, _size914);
            this->thrift_attr_list.resize(_size914);
            uint32_t _i918;
            for (_i918 = 0; _i918 < _size914; ++_i918)
            {
              xfer += this->thrift_attr_list[_i918].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_rpf_group_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter919;
    for (_iter919 = this->thrift_attr_list.begin(); _iter919 != this->thrift_attr_list.end(); ++_iter919)
    {
      xfer += (*_iter919).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_rpf_group_member_pargs::~switch_sai_rpc_sai_thrift_create_rpf_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_rpf_group_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter920;
    for (_iter920 = (*(this->thrift_attr_list)).begin(); _iter920 != (*(this->thrift_attr_list)).end(); ++_iter920)
    {
      xfer += (*_iter920).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_rpf_group_member_result::~switch_sai_rpc_sai_thrift_create_rpf_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_rpf_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_rpf_group_member_presult::~switch_sai_rpc_sai_thrift_create_rpf_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_rpf_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_rpf_group_member_args::~switch_sai_rpc_sai_thrift_remove_rpf_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_rpf_group_member_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_rpf_group_member_pargs::~switch_sai_rpc_sai_thrift_remove_rpf_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_rpf_group_member_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_rpf_group_member_result::~switch_sai_rpc_sai_thrift_remove_rpf_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_rpf_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_rpf_group_member_presult::~switch_sai_rpc_sai_thrift_remove_rpf_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_rpf_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_args::~switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_pargs::~switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_result::~switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_presult::~switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_args::~switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_id);
          this->__isset.member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_args");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_result::~switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_entry_args::~switch_sai_rpc_sai_thrift_create_ipmc_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_ipmc_entry.read(iprot);
          this->__isset.thrift_ipmc_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size921;
            ::apache::thrift::protocol::TType _etype924;
            xfer += iprot->readListBegin(_etype924, _size921);
            this->thrift_attr_list.resize(_size921);
            uint32_t _i925;
            for (_i925 = 0; _i925 < _size921; ++_i925)
            {
              xfer += this->thrift_attr_list[_i925].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_ipmc_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_entry_args");

  xfer += oprot->writeFieldBegin("thrift_ipmc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_ipmc_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter926;
    for (_iter926 = this->thrift_attr_list.begin(); _iter926 != this->thrift_attr_list.end(); ++_iter926)
    {
      xfer += (*_iter926).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_entry_pargs::~switch_sai_rpc_sai_thrift_create_ipmc_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_ipmc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_ipmc_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter927;
    for (_iter927 = (*(this->thrift_attr_list)).begin(); _iter927 != (*(this->thrift_attr_list)).end(); ++_iter927)
    {
      xfer += (*_iter927).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_entry_result::~switch_sai_rpc_sai_thrift_create_ipmc_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_ipmc_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ipmc_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ipmc_entry_presult::~switch_sai_rpc_sai_thrift_create_ipmc_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ipmc_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_entry_args::~switch_sai_rpc_sai_thrift_remove_ipmc_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_ipmc_entry.read(iprot);
          this->__isset.thrift_ipmc_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_entry_args");

  xfer += oprot->writeFieldBegin("thrift_ipmc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_ipmc_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_entry_pargs::~switch_sai_rpc_sai_thrift_remove_ipmc_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_ipmc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_ipmc_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_entry_result::~switch_sai_rpc_sai_thrift_remove_ipmc_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ipmc_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ipmc_entry_presult::~switch_sai_rpc_sai_thrift_remove_ipmc_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ipmc_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_ipmc_entry.read(iprot);
          this->__isset.thrift_ipmc_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_ipmc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_ipmc_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_ipmc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_ipmc_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_ipmc_entry.read(iprot);
          this->__isset.thrift_ipmc_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_ipmc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_ipmc_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_ipmc_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_ipmc_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_samplepacket_args::~switch_sai_rpc_sai_thrift_create_samplepacket_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_samplepacket_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size928;
            ::apache::thrift::protocol::TType _etype931;
            xfer += iprot->readListBegin(_etype931, _size928);
            this->thrift_attr_list.resize(_size928);
            uint32_t _i932;
            for (_i932 = 0; _i932 < _size928; ++_i932)
            {
              xfer += this->thrift_attr_list[_i932].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_samplepacket_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_samplepacket_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter933;
    for (_iter933 = this->thrift_attr_list.begin(); _iter933 != this->thrift_attr_list.end(); ++_iter933)
    {
      xfer += (*_iter933).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_samplepacket_pargs::~switch_sai_rpc_sai_thrift_create_samplepacket_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_samplepacket_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_samplepacket_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter934;
    for (_iter934 = (*(this->thrift_attr_list)).begin(); _iter934 != (*(this->thrift_attr_list)).end(); ++_iter934)
    {
      xfer += (*_iter934).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_samplepacket_result::~switch_sai_rpc_sai_thrift_create_samplepacket_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_samplepacket_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_samplepacket_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_samplepacket_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_samplepacket_presult::~switch_sai_rpc_sai_thrift_create_samplepacket_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_samplepacket_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_samplepacket_args::~switch_sai_rpc_sai_thrift_remove_samplepacket_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_samplepacket_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->samplepacket_id);
          this->__isset.samplepacket_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_samplepacket_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_samplepacket_args");

  xfer += oprot->writeFieldBegin("samplepacket_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->samplepacket_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_samplepacket_pargs::~switch_sai_rpc_sai_thrift_remove_samplepacket_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_samplepacket_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_samplepacket_pargs");

  xfer += oprot->writeFieldBegin("samplepacket_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->samplepacket_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_samplepacket_result::~switch_sai_rpc_sai_thrift_remove_samplepacket_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_samplepacket_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_samplepacket_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_samplepacket_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_samplepacket_presult::~switch_sai_rpc_sai_thrift_remove_samplepacket_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_samplepacket_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_samplepacket_attribute_args::~switch_sai_rpc_sai_thrift_get_samplepacket_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_samplepacket_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->samplepacket_id);
          this->__isset.samplepacket_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_samplepacket_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_samplepacket_attribute_args");

  xfer += oprot->writeFieldBegin("samplepacket_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->samplepacket_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_samplepacket_attribute_pargs::~switch_sai_rpc_sai_thrift_get_samplepacket_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_samplepacket_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_samplepacket_attribute_pargs");

  xfer += oprot->writeFieldBegin("samplepacket_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->samplepacket_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_samplepacket_attribute_result::~switch_sai_rpc_sai_thrift_get_samplepacket_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_samplepacket_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_samplepacket_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_samplepacket_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_samplepacket_attribute_presult::~switch_sai_rpc_sai_thrift_get_samplepacket_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_samplepacket_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_samplepacket_attribute_args::~switch_sai_rpc_sai_thrift_set_samplepacket_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_samplepacket_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->samplepacket_id);
          this->__isset.samplepacket_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_samplepacket_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_samplepacket_attribute_args");

  xfer += oprot->writeFieldBegin("samplepacket_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->samplepacket_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_samplepacket_attribute_pargs::~switch_sai_rpc_sai_thrift_set_samplepacket_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_samplepacket_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_samplepacket_attribute_pargs");

  xfer += oprot->writeFieldBegin("samplepacket_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->samplepacket_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_samplepacket_attribute_result::~switch_sai_rpc_sai_thrift_set_samplepacket_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_samplepacket_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_samplepacket_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_samplepacket_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_samplepacket_attribute_presult::~switch_sai_rpc_sai_thrift_set_samplepacket_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_samplepacket_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_map_entry_args::~switch_sai_rpc_sai_thrift_create_tunnel_map_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size935;
            ::apache::thrift::protocol::TType _etype938;
            xfer += iprot->readListBegin(_etype938, _size935);
            this->thrift_attr_list.resize(_size935);
            uint32_t _i939;
            for (_i939 = 0; _i939 < _size935; ++_i939)
            {
              xfer += this->thrift_attr_list[_i939].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_map_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter940;
    for (_iter940 = this->thrift_attr_list.begin(); _iter940 != this->thrift_attr_list.end(); ++_iter940)
    {
      xfer += (*_iter940).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_map_entry_pargs::~switch_sai_rpc_sai_thrift_create_tunnel_map_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_map_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter941;
    for (_iter941 = (*(this->thrift_attr_list)).begin(); _iter941 != (*(this->thrift_attr_list)).end(); ++_iter941)
    {
      xfer += (*_iter941).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_map_entry_result::~switch_sai_rpc_sai_thrift_create_tunnel_map_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_map_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_map_entry_presult::~switch_sai_rpc_sai_thrift_create_tunnel_map_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_args::~switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_map_entry_id);
          this->__isset.tunnel_map_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_args");

  xfer += oprot->writeFieldBegin("tunnel_map_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_map_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_pargs::~switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_pargs");

  xfer += oprot->writeFieldBegin("tunnel_map_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_map_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_result::~switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_presult::~switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_map_entry_id);
          this->__isset.tunnel_map_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_args");

  xfer += oprot->writeFieldBegin("tunnel_map_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_map_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("tunnel_map_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_map_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_map_entry_id);
          this->__isset.tunnel_map_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_args");

  xfer += oprot->writeFieldBegin("tunnel_map_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_map_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("tunnel_map_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_map_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_map_args::~switch_sai_rpc_sai_thrift_create_tunnel_map_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size942;
            ::apache::thrift::protocol::TType _etype945;
            xfer += iprot->readListBegin(_etype945, _size942);
            this->thrift_attr_list.resize(_size942);
            uint32_t _i946;
            for (_i946 = 0; _i946 < _size942; ++_i946)
            {
              xfer += this->thrift_attr_list[_i946].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_map_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter947;
    for (_iter947 = this->thrift_attr_list.begin(); _iter947 != this->thrift_attr_list.end(); ++_iter947)
    {
      xfer += (*_iter947).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_map_pargs::~switch_sai_rpc_sai_thrift_create_tunnel_map_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_map_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter948;
    for (_iter948 = (*(this->thrift_attr_list)).begin(); _iter948 != (*(this->thrift_attr_list)).end(); ++_iter948)
    {
      xfer += (*_iter948).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_map_result::~switch_sai_rpc_sai_thrift_create_tunnel_map_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_map_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_map_presult::~switch_sai_rpc_sai_thrift_create_tunnel_map_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_map_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_map_args::~switch_sai_rpc_sai_thrift_remove_tunnel_map_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_map_id);
          this->__isset.tunnel_map_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_map_args");

  xfer += oprot->writeFieldBegin("tunnel_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_map_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_map_pargs::~switch_sai_rpc_sai_thrift_remove_tunnel_map_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_map_pargs");

  xfer += oprot->writeFieldBegin("tunnel_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_map_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_map_result::~switch_sai_rpc_sai_thrift_remove_tunnel_map_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_map_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_map_presult::~switch_sai_rpc_sai_thrift_remove_tunnel_map_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_map_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_args::~switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_map_id);
          this->__isset.tunnel_map_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_args");

  xfer += oprot->writeFieldBegin("tunnel_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_map_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_pargs::~switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_pargs");

  xfer += oprot->writeFieldBegin("tunnel_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_map_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_result::~switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_presult::~switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_args::~switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_map_id);
          this->__isset.tunnel_map_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_args");

  xfer += oprot->writeFieldBegin("tunnel_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_map_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_pargs::~switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_pargs");

  xfer += oprot->writeFieldBegin("tunnel_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_map_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_result::~switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_presult::~switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_args::~switch_sai_rpc_sai_thrift_create_tunnel_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size949;
            ::apache::thrift::protocol::TType _etype952;
            xfer += iprot->readListBegin(_etype952, _size949);
            this->thrift_attr_list.resize(_size949);
            uint32_t _i953;
            for (_i953 = 0; _i953 < _size949; ++_i953)
            {
              xfer += this->thrift_attr_list[_i953].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter954;
    for (_iter954 = this->thrift_attr_list.begin(); _iter954 != this->thrift_attr_list.end(); ++_iter954)
    {
      xfer += (*_iter954).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_pargs::~switch_sai_rpc_sai_thrift_create_tunnel_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter955;
    for (_iter955 = (*(this->thrift_attr_list)).begin(); _iter955 != (*(this->thrift_attr_list)).end(); ++_iter955)
    {
      xfer += (*_iter955).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_result::~switch_sai_rpc_sai_thrift_create_tunnel_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_presult::~switch_sai_rpc_sai_thrift_create_tunnel_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_args::~switch_sai_rpc_sai_thrift_remove_tunnel_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_id);
          this->__isset.tunnel_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_args");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_pargs::~switch_sai_rpc_sai_thrift_remove_tunnel_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_pargs");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_result::~switch_sai_rpc_sai_thrift_remove_tunnel_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_presult::~switch_sai_rpc_sai_thrift_remove_tunnel_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_attribute_args::~switch_sai_rpc_sai_thrift_get_tunnel_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_id);
          this->__isset.tunnel_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_ids.clear();
            uint32_t _size956;
            ::apache::thrift::protocol::TType _etype959;
            xfer += iprot->readListBegin(_etype959, _size956);
            this->thrift_attr_ids.resize(_size956);
            uint32_t _i960;
            for (_i960 = 0; _i960 < _size956; ++_i960)
            {
              xfer += iprot->readI32(this->thrift_attr_ids[_i960]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_attribute_args");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_ids.size()));
    std::vector<int32_t> ::const_iterator _iter961;
    for (_iter961 = this->thrift_attr_ids.begin(); _iter961 != this->thrift_attr_ids.end(); ++_iter961)
    {
      xfer += oprot->writeI32((*_iter961));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_attribute_pargs::~switch_sai_rpc_sai_thrift_get_tunnel_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_attribute_pargs");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_ids)).size()));
    std::vector<int32_t> ::const_iterator _iter962;
    for (_iter962 = (*(this->thrift_attr_ids)).begin(); _iter962 != (*(this->thrift_attr_ids)).end(); ++_iter962)
    {
      xfer += oprot->writeI32((*_iter962));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_attribute_result::~switch_sai_rpc_sai_thrift_get_tunnel_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_attribute_presult::~switch_sai_rpc_sai_thrift_get_tunnel_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_attribute_args::~switch_sai_rpc_sai_thrift_set_tunnel_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_id);
          this->__isset.tunnel_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_tunnel_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_attribute_args");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_attribute_pargs::~switch_sai_rpc_sai_thrift_set_tunnel_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_attribute_pargs");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_attribute_result::~switch_sai_rpc_sai_thrift_set_tunnel_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_tunnel_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_attribute_presult::~switch_sai_rpc_sai_thrift_set_tunnel_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_stats_args::~switch_sai_rpc_sai_thrift_get_tunnel_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_id);
          this->__isset.tunnel_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size963;
            ::apache::thrift::protocol::TType _etype966;
            xfer += iprot->readListBegin(_etype966, _size963);
            this->counter_ids.resize(_size963);
            uint32_t _i967;
            for (_i967 = 0; _i967 < _size963; ++_i967)
            {
              xfer += iprot->readI32(this->counter_ids[_i967]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_stats_args");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter968;
    for (_iter968 = this->counter_ids.begin(); _iter968 != this->counter_ids.end(); ++_iter968)
    {
      xfer += oprot->writeI32((*_iter968));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_stats_pargs::~switch_sai_rpc_sai_thrift_get_tunnel_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_stats_pargs");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter969;
    for (_iter969 = (*(this->counter_ids)).begin(); _iter969 != (*(this->counter_ids)).end(); ++_iter969)
    {
      xfer += oprot->writeI32((*_iter969));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_stats_result::~switch_sai_rpc_sai_thrift_get_tunnel_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size970;
            ::apache::thrift::protocol::TType _etype973;
            xfer += iprot->readListBegin(_etype973, _size970);
            this->success.resize(_size970);
            uint32_t _i974;
            for (_i974 = 0; _i974 < _size970; ++_i974)
            {
              xfer += iprot->readI64(this->success[_i974]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter975;
      for (_iter975 = this->success.begin(); _iter975 != this->success.end(); ++_iter975)
      {
        xfer += oprot->writeI64((*_iter975));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_stats_presult::~switch_sai_rpc_sai_thrift_get_tunnel_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size976;
            ::apache::thrift::protocol::TType _etype979;
            xfer += iprot->readListBegin(_etype979, _size976);
            (*(this->success)).resize(_size976);
            uint32_t _i980;
            for (_i980 = 0; _i980 < _size976; ++_i980)
            {
              xfer += iprot->readI64((*(this->success))[_i980]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_tunnel_stats_args::~switch_sai_rpc_sai_thrift_clear_tunnel_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_tunnel_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_id);
          this->__isset.tunnel_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size981;
            ::apache::thrift::protocol::TType _etype984;
            xfer += iprot->readListBegin(_etype984, _size981);
            this->counter_ids.resize(_size981);
            uint32_t _i985;
            for (_i985 = 0; _i985 < _size981; ++_i985)
            {
              xfer += iprot->readI32(this->counter_ids[_i985]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_tunnel_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_tunnel_stats_args");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter986;
    for (_iter986 = this->counter_ids.begin(); _iter986 != this->counter_ids.end(); ++_iter986)
    {
      xfer += oprot->writeI32((*_iter986));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_tunnel_stats_pargs::~switch_sai_rpc_sai_thrift_clear_tunnel_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_tunnel_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_tunnel_stats_pargs");

  xfer += oprot->writeFieldBegin("tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter987;
    for (_iter987 = (*(this->counter_ids)).begin(); _iter987 != (*(this->counter_ids)).end(); ++_iter987)
    {
      xfer += oprot->writeI32((*_iter987));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_tunnel_stats_result::~switch_sai_rpc_sai_thrift_clear_tunnel_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_tunnel_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_tunnel_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_tunnel_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_tunnel_stats_presult::~switch_sai_rpc_sai_thrift_clear_tunnel_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_tunnel_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args::~switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size988;
            ::apache::thrift::protocol::TType _etype991;
            xfer += iprot->readListBegin(_etype991, _size988);
            this->thrift_attr_list.resize(_size988);
            uint32_t _i992;
            for (_i992 = 0; _i992 < _size988; ++_i992)
            {
              xfer += this->thrift_attr_list[_i992].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter993;
    for (_iter993 = this->thrift_attr_list.begin(); _iter993 != this->thrift_attr_list.end(); ++_iter993)
    {
      xfer += (*_iter993).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs::~switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter994;
    for (_iter994 = (*(this->thrift_attr_list)).begin(); _iter994 != (*(this->thrift_attr_list)).end(); ++_iter994)
    {
      xfer += (*_iter994).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result::~switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult::~switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args::~switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_term_table_entry_id);
          this->__isset.tunnel_term_table_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args");

  xfer += oprot->writeFieldBegin("tunnel_term_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_term_table_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs::~switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs");

  xfer += oprot->writeFieldBegin("tunnel_term_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_term_table_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result::~switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult::~switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_args::~switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_term_table_entry_id);
          this->__isset.tunnel_term_table_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_ids.clear();
            uint32_t _size995;
            ::apache::thrift::protocol::TType _etype998;
            xfer += iprot->readListBegin(_etype998, _size995);
            this->thrift_attr_ids.resize(_size995);
            uint32_t _i999;
            for (_i999 = 0; _i999 < _size995; ++_i999)
            {
              xfer += iprot->readI32(this->thrift_attr_ids[_i999]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_args");

  xfer += oprot->writeFieldBegin("tunnel_term_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_term_table_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_ids.size()));
    std::vector<int32_t> ::const_iterator _iter1000;
    for (_iter1000 = this->thrift_attr_ids.begin(); _iter1000 != this->thrift_attr_ids.end(); ++_iter1000)
    {
      xfer += oprot->writeI32((*_iter1000));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("tunnel_term_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_term_table_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_ids)).size()));
    std::vector<int32_t> ::const_iterator _iter1001;
    for (_iter1001 = (*(this->thrift_attr_ids)).begin(); _iter1001 != (*(this->thrift_attr_ids)).end(); ++_iter1001)
    {
      xfer += oprot->writeI32((*_iter1001));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_result::~switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_presult::~switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tunnel_term_table_entry_id);
          this->__isset.tunnel_term_table_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_args");

  xfer += oprot->writeFieldBegin("tunnel_term_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tunnel_term_table_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("tunnel_term_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->tunnel_term_table_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_args::~switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->switch_id);
          this->__isset.switch_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_args");

  xfer += oprot->writeFieldBegin("switch_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->switch_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_pargs::~switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_pargs");

  xfer += oprot->writeFieldBegin("switch_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->switch_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_result::~switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_presult::~switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_packet_count_args::~switch_sai_rpc_sai_thrift_get_cpu_packet_count_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_count_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_count_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_packet_count_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_packet_count_pargs::~switch_sai_rpc_sai_thrift_get_cpu_packet_count_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_count_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_packet_count_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_packet_count_result::~switch_sai_rpc_sai_thrift_get_cpu_packet_count_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_count_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_count_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_packet_count_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_packet_count_presult::~switch_sai_rpc_sai_thrift_get_cpu_packet_count_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_packet_count_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_cpu_packet_info_args::~switch_sai_rpc_sai_thrift_clear_cpu_packet_info_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_cpu_packet_info_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_cpu_packet_info_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_cpu_packet_info_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_cpu_packet_info_pargs::~switch_sai_rpc_sai_thrift_clear_cpu_packet_info_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_cpu_packet_info_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_cpu_packet_info_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_cpu_packet_info_result::~switch_sai_rpc_sai_thrift_clear_cpu_packet_info_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_cpu_packet_info_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_cpu_packet_info_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_cpu_packet_info_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_cpu_packet_info_presult::~switch_sai_rpc_sai_thrift_clear_cpu_packet_info_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_cpu_packet_info_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_log_set_args::~switch_sai_rpc_sai_thrift_log_set_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_log_set_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sai_api_id);
          this->__isset.sai_api_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->log_level);
          this->__isset.log_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_log_set_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_log_set_args");

  xfer += oprot->writeFieldBegin("sai_api_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->sai_api_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("log_level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->log_level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_log_set_pargs::~switch_sai_rpc_sai_thrift_log_set_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_log_set_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_log_set_pargs");

  xfer += oprot->writeFieldBegin("sai_api_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->sai_api_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("log_level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->log_level)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_log_set_result::~switch_sai_rpc_sai_thrift_log_set_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_log_set_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_log_set_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_log_set_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_log_set_presult::~switch_sai_rpc_sai_thrift_log_set_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_log_set_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_isolation_group_args::~switch_sai_rpc_sai_thrift_create_isolation_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1002;
            ::apache::thrift::protocol::TType _etype1005;
            xfer += iprot->readListBegin(_etype1005, _size1002);
            this->thrift_attr_list.resize(_size1002);
            uint32_t _i1006;
            for (_i1006 = 0; _i1006 < _size1002; ++_i1006)
            {
              xfer += this->thrift_attr_list[_i1006].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_isolation_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1007;
    for (_iter1007 = this->thrift_attr_list.begin(); _iter1007 != this->thrift_attr_list.end(); ++_iter1007)
    {
      xfer += (*_iter1007).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_isolation_group_pargs::~switch_sai_rpc_sai_thrift_create_isolation_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_isolation_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1008;
    for (_iter1008 = (*(this->thrift_attr_list)).begin(); _iter1008 != (*(this->thrift_attr_list)).end(); ++_iter1008)
    {
      xfer += (*_iter1008).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_isolation_group_result::~switch_sai_rpc_sai_thrift_create_isolation_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_isolation_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_isolation_group_presult::~switch_sai_rpc_sai_thrift_create_isolation_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_isolation_group_args::~switch_sai_rpc_sai_thrift_remove_isolation_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iso_group_oid);
          this->__isset.iso_group_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_isolation_group_args");

  xfer += oprot->writeFieldBegin("iso_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->iso_group_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_isolation_group_pargs::~switch_sai_rpc_sai_thrift_remove_isolation_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_isolation_group_pargs");

  xfer += oprot->writeFieldBegin("iso_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->iso_group_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_isolation_group_result::~switch_sai_rpc_sai_thrift_remove_isolation_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_isolation_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_isolation_group_presult::~switch_sai_rpc_sai_thrift_remove_isolation_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_isolation_group_member_args::~switch_sai_rpc_sai_thrift_create_isolation_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1009;
            ::apache::thrift::protocol::TType _etype1012;
            xfer += iprot->readListBegin(_etype1012, _size1009);
            this->thrift_attr_list.resize(_size1009);
            uint32_t _i1013;
            for (_i1013 = 0; _i1013 < _size1009; ++_i1013)
            {
              xfer += this->thrift_attr_list[_i1013].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_isolation_group_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1014;
    for (_iter1014 = this->thrift_attr_list.begin(); _iter1014 != this->thrift_attr_list.end(); ++_iter1014)
    {
      xfer += (*_iter1014).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_isolation_group_member_pargs::~switch_sai_rpc_sai_thrift_create_isolation_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_isolation_group_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1015;
    for (_iter1015 = (*(this->thrift_attr_list)).begin(); _iter1015 != (*(this->thrift_attr_list)).end(); ++_iter1015)
    {
      xfer += (*_iter1015).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_isolation_group_member_result::~switch_sai_rpc_sai_thrift_create_isolation_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_isolation_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_isolation_group_member_presult::~switch_sai_rpc_sai_thrift_create_isolation_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_isolation_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_isolation_group_member_args::~switch_sai_rpc_sai_thrift_remove_isolation_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_oid);
          this->__isset.member_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_isolation_group_member_args");

  xfer += oprot->writeFieldBegin("member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_isolation_group_member_pargs::~switch_sai_rpc_sai_thrift_remove_isolation_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_isolation_group_member_pargs");

  xfer += oprot->writeFieldBegin("member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_isolation_group_member_result::~switch_sai_rpc_sai_thrift_remove_isolation_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_isolation_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_isolation_group_member_presult::~switch_sai_rpc_sai_thrift_remove_isolation_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_isolation_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_isolation_group_attributes_args::~switch_sai_rpc_sai_thrift_get_isolation_group_attributes_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_attributes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iso_group_oid);
          this->__isset.iso_group_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_attributes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_isolation_group_attributes_args");

  xfer += oprot->writeFieldBegin("iso_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->iso_group_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_isolation_group_attributes_pargs::~switch_sai_rpc_sai_thrift_get_isolation_group_attributes_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_attributes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_isolation_group_attributes_pargs");

  xfer += oprot->writeFieldBegin("iso_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->iso_group_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_isolation_group_attributes_result::~switch_sai_rpc_sai_thrift_get_isolation_group_attributes_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_attributes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_attributes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_isolation_group_attributes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_isolation_group_attributes_presult::~switch_sai_rpc_sai_thrift_get_isolation_group_attributes_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_attributes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_args::~switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->member_oid);
          this->__isset.member_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_args");

  xfer += oprot->writeFieldBegin("member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->member_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_pargs::~switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_pargs");

  xfer += oprot->writeFieldBegin("member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->member_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_result::~switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_presult::~switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_counter_args::~switch_sai_rpc_sai_thrift_create_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1016;
            ::apache::thrift::protocol::TType _etype1019;
            xfer += iprot->readListBegin(_etype1019, _size1016);
            this->thrift_attr_list.resize(_size1016);
            uint32_t _i1020;
            for (_i1020 = 0; _i1020 < _size1016; ++_i1020)
            {
              xfer += this->thrift_attr_list[_i1020].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_counter_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1021;
    for (_iter1021 = this->thrift_attr_list.begin(); _iter1021 != this->thrift_attr_list.end(); ++_iter1021)
    {
      xfer += (*_iter1021).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_counter_pargs::~switch_sai_rpc_sai_thrift_create_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_counter_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1022;
    for (_iter1022 = (*(this->thrift_attr_list)).begin(); _iter1022 != (*(this->thrift_attr_list)).end(); ++_iter1022)
    {
      xfer += (*_iter1022).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_counter_result::~switch_sai_rpc_sai_thrift_create_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_counter_presult::~switch_sai_rpc_sai_thrift_create_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_counter_args::~switch_sai_rpc_sai_thrift_remove_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->counter_oid);
          this->__isset.counter_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_counter_args");

  xfer += oprot->writeFieldBegin("counter_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->counter_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_counter_pargs::~switch_sai_rpc_sai_thrift_remove_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_counter_pargs");

  xfer += oprot->writeFieldBegin("counter_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->counter_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_counter_result::~switch_sai_rpc_sai_thrift_remove_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_counter_presult::~switch_sai_rpc_sai_thrift_remove_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_counter_attribute_args::~switch_sai_rpc_sai_thrift_set_counter_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_counter_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_counter_id);
          this->__isset.thrift_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_counter_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_counter_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_counter_attribute_pargs::~switch_sai_rpc_sai_thrift_set_counter_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_counter_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_counter_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_counter_attribute_result::~switch_sai_rpc_sai_thrift_set_counter_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_counter_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_counter_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_counter_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_counter_attribute_presult::~switch_sai_rpc_sai_thrift_set_counter_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_counter_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_attribute_args::~switch_sai_rpc_sai_thrift_get_counter_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_counter_id);
          this->__isset.thrift_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_counter_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_attribute_pargs::~switch_sai_rpc_sai_thrift_get_counter_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_attribute_result::~switch_sai_rpc_sai_thrift_get_counter_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_counter_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_attribute_presult::~switch_sai_rpc_sai_thrift_get_counter_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_stats_args::~switch_sai_rpc_sai_thrift_get_counter_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->counter_id);
          this->__isset.counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size1023;
            ::apache::thrift::protocol::TType _etype1026;
            xfer += iprot->readListBegin(_etype1026, _size1023);
            this->counter_ids.resize(_size1023);
            uint32_t _i1027;
            for (_i1027 = 0; _i1027 < _size1023; ++_i1027)
            {
              xfer += iprot->readI32(this->counter_ids[_i1027]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_stats_args");

  xfer += oprot->writeFieldBegin("counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_stat_id_t> ::const_iterator _iter1028;
    for (_iter1028 = this->counter_ids.begin(); _iter1028 != this->counter_ids.end(); ++_iter1028)
    {
      xfer += oprot->writeI32((*_iter1028));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_stats_pargs::~switch_sai_rpc_sai_thrift_get_counter_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_stats_pargs");

  xfer += oprot->writeFieldBegin("counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_stat_id_t> ::const_iterator _iter1029;
    for (_iter1029 = (*(this->counter_ids)).begin(); _iter1029 != (*(this->counter_ids)).end(); ++_iter1029)
    {
      xfer += oprot->writeI32((*_iter1029));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_stats_result::~switch_sai_rpc_sai_thrift_get_counter_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1030;
            ::apache::thrift::protocol::TType _etype1033;
            xfer += iprot->readListBegin(_etype1033, _size1030);
            this->success.resize(_size1030);
            uint32_t _i1034;
            for (_i1034 = 0; _i1034 < _size1030; ++_i1034)
            {
              xfer += iprot->readI64(this->success[_i1034]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter1035;
      for (_iter1035 = this->success.begin(); _iter1035 != this->success.end(); ++_iter1035)
      {
        xfer += oprot->writeI64((*_iter1035));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_stats_presult::~switch_sai_rpc_sai_thrift_get_counter_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1036;
            ::apache::thrift::protocol::TType _etype1039;
            xfer += iprot->readListBegin(_etype1039, _size1036);
            (*(this->success)).resize(_size1036);
            uint32_t _i1040;
            for (_i1040 = 0; _i1040 < _size1036; ++_i1040)
            {
              xfer += iprot->readI64((*(this->success))[_i1040]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_stats_ext_args::~switch_sai_rpc_sai_thrift_get_counter_stats_ext_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_ext_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->counter_id);
          this->__isset.counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size1041;
            ::apache::thrift::protocol::TType _etype1044;
            xfer += iprot->readListBegin(_etype1044, _size1041);
            this->counter_ids.resize(_size1041);
            uint32_t _i1045;
            for (_i1045 = 0; _i1045 < _size1041; ++_i1045)
            {
              xfer += iprot->readI32(this->counter_ids[_i1045]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_ext_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_stats_ext_args");

  xfer += oprot->writeFieldBegin("counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_stat_id_t> ::const_iterator _iter1046;
    for (_iter1046 = this->counter_ids.begin(); _iter1046 != this->counter_ids.end(); ++_iter1046)
    {
      xfer += oprot->writeI32((*_iter1046));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_stats_ext_pargs::~switch_sai_rpc_sai_thrift_get_counter_stats_ext_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_ext_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_stats_ext_pargs");

  xfer += oprot->writeFieldBegin("counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_stat_id_t> ::const_iterator _iter1047;
    for (_iter1047 = (*(this->counter_ids)).begin(); _iter1047 != (*(this->counter_ids)).end(); ++_iter1047)
    {
      xfer += oprot->writeI32((*_iter1047));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->mode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_stats_ext_result::~switch_sai_rpc_sai_thrift_get_counter_stats_ext_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_ext_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1048;
            ::apache::thrift::protocol::TType _etype1051;
            xfer += iprot->readListBegin(_etype1051, _size1048);
            this->success.resize(_size1048);
            uint32_t _i1052;
            for (_i1052 = 0; _i1052 < _size1048; ++_i1052)
            {
              xfer += iprot->readI64(this->success[_i1052]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_ext_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_counter_stats_ext_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter1053;
      for (_iter1053 = this->success.begin(); _iter1053 != this->success.end(); ++_iter1053)
      {
        xfer += oprot->writeI64((*_iter1053));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_counter_stats_ext_presult::~switch_sai_rpc_sai_thrift_get_counter_stats_ext_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_counter_stats_ext_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1054;
            ::apache::thrift::protocol::TType _etype1057;
            xfer += iprot->readListBegin(_etype1057, _size1054);
            (*(this->success)).resize(_size1054);
            uint32_t _i1058;
            for (_i1058 = 0; _i1058 < _size1054; ++_i1058)
            {
              xfer += iprot->readI64((*(this->success))[_i1058]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_counter_stats_args::~switch_sai_rpc_sai_thrift_clear_counter_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_counter_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->counter_id);
          this->__isset.counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size1059;
            ::apache::thrift::protocol::TType _etype1062;
            xfer += iprot->readListBegin(_etype1062, _size1059);
            this->thrift_counter_ids.resize(_size1059);
            uint32_t _i1063;
            for (_i1063 = 0; _i1063 < _size1059; ++_i1063)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i1063]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_counter_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_counter_stats_args");

  xfer += oprot->writeFieldBegin("counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_stat_id_t> ::const_iterator _iter1064;
    for (_iter1064 = this->thrift_counter_ids.begin(); _iter1064 != this->thrift_counter_ids.end(); ++_iter1064)
    {
      xfer += oprot->writeI32((*_iter1064));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_counter_stats_pargs::~switch_sai_rpc_sai_thrift_clear_counter_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_counter_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_counter_stats_pargs");

  xfer += oprot->writeFieldBegin("counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_stat_id_t> ::const_iterator _iter1065;
    for (_iter1065 = (*(this->thrift_counter_ids)).begin(); _iter1065 != (*(this->thrift_counter_ids)).end(); ++_iter1065)
    {
      xfer += oprot->writeI32((*_iter1065));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_counter_stats_result::~switch_sai_rpc_sai_thrift_clear_counter_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_counter_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_counter_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_counter_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_counter_stats_presult::~switch_sai_rpc_sai_thrift_clear_counter_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_counter_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_debug_counter_args::~switch_sai_rpc_sai_thrift_create_debug_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1066;
            ::apache::thrift::protocol::TType _etype1069;
            xfer += iprot->readListBegin(_etype1069, _size1066);
            this->thrift_attr_list.resize(_size1066);
            uint32_t _i1070;
            for (_i1070 = 0; _i1070 < _size1066; ++_i1070)
            {
              xfer += this->thrift_attr_list[_i1070].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_debug_counter_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1071;
    for (_iter1071 = this->thrift_attr_list.begin(); _iter1071 != this->thrift_attr_list.end(); ++_iter1071)
    {
      xfer += (*_iter1071).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_debug_counter_pargs::~switch_sai_rpc_sai_thrift_create_debug_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_debug_counter_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1072;
    for (_iter1072 = (*(this->thrift_attr_list)).begin(); _iter1072 != (*(this->thrift_attr_list)).end(); ++_iter1072)
    {
      xfer += (*_iter1072).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_debug_counter_result::~switch_sai_rpc_sai_thrift_create_debug_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_debug_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_debug_counter_presult::~switch_sai_rpc_sai_thrift_create_debug_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_debug_counter_args::~switch_sai_rpc_sai_thrift_remove_debug_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->debug_counter_oid);
          this->__isset.debug_counter_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_debug_counter_args");

  xfer += oprot->writeFieldBegin("debug_counter_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->debug_counter_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_debug_counter_pargs::~switch_sai_rpc_sai_thrift_remove_debug_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_debug_counter_pargs");

  xfer += oprot->writeFieldBegin("debug_counter_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->debug_counter_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_debug_counter_result::~switch_sai_rpc_sai_thrift_remove_debug_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_debug_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_debug_counter_presult::~switch_sai_rpc_sai_thrift_remove_debug_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args::~switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_debug_counter_id);
          this->__isset.thrift_debug_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_debug_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_debug_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs::~switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_debug_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_debug_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result::~switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult::~switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_debug_counter_attribute_args::~switch_sai_rpc_sai_thrift_get_debug_counter_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_debug_counter_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_debug_counter_id);
          this->__isset.thrift_debug_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_debug_counter_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_debug_counter_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_debug_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_debug_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_debug_counter_attribute_pargs::~switch_sai_rpc_sai_thrift_get_debug_counter_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_debug_counter_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_debug_counter_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_debug_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_debug_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_debug_counter_attribute_result::~switch_sai_rpc_sai_thrift_get_debug_counter_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_debug_counter_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_debug_counter_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_debug_counter_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_debug_counter_attribute_presult::~switch_sai_rpc_sai_thrift_get_debug_counter_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_debug_counter_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_nat_args::~switch_sai_rpc_sai_thrift_create_nat_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_nat_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_nat_entry.read(iprot);
          this->__isset.thrift_nat_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1073;
            ::apache::thrift::protocol::TType _etype1076;
            xfer += iprot->readListBegin(_etype1076, _size1073);
            this->thrift_attr_list.resize(_size1073);
            uint32_t _i1077;
            for (_i1077 = 0; _i1077 < _size1073; ++_i1077)
            {
              xfer += this->thrift_attr_list[_i1077].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_nat_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_nat_args");

  xfer += oprot->writeFieldBegin("thrift_nat_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_nat_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1078;
    for (_iter1078 = this->thrift_attr_list.begin(); _iter1078 != this->thrift_attr_list.end(); ++_iter1078)
    {
      xfer += (*_iter1078).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_nat_pargs::~switch_sai_rpc_sai_thrift_create_nat_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_nat_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_nat_pargs");

  xfer += oprot->writeFieldBegin("thrift_nat_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_nat_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1079;
    for (_iter1079 = (*(this->thrift_attr_list)).begin(); _iter1079 != (*(this->thrift_attr_list)).end(); ++_iter1079)
    {
      xfer += (*_iter1079).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_nat_result::~switch_sai_rpc_sai_thrift_create_nat_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_nat_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_nat_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_nat_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_nat_presult::~switch_sai_rpc_sai_thrift_create_nat_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_nat_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_nat_args::~switch_sai_rpc_sai_thrift_remove_nat_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_nat_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_nat_entry.read(iprot);
          this->__isset.thrift_nat_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_nat_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_nat_args");

  xfer += oprot->writeFieldBegin("thrift_nat_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_nat_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_nat_pargs::~switch_sai_rpc_sai_thrift_remove_nat_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_nat_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_nat_pargs");

  xfer += oprot->writeFieldBegin("thrift_nat_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_nat_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_nat_result::~switch_sai_rpc_sai_thrift_remove_nat_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_nat_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_nat_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_nat_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_nat_presult::~switch_sai_rpc_sai_thrift_remove_nat_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_nat_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_nat_attribute_args::~switch_sai_rpc_sai_thrift_set_nat_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_nat_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_nat_entry.read(iprot);
          this->__isset.thrift_nat_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_nat_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_nat_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_nat_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_nat_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_nat_attribute_pargs::~switch_sai_rpc_sai_thrift_set_nat_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_nat_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_nat_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_nat_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_nat_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_nat_attribute_result::~switch_sai_rpc_sai_thrift_set_nat_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_nat_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_nat_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_nat_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_nat_attribute_presult::~switch_sai_rpc_sai_thrift_set_nat_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_nat_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_nat_attribute_args::~switch_sai_rpc_sai_thrift_get_nat_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_nat_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_nat_entry.read(iprot);
          this->__isset.thrift_nat_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_nat_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_nat_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_nat_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_nat_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_nat_attribute_pargs::~switch_sai_rpc_sai_thrift_get_nat_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_nat_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_nat_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_nat_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_nat_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_nat_attribute_result::~switch_sai_rpc_sai_thrift_get_nat_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_nat_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_nat_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_nat_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_nat_attribute_presult::~switch_sai_rpc_sai_thrift_get_nat_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_nat_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_bfd_args::~switch_sai_rpc_sai_thrift_create_bfd_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bfd_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1080;
            ::apache::thrift::protocol::TType _etype1083;
            xfer += iprot->readListBegin(_etype1083, _size1080);
            this->thrift_attr_list.resize(_size1080);
            uint32_t _i1084;
            for (_i1084 = 0; _i1084 < _size1080; ++_i1084)
            {
              xfer += this->thrift_attr_list[_i1084].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bfd_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bfd_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1085;
    for (_iter1085 = this->thrift_attr_list.begin(); _iter1085 != this->thrift_attr_list.end(); ++_iter1085)
    {
      xfer += (*_iter1085).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bfd_pargs::~switch_sai_rpc_sai_thrift_create_bfd_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bfd_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bfd_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1086;
    for (_iter1086 = (*(this->thrift_attr_list)).begin(); _iter1086 != (*(this->thrift_attr_list)).end(); ++_iter1086)
    {
      xfer += (*_iter1086).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bfd_result::~switch_sai_rpc_sai_thrift_create_bfd_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bfd_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bfd_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bfd_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bfd_presult::~switch_sai_rpc_sai_thrift_create_bfd_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bfd_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bfd_args::~switch_sai_rpc_sai_thrift_remove_bfd_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bfd_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bfd_oid);
          this->__isset.bfd_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bfd_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bfd_args");

  xfer += oprot->writeFieldBegin("bfd_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bfd_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bfd_pargs::~switch_sai_rpc_sai_thrift_remove_bfd_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bfd_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bfd_pargs");

  xfer += oprot->writeFieldBegin("bfd_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bfd_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bfd_result::~switch_sai_rpc_sai_thrift_remove_bfd_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bfd_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bfd_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bfd_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bfd_presult::~switch_sai_rpc_sai_thrift_remove_bfd_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bfd_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_bfd_attribute_args::~switch_sai_rpc_sai_thrift_set_bfd_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bfd_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bfd_oid);
          this->__isset.bfd_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_bfd_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bfd_attribute_args");

  xfer += oprot->writeFieldBegin("bfd_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bfd_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bfd_attribute_pargs::~switch_sai_rpc_sai_thrift_set_bfd_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bfd_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bfd_attribute_pargs");

  xfer += oprot->writeFieldBegin("bfd_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bfd_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bfd_attribute_result::~switch_sai_rpc_sai_thrift_set_bfd_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bfd_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_bfd_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bfd_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bfd_attribute_presult::~switch_sai_rpc_sai_thrift_set_bfd_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bfd_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_bfd_attribute_args::~switch_sai_rpc_sai_thrift_get_bfd_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bfd_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bfd_oid);
          this->__isset.bfd_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bfd_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bfd_attribute_args");

  xfer += oprot->writeFieldBegin("bfd_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bfd_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bfd_attribute_pargs::~switch_sai_rpc_sai_thrift_get_bfd_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bfd_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bfd_attribute_pargs");

  xfer += oprot->writeFieldBegin("bfd_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bfd_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bfd_attribute_result::~switch_sai_rpc_sai_thrift_get_bfd_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bfd_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bfd_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bfd_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bfd_attribute_presult::~switch_sai_rpc_sai_thrift_get_bfd_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bfd_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_meg_args::~switch_sai_rpc_sai_thrift_create_y1731_meg_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_meg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1087;
            ::apache::thrift::protocol::TType _etype1090;
            xfer += iprot->readListBegin(_etype1090, _size1087);
            this->thrift_attr_list.resize(_size1087);
            uint32_t _i1091;
            for (_i1091 = 0; _i1091 < _size1087; ++_i1091)
            {
              xfer += this->thrift_attr_list[_i1091].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_y1731_meg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_meg_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1092;
    for (_iter1092 = this->thrift_attr_list.begin(); _iter1092 != this->thrift_attr_list.end(); ++_iter1092)
    {
      xfer += (*_iter1092).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_meg_pargs::~switch_sai_rpc_sai_thrift_create_y1731_meg_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_meg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_meg_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1093;
    for (_iter1093 = (*(this->thrift_attr_list)).begin(); _iter1093 != (*(this->thrift_attr_list)).end(); ++_iter1093)
    {
      xfer += (*_iter1093).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_meg_result::~switch_sai_rpc_sai_thrift_create_y1731_meg_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_meg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_y1731_meg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_meg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_meg_presult::~switch_sai_rpc_sai_thrift_create_y1731_meg_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_meg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_meg_args::~switch_sai_rpc_sai_thrift_remove_y1731_meg_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_meg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_meg_oid);
          this->__isset.y1731_meg_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_y1731_meg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_meg_args");

  xfer += oprot->writeFieldBegin("y1731_meg_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_meg_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_meg_pargs::~switch_sai_rpc_sai_thrift_remove_y1731_meg_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_meg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_meg_pargs");

  xfer += oprot->writeFieldBegin("y1731_meg_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_meg_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_meg_result::~switch_sai_rpc_sai_thrift_remove_y1731_meg_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_meg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_y1731_meg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_meg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_meg_presult::~switch_sai_rpc_sai_thrift_remove_y1731_meg_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_meg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_args::~switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_meg_oid);
          this->__isset.y1731_meg_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_args");

  xfer += oprot->writeFieldBegin("y1731_meg_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_meg_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_pargs::~switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_pargs");

  xfer += oprot->writeFieldBegin("y1731_meg_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_meg_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_result::~switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_presult::~switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_args::~switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_meg_oid);
          this->__isset.y1731_meg_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_args");

  xfer += oprot->writeFieldBegin("y1731_meg_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_meg_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_pargs::~switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_pargs");

  xfer += oprot->writeFieldBegin("y1731_meg_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_meg_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_result::~switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_presult::~switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_session_args::~switch_sai_rpc_sai_thrift_create_y1731_session_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_session_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1094;
            ::apache::thrift::protocol::TType _etype1097;
            xfer += iprot->readListBegin(_etype1097, _size1094);
            this->thrift_attr_list.resize(_size1094);
            uint32_t _i1098;
            for (_i1098 = 0; _i1098 < _size1094; ++_i1098)
            {
              xfer += this->thrift_attr_list[_i1098].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_y1731_session_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_session_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1099;
    for (_iter1099 = this->thrift_attr_list.begin(); _iter1099 != this->thrift_attr_list.end(); ++_iter1099)
    {
      xfer += (*_iter1099).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_session_pargs::~switch_sai_rpc_sai_thrift_create_y1731_session_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_session_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_session_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1100;
    for (_iter1100 = (*(this->thrift_attr_list)).begin(); _iter1100 != (*(this->thrift_attr_list)).end(); ++_iter1100)
    {
      xfer += (*_iter1100).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_session_result::~switch_sai_rpc_sai_thrift_create_y1731_session_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_session_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_y1731_session_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_session_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_session_presult::~switch_sai_rpc_sai_thrift_create_y1731_session_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_session_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_session_args::~switch_sai_rpc_sai_thrift_remove_y1731_session_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_session_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_session_oid);
          this->__isset.y1731_session_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_y1731_session_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_session_args");

  xfer += oprot->writeFieldBegin("y1731_session_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_session_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_session_pargs::~switch_sai_rpc_sai_thrift_remove_y1731_session_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_session_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_session_pargs");

  xfer += oprot->writeFieldBegin("y1731_session_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_session_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_session_result::~switch_sai_rpc_sai_thrift_remove_y1731_session_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_session_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_y1731_session_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_session_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_session_presult::~switch_sai_rpc_sai_thrift_remove_y1731_session_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_session_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_session_attribute_args::~switch_sai_rpc_sai_thrift_set_y1731_session_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_session_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_session_oid);
          this->__isset.y1731_session_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_y1731_session_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_session_attribute_args");

  xfer += oprot->writeFieldBegin("y1731_session_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_session_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_session_attribute_pargs::~switch_sai_rpc_sai_thrift_set_y1731_session_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_session_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_session_attribute_pargs");

  xfer += oprot->writeFieldBegin("y1731_session_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_session_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_session_attribute_result::~switch_sai_rpc_sai_thrift_set_y1731_session_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_session_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_y1731_session_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_session_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_session_attribute_presult::~switch_sai_rpc_sai_thrift_set_y1731_session_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_session_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_session_attribute_args::~switch_sai_rpc_sai_thrift_get_y1731_session_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_session_oid);
          this->__isset.y1731_session_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_session_attribute_args");

  xfer += oprot->writeFieldBegin("y1731_session_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_session_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_session_attribute_pargs::~switch_sai_rpc_sai_thrift_get_y1731_session_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_session_attribute_pargs");

  xfer += oprot->writeFieldBegin("y1731_session_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_session_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_session_attribute_result::~switch_sai_rpc_sai_thrift_get_y1731_session_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_session_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_session_attribute_presult::~switch_sai_rpc_sai_thrift_get_y1731_session_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_rmep_args::~switch_sai_rpc_sai_thrift_create_y1731_rmep_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_rmep_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1101;
            ::apache::thrift::protocol::TType _etype1104;
            xfer += iprot->readListBegin(_etype1104, _size1101);
            this->thrift_attr_list.resize(_size1101);
            uint32_t _i1105;
            for (_i1105 = 0; _i1105 < _size1101; ++_i1105)
            {
              xfer += this->thrift_attr_list[_i1105].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_y1731_rmep_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_rmep_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1106;
    for (_iter1106 = this->thrift_attr_list.begin(); _iter1106 != this->thrift_attr_list.end(); ++_iter1106)
    {
      xfer += (*_iter1106).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_rmep_pargs::~switch_sai_rpc_sai_thrift_create_y1731_rmep_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_rmep_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_rmep_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1107;
    for (_iter1107 = (*(this->thrift_attr_list)).begin(); _iter1107 != (*(this->thrift_attr_list)).end(); ++_iter1107)
    {
      xfer += (*_iter1107).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_rmep_result::~switch_sai_rpc_sai_thrift_create_y1731_rmep_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_rmep_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_y1731_rmep_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_y1731_rmep_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_y1731_rmep_presult::~switch_sai_rpc_sai_thrift_create_y1731_rmep_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_y1731_rmep_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_rmep_args::~switch_sai_rpc_sai_thrift_remove_y1731_rmep_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_rmep_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_rmep_oid);
          this->__isset.y1731_rmep_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_y1731_rmep_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_rmep_args");

  xfer += oprot->writeFieldBegin("y1731_rmep_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_rmep_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_rmep_pargs::~switch_sai_rpc_sai_thrift_remove_y1731_rmep_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_rmep_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_rmep_pargs");

  xfer += oprot->writeFieldBegin("y1731_rmep_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_rmep_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_rmep_result::~switch_sai_rpc_sai_thrift_remove_y1731_rmep_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_rmep_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_y1731_rmep_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_y1731_rmep_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_y1731_rmep_presult::~switch_sai_rpc_sai_thrift_remove_y1731_rmep_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_y1731_rmep_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_args::~switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_rmep_oid);
          this->__isset.y1731_rmep_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_args");

  xfer += oprot->writeFieldBegin("y1731_rmep_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_rmep_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_pargs::~switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_pargs");

  xfer += oprot->writeFieldBegin("y1731_rmep_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_rmep_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_result::~switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_presult::~switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_args::~switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_rmep_oid);
          this->__isset.y1731_rmep_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_args");

  xfer += oprot->writeFieldBegin("y1731_rmep_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_rmep_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_pargs::~switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_pargs");

  xfer += oprot->writeFieldBegin("y1731_rmep_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_rmep_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_result::~switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_presult::~switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_args::~switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y1731_session_oid);
          this->__isset.y1731_session_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lm_stats_ids.clear();
            uint32_t _size1108;
            ::apache::thrift::protocol::TType _etype1111;
            xfer += iprot->readListBegin(_etype1111, _size1108);
            this->lm_stats_ids.resize(_size1108);
            uint32_t _i1112;
            for (_i1112 = 0; _i1112 < _size1108; ++_i1112)
            {
              xfer += iprot->readI32(this->lm_stats_ids[_i1112]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lm_stats_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_stats);
          this->__isset.number_of_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_args");

  xfer += oprot->writeFieldBegin("y1731_session_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->y1731_session_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lm_stats_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->lm_stats_ids.size()));
    std::vector<sai_thrift_stat_id_t> ::const_iterator _iter1113;
    for (_iter1113 = this->lm_stats_ids.begin(); _iter1113 != this->lm_stats_ids.end(); ++_iter1113)
    {
      xfer += oprot->writeI32((*_iter1113));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_stats", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_stats);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_pargs::~switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_pargs");

  xfer += oprot->writeFieldBegin("y1731_session_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->y1731_session_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lm_stats_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->lm_stats_ids)).size()));
    std::vector<sai_thrift_stat_id_t> ::const_iterator _iter1114;
    for (_iter1114 = (*(this->lm_stats_ids)).begin(); _iter1114 != (*(this->lm_stats_ids)).end(); ++_iter1114)
    {
      xfer += oprot->writeI32((*_iter1114));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_stats", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_stats)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_result::~switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1115;
            ::apache::thrift::protocol::TType _etype1118;
            xfer += iprot->readListBegin(_etype1118, _size1115);
            this->success.resize(_size1115);
            uint32_t _i1119;
            for (_i1119 = 0; _i1119 < _size1115; ++_i1119)
            {
              xfer += iprot->readI64(this->success[_i1119]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter1120;
      for (_iter1120 = this->success.begin(); _iter1120 != this->success.end(); ++_iter1120)
      {
        xfer += oprot->writeI64((*_iter1120));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_presult::~switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1121;
            ::apache::thrift::protocol::TType _etype1124;
            xfer += iprot->readListBegin(_etype1124, _size1121);
            (*(this->success)).resize(_size1121);
            uint32_t _i1125;
            for (_i1125 = 0; _i1125 < _size1121; ++_i1125)
            {
              xfer += iprot->readI64((*(this->success))[_i1125]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_port_args::~switch_sai_rpc_sai_thrift_create_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port_name);
          this->__isset.port_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1126;
            ::apache::thrift::protocol::TType _etype1129;
            xfer += iprot->readListBegin(_etype1129, _size1126);
            this->thrift_attr_list.resize(_size1126);
            uint32_t _i1130;
            for (_i1130 = 0; _i1130 < _size1126; ++_i1130)
            {
              xfer += this->thrift_attr_list[_i1130].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_port_args");

  xfer += oprot->writeFieldBegin("port_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->port_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1131;
    for (_iter1131 = this->thrift_attr_list.begin(); _iter1131 != this->thrift_attr_list.end(); ++_iter1131)
    {
      xfer += (*_iter1131).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_port_pargs::~switch_sai_rpc_sai_thrift_create_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_port_pargs");

  xfer += oprot->writeFieldBegin("port_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->port_name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1132;
    for (_iter1132 = (*(this->thrift_attr_list)).begin(); _iter1132 != (*(this->thrift_attr_list)).end(); ++_iter1132)
    {
      xfer += (*_iter1132).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_port_result::~switch_sai_rpc_sai_thrift_create_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_port_presult::~switch_sai_rpc_sai_thrift_create_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_port_args::~switch_sai_rpc_sai_thrift_remove_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_oid);
          this->__isset.port_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_port_args");

  xfer += oprot->writeFieldBegin("port_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_port_pargs::~switch_sai_rpc_sai_thrift_remove_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_port_pargs");

  xfer += oprot->writeFieldBegin("port_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_port_result::~switch_sai_rpc_sai_thrift_remove_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_port_presult::~switch_sai_rpc_sai_thrift_remove_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_ptp_domain_args::~switch_sai_rpc_sai_thrift_create_ptp_domain_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ptp_domain_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1133;
            ::apache::thrift::protocol::TType _etype1136;
            xfer += iprot->readListBegin(_etype1136, _size1133);
            this->thrift_attr_list.resize(_size1133);
            uint32_t _i1137;
            for (_i1137 = 0; _i1137 < _size1133; ++_i1137)
            {
              xfer += this->thrift_attr_list[_i1137].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_ptp_domain_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ptp_domain_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1138;
    for (_iter1138 = this->thrift_attr_list.begin(); _iter1138 != this->thrift_attr_list.end(); ++_iter1138)
    {
      xfer += (*_iter1138).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ptp_domain_pargs::~switch_sai_rpc_sai_thrift_create_ptp_domain_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ptp_domain_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ptp_domain_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1139;
    for (_iter1139 = (*(this->thrift_attr_list)).begin(); _iter1139 != (*(this->thrift_attr_list)).end(); ++_iter1139)
    {
      xfer += (*_iter1139).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ptp_domain_result::~switch_sai_rpc_sai_thrift_create_ptp_domain_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ptp_domain_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_ptp_domain_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_ptp_domain_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_ptp_domain_presult::~switch_sai_rpc_sai_thrift_create_ptp_domain_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_ptp_domain_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ptp_domain_args::~switch_sai_rpc_sai_thrift_remove_ptp_domain_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ptp_domain_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ptp_oid);
          this->__isset.ptp_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_ptp_domain_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ptp_domain_args");

  xfer += oprot->writeFieldBegin("ptp_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ptp_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ptp_domain_pargs::~switch_sai_rpc_sai_thrift_remove_ptp_domain_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ptp_domain_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ptp_domain_pargs");

  xfer += oprot->writeFieldBegin("ptp_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->ptp_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ptp_domain_result::~switch_sai_rpc_sai_thrift_remove_ptp_domain_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ptp_domain_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_ptp_domain_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_ptp_domain_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_ptp_domain_presult::~switch_sai_rpc_sai_thrift_remove_ptp_domain_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_ptp_domain_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_args::~switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ptp_oid);
          this->__isset.ptp_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_args");

  xfer += oprot->writeFieldBegin("ptp_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ptp_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_pargs::~switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_pargs");

  xfer += oprot->writeFieldBegin("ptp_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->ptp_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_result::~switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_presult::~switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_args::~switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ptp_oid);
          this->__isset.ptp_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_args");

  xfer += oprot->writeFieldBegin("ptp_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ptp_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_pargs::~switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_pargs");

  xfer += oprot->writeFieldBegin("ptp_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->ptp_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_result::~switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_presult::~switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_es_args::~switch_sai_rpc_sai_thrift_create_es_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_es_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size1140;
            ::apache::thrift::protocol::TType _etype1143;
            xfer += iprot->readListBegin(_etype1143, _size1140);
            this->thrift_attr_list.resize(_size1140);
            uint32_t _i1144;
            for (_i1144 = 0; _i1144 < _size1140; ++_i1144)
            {
              xfer += this->thrift_attr_list[_i1144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_es_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_es_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1145;
    for (_iter1145 = this->thrift_attr_list.begin(); _iter1145 != this->thrift_attr_list.end(); ++_iter1145)
    {
      xfer += (*_iter1145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_es_pargs::~switch_sai_rpc_sai_thrift_create_es_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_es_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_es_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter1146;
    for (_iter1146 = (*(this->thrift_attr_list)).begin(); _iter1146 != (*(this->thrift_attr_list)).end(); ++_iter1146)
    {
      xfer += (*_iter1146).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_es_result::~switch_sai_rpc_sai_thrift_create_es_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_es_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_es_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_es_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_es_presult::~switch_sai_rpc_sai_thrift_create_es_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_es_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_es_args::~switch_sai_rpc_sai_thrift_remove_es_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_es_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->es_oid);
          this->__isset.es_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_es_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_es_args");

  xfer += oprot->writeFieldBegin("es_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->es_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_es_pargs::~switch_sai_rpc_sai_thrift_remove_es_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_es_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_es_pargs");

  xfer += oprot->writeFieldBegin("es_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->es_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_es_result::~switch_sai_rpc_sai_thrift_remove_es_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_es_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_es_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_es_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_es_presult::~switch_sai_rpc_sai_thrift_remove_es_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_es_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_es_attribute_args::~switch_sai_rpc_sai_thrift_set_es_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_es_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->es_oid);
          this->__isset.es_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_es_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_es_attribute_args");

  xfer += oprot->writeFieldBegin("es_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->es_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_es_attribute_pargs::~switch_sai_rpc_sai_thrift_set_es_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_es_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_es_attribute_pargs");

  xfer += oprot->writeFieldBegin("es_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->es_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_es_attribute_result::~switch_sai_rpc_sai_thrift_set_es_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_es_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_es_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_es_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_es_attribute_presult::~switch_sai_rpc_sai_thrift_set_es_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_es_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_es_attribute_args::~switch_sai_rpc_sai_thrift_get_es_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_es_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->es_oid);
          this->__isset.es_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_es_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_es_attribute_args");

  xfer += oprot->writeFieldBegin("es_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->es_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_es_attribute_pargs::~switch_sai_rpc_sai_thrift_get_es_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_es_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_es_attribute_pargs");

  xfer += oprot->writeFieldBegin("es_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->es_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_es_attribute_result::~switch_sai_rpc_sai_thrift_get_es_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_es_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_es_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_es_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_es_attribute_presult::~switch_sai_rpc_sai_thrift_get_es_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_es_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_port_attribute(port_id, thrift_attr);
  return recv_sai_thrift_set_port_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_port_attribute_pargs args;
  args.port_id = &port_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_port_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_port_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t port_id)
{
  send_sai_thrift_get_port_attribute(port_id);
  recv_sai_thrift_get_port_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_port_attribute(const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_attribute_pargs args;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_port_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_port_stats(port_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_port_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_port_stats(const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_stats_pargs args;
  args.port_id = &port_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_port_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_port_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_stats failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_port_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  send_sai_thrift_get_port_stats_ext(port_id, counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_port_stats_ext(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_port_stats_ext(const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_stats_ext_pargs args;
  args.port_id = &port_id;
  args.counter_ids = &counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_port_stats_ext(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_stats_ext") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_port_stats_ext_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_stats_ext failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
{
  send_sai_thrift_clear_port_all_stats(port_id);
  return recv_sai_thrift_clear_port_all_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_port_all_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs args;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_port_all_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_port_all_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_port_all_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_port_all_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_port_stats(const sai_thrift_object_id_t port_id, const int32_t number_of_counters, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids)
{
  send_sai_thrift_clear_port_stats(port_id, number_of_counters, counter_ids);
  return recv_sai_thrift_clear_port_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_port_stats(const sai_thrift_object_id_t port_id, const int32_t number_of_counters, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_port_stats_pargs args;
  args.port_id = &port_id;
  args.number_of_counters = &number_of_counters;
  args.counter_ids = &counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_port_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_port_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_port_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_port_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_fdb_entry(thrift_fdb_entry, thrift_attr_list);
  return recv_sai_thrift_create_fdb_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_fdb_entry_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_fdb_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_fdb_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_fdb_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_fdb_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  send_sai_thrift_delete_fdb_entry(thrift_fdb_entry);
  return recv_sai_thrift_delete_fdb_entry();
}

void switch_sai_rpcClient::send_sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_delete_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_delete_fdb_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_delete_fdb_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_delete_fdb_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_delete_fdb_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_flush_fdb_entries(thrift_attr_list);
  return recv_sai_thrift_flush_fdb_entries();
}

void switch_sai_rpcClient::send_sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_flush_fdb_entries", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_flush_fdb_entries()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_flush_fdb_entries") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_flush_fdb_entries_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_flush_fdb_entries failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_fdb_entry_attribute(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_fdb_entry_attribute(thrift_fdb_entry, thrift_attr);
  return recv_sai_thrift_set_fdb_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_fdb_entry_attribute(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_fdb_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_fdb_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_fdb_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_fdb_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_fdb_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  send_sai_thrift_get_fdb_entry_attribute(thrift_fdb_entry);
  recv_sai_thrift_get_fdb_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_fdb_entry_attribute(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_fdb_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_fdb_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_fdb_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_fdb_entry_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_vlan(thrift_attr_list);
  return recv_sai_thrift_create_vlan();
}

void switch_sai_rpcClient::send_sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_vlan", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_vlan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_vlan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_vlan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
{
  send_sai_thrift_remove_vlan(vlan_oid);
  return recv_sai_thrift_remove_vlan();
}

void switch_sai_rpcClient::send_sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_vlan", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_pargs args;
  args.vlan_oid = &vlan_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_vlan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_vlan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_vlan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_vlan_stats(vlan_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_vlan_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_stats(const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_stats_pargs args;
  args.vlan_id = &vlan_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_stats failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  send_sai_thrift_get_vlan_stats_ext(vlan_id, thrift_counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_vlan_stats_ext(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_stats_ext(const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_stats_ext_pargs args;
  args.vlan_id = &vlan_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_stats_ext(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_stats_ext") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_stats_ext_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_stats_ext failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_vlan_stats(const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_clear_vlan_stats(vlan_id, thrift_counter_ids, number_of_counters);
  return recv_sai_thrift_clear_vlan_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_vlan_stats(const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_vlan_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_vlan_stats_pargs args;
  args.vlan_id = &vlan_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_vlan_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_vlan_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_vlan_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_vlan_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_vlan_member(thrift_attr_list);
  return recv_sai_thrift_create_vlan_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_vlan_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_vlan_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_vlan_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_vlan_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan_member failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vlan_member_id)
{
  send_sai_thrift_get_vlan_member_attribute(vlan_member_id);
  recv_sai_thrift_get_vlan_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_member_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
{
  send_sai_thrift_remove_vlan_member(vlan_member_id);
  return recv_sai_thrift_remove_vlan_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_vlan_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_member_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_vlan_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_vlan_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_vlan_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_vlan_attribute(vlan_id, thrift_attr);
  return recv_sai_thrift_set_vlan_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_vlan_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs args;
  args.vlan_id = &vlan_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_vlan_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_vlan_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_vlan_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_vlan_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_vlan_member_attribute(vlan_member_id, thrift_attr);
  return recv_sai_thrift_set_vlan_member_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_vlan_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_vlan_member_attribute_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_vlan_member_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_vlan_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_vlan_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_vlan_member_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vlan_id)
{
  send_sai_thrift_get_vlan_attribute(vlan_id);
  recv_sai_thrift_get_vlan_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_attribute(const sai_thrift_object_id_t vlan_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs args;
  args.vlan_id = &vlan_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_id(sai_thrift_result_t& _return, const sai_thrift_object_id_t vlan_id)
{
  send_sai_thrift_get_vlan_id(vlan_id);
  recv_sai_thrift_get_vlan_id(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_id(const sai_thrift_object_id_t vlan_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_id_pargs args;
  args.vlan_id = &vlan_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_id(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_id failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_create_vlan_members(sai_thrift_results_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_lists, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  send_sai_thrift_create_vlan_members(thrift_attr_lists, thrift_attr_count_lists, mode);
  recv_sai_thrift_create_vlan_members(_return);
}

void switch_sai_rpcClient::send_sai_thrift_create_vlan_members(const std::vector<sai_thrift_attribute_t> & thrift_attr_lists, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_vlan_members", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_members_pargs args;
  args.thrift_attr_lists = &thrift_attr_lists;
  args.thrift_attr_count_lists = &thrift_attr_count_lists;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_create_vlan_members(sai_thrift_results_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_vlan_members") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_create_vlan_members_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan_members failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_remove_vlan_members(sai_thrift_status_list_t& _return, const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, const int8_t mode)
{
  send_sai_thrift_remove_vlan_members(thrift_object_id_list, mode);
  recv_sai_thrift_remove_vlan_members(_return);
}

void switch_sai_rpcClient::send_sai_thrift_remove_vlan_members(const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, const int8_t mode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_vlan_members", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_members_pargs args;
  args.thrift_object_id_list = &thrift_object_id_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_remove_vlan_members(sai_thrift_status_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_vlan_members") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_remove_vlan_members_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan_members failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_virtual_router(thrift_attr_list);
  return recv_sai_thrift_create_virtual_router();
}

void switch_sai_rpcClient::send_sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_virtual_router", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_virtual_router_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_virtual_router()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_virtual_router") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_virtual_router_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_virtual_router failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
{
  send_sai_thrift_remove_virtual_router(vr_id);
  return recv_sai_thrift_remove_virtual_router();
}

void switch_sai_rpcClient::send_sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_virtual_router", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_virtual_router_pargs args;
  args.vr_id = &vr_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_virtual_router()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_virtual_router") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_virtual_router_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_virtual_router failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_virtual_router_attribute(const sai_thrift_object_id_t vr_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_virtual_router_attribute(vr_id, thrift_attr);
  return recv_sai_thrift_set_virtual_router_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_virtual_router_attribute(const sai_thrift_object_id_t vr_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_virtual_router_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_virtual_router_attribute_pargs args;
  args.vr_id = &vr_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_virtual_router_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_virtual_router_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_virtual_router_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_virtual_router_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_virtual_router_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vr_id)
{
  send_sai_thrift_get_virtual_router_attribute(vr_id);
  recv_sai_thrift_get_virtual_router_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_virtual_router_attribute(const sai_thrift_object_id_t vr_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_virtual_router_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_virtual_router_attribute_pargs args;
  args.vr_id = &vr_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_virtual_router_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_virtual_router_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_virtual_router_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_virtual_router_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_route(thrift_route_entry, thrift_attr_list);
  return recv_sai_thrift_create_route();
}

void switch_sai_rpcClient::send_sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_route", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_route_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_route()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_route") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_route_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_route failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry)
{
  send_sai_thrift_remove_route(thrift_route_entry);
  return recv_sai_thrift_remove_route();
}

void switch_sai_rpcClient::send_sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_route", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_route_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_route()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_route") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_route_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_route failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_route_attribute(const sai_thrift_route_entry_t& thrift_route_entry, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_route_attribute(thrift_route_entry, thrift_attr);
  return recv_sai_thrift_set_route_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_route_attribute(const sai_thrift_route_entry_t& thrift_route_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_route_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_route_attribute_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_route_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_route_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_route_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_route_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_route_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_route_entry_t& thrift_route_entry)
{
  send_sai_thrift_get_route_attribute(thrift_route_entry);
  recv_sai_thrift_get_route_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_route_attribute(const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_route_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_route_attribute_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_route_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_route_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_route_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_route_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const std::vector<sai_thrift_attribute_t> & thrift_attr_list, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  send_sai_thrift_create_routes(thrift_route_entry_list, thrift_attr_list, thrift_attr_count_lists, mode);
  return recv_sai_thrift_create_routes();
}

void switch_sai_rpcClient::send_sai_thrift_create_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const std::vector<sai_thrift_attribute_t> & thrift_attr_list, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_routes", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_routes_pargs args;
  args.thrift_route_entry_list = &thrift_route_entry_list;
  args.thrift_attr_list = &thrift_attr_list;
  args.thrift_attr_count_lists = &thrift_attr_count_lists;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_routes()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_routes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_routes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_routes failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
{
  send_sai_thrift_remove_routes(thrift_route_entry_list, mode);
  return recv_sai_thrift_remove_routes();
}

void switch_sai_rpcClient::send_sai_thrift_remove_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_routes", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_routes_pargs args;
  args.thrift_route_entry_list = &thrift_route_entry_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_routes()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_routes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_routes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_routes failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_routes_attribute(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const std::vector<sai_thrift_attribute_t> & thrift_attr_list, const int8_t mode)
{
  send_sai_thrift_set_routes_attribute(thrift_route_entry_list, thrift_attr_list, mode);
  return recv_sai_thrift_set_routes_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_routes_attribute(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const std::vector<sai_thrift_attribute_t> & thrift_attr_list, const int8_t mode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_routes_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_routes_attribute_pargs args;
  args.thrift_route_entry_list = &thrift_route_entry_list;
  args.thrift_attr_list = &thrift_attr_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_routes_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_routes_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_routes_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_routes_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_routes_attribute(sai_thrift_attribute_list_t& _return, const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
{
  send_sai_thrift_get_routes_attribute(thrift_route_entry_list, mode);
  recv_sai_thrift_get_routes_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_routes_attribute(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_routes_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_routes_attribute_pargs args;
  args.thrift_route_entry_list = &thrift_route_entry_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_routes_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_routes_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_routes_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_routes_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_router_interface(thrift_attr_list);
  return recv_sai_thrift_create_router_interface();
}

void switch_sai_rpcClient::send_sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_router_interface", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_router_interface_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_router_interface()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_router_interface") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_router_interface_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_router_interface failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
{
  send_sai_thrift_remove_router_interface(rif_id);
  return recv_sai_thrift_remove_router_interface();
}

void switch_sai_rpcClient::send_sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_router_interface", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_router_interface_pargs args;
  args.rif_id = &rif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_router_interface()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_router_interface") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_router_interface_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_router_interface failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_router_interface_attribute(rif_id, thrift_attr);
  return recv_sai_thrift_set_router_interface_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_router_interface_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs args;
  args.rif_id = &rif_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_router_interface_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_router_interface_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_router_interface_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_router_interface_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t rif_id)
{
  send_sai_thrift_get_router_interface_attribute(rif_id);
  recv_sai_thrift_get_router_interface_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_router_interface_attribute(const sai_thrift_object_id_t rif_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_router_interface_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_router_interface_attribute_pargs args;
  args.rif_id = &rif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_router_interface_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_router_interface_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_router_interface_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_router_interface_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_router_interface_get_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_router_interface_get_stats(rif_id, thrift_counter_ids, number_of_counters);
  recv_sai_thrift_router_interface_get_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_router_interface_get_stats(const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_router_interface_get_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_router_interface_get_stats_pargs args;
  args.rif_id = &rif_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_router_interface_get_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_router_interface_get_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_router_interface_get_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_router_interface_get_stats failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_router_interface_get_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  send_sai_thrift_router_interface_get_stats_ext(rif_id, thrift_counter_ids, mode, number_of_counters);
  recv_sai_thrift_router_interface_get_stats_ext(_return);
}

void switch_sai_rpcClient::send_sai_thrift_router_interface_get_stats_ext(const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_router_interface_get_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_pargs args;
  args.rif_id = &rif_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_router_interface_get_stats_ext(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_router_interface_get_stats_ext") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_router_interface_get_stats_ext failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_router_interface_clear_stats(const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_router_interface_clear_stats(rif_id, thrift_counter_ids, number_of_counters);
  return recv_sai_thrift_router_interface_clear_stats();
}

void switch_sai_rpcClient::send_sai_thrift_router_interface_clear_stats(const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_router_interface_clear_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_router_interface_clear_stats_pargs args;
  args.rif_id = &rif_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_router_interface_clear_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_router_interface_clear_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_router_interface_clear_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_router_interface_clear_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_next_hop(thrift_attr_list);
  return recv_sai_thrift_create_next_hop();
}

void switch_sai_rpcClient::send_sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_next_hop", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_next_hop()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_next_hop") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_next_hop_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
{
  send_sai_thrift_remove_next_hop(next_hop_id);
  return recv_sai_thrift_remove_next_hop();
}

void switch_sai_rpcClient::send_sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_pargs args;
  args.next_hop_id = &next_hop_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_next_hop()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_next_hop") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_next_hop_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_next_hop_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t next_hop_id)
{
  send_sai_thrift_get_next_hop_attribute(next_hop_id);
  recv_sai_thrift_get_next_hop_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_next_hop_attribute(const sai_thrift_object_id_t next_hop_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_next_hop_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_next_hop_attribute_pargs args;
  args.next_hop_id = &next_hop_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_next_hop_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_next_hop_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_next_hop_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_next_hop_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_next_hop_group(thrift_attr_list);
  return recv_sai_thrift_create_next_hop_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_next_hop_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_next_hop_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_next_hop_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_next_hop_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid)
{
  send_sai_thrift_remove_next_hop_group(nhop_group_oid);
  return recv_sai_thrift_remove_next_hop_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs args;
  args.nhop_group_oid = &nhop_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_next_hop_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_next_hop_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_next_hop_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_next_hop_group_attribute(const sai_thrift_object_id_t nhop_group_oid, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_next_hop_group_attribute(nhop_group_oid, thrift_attr);
  return recv_sai_thrift_set_next_hop_group_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_next_hop_group_attribute(const sai_thrift_object_id_t nhop_group_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_next_hop_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_pargs args;
  args.nhop_group_oid = &nhop_group_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_next_hop_group_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_next_hop_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_next_hop_group_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_next_hop_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t nhop_group_oid)
{
  send_sai_thrift_get_next_hop_group_attribute(nhop_group_oid);
  recv_sai_thrift_get_next_hop_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_next_hop_group_attribute(const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_next_hop_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_pargs args;
  args.nhop_group_oid = &nhop_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_next_hop_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_next_hop_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_next_hop_group_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_next_hop_group_member(thrift_attr_list);
  return recv_sai_thrift_create_next_hop_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_next_hop_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_next_hop_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_next_hop_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid)
{
  send_sai_thrift_remove_next_hop_group_member(nhop_group_member_oid);
  return recv_sai_thrift_remove_next_hop_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs args;
  args.nhop_group_member_oid = &nhop_group_member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_next_hop_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_next_hop_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop_group_member failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_next_hop_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t nhop_group_member_oid)
{
  send_sai_thrift_get_next_hop_group_member_attribute(nhop_group_member_oid);
  recv_sai_thrift_get_next_hop_group_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_next_hop_group_member_attribute(const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_next_hop_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_pargs args;
  args.nhop_group_member_oid = &nhop_group_member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_next_hop_group_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_next_hop_group_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_next_hop_group_member_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_lag(thrift_attr_list);
  return recv_sai_thrift_create_lag();
}

void switch_sai_rpcClient::send_sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_lag", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_lag_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_lag()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_lag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_lag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_lag failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
{
  send_sai_thrift_remove_lag(lag_id);
  return recv_sai_thrift_remove_lag();
}

void switch_sai_rpcClient::send_sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_lag", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_lag_pargs args;
  args.lag_id = &lag_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_lag()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_lag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_lag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_lag failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_lag_attribute(lag_id, thrift_attr);
  return recv_sai_thrift_set_lag_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_lag_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_lag_attribute_pargs args;
  args.lag_id = &lag_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_lag_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_lag_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_lag_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_lag_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_lag_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t lag_id)
{
  send_sai_thrift_get_lag_attribute(lag_id);
  recv_sai_thrift_get_lag_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_lag_attribute(const sai_thrift_object_id_t lag_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_lag_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_lag_attribute_pargs args;
  args.lag_id = &lag_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_lag_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_lag_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_lag_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_lag_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_lag_member(thrift_attr_list);
  return recv_sai_thrift_create_lag_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_lag_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_lag_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_lag_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_lag_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_lag_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_lag_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
{
  send_sai_thrift_remove_lag_member(lag_member_id);
  return recv_sai_thrift_remove_lag_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_lag_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_lag_member_pargs args;
  args.lag_member_id = &lag_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_lag_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_lag_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_lag_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_lag_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_lag_member_attribute(const sai_thrift_object_id_t lag_member_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_lag_member_attribute(lag_member_id, thrift_attr);
  return recv_sai_thrift_set_lag_member_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_lag_member_attribute(const sai_thrift_object_id_t lag_member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_lag_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_lag_member_attribute_pargs args;
  args.lag_member_id = &lag_member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_lag_member_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_lag_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_lag_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_lag_member_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t lag_member_id)
{
  send_sai_thrift_get_lag_member_attribute(lag_member_id);
  recv_sai_thrift_get_lag_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_lag_member_attribute(const sai_thrift_object_id_t lag_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_lag_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs args;
  args.lag_member_id = &lag_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_lag_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_lag_member_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_stp_entry(thrift_attr_list);
  return recv_sai_thrift_create_stp_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_stp_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_stp_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_stp_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_stp_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_stp_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_stp_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
{
  send_sai_thrift_remove_stp_entry(stp_id);
  return recv_sai_thrift_remove_stp_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_stp_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_stp_entry_pargs args;
  args.stp_id = &stp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_stp_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_stp_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_stp_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_stp_entry failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_stp_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t stp_id)
{
  send_sai_thrift_get_stp_attribute(stp_id);
  recv_sai_thrift_get_stp_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_stp_attribute(const sai_thrift_object_id_t stp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_stp_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_stp_attribute_pargs args;
  args.stp_id = &stp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_stp_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_stp_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_stp_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_stp_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_stp_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_stp_port(thrift_attr_list);
  return recv_sai_thrift_create_stp_port();
}

void switch_sai_rpcClient::send_sai_thrift_create_stp_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_stp_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_stp_port_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_stp_port()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_stp_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_stp_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_stp_port failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_id)
{
  send_sai_thrift_remove_stp_port(stp_port_id);
  return recv_sai_thrift_remove_stp_port();
}

void switch_sai_rpcClient::send_sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_stp_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_stp_port_pargs args;
  args.stp_port_id = &stp_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_stp_port()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_stp_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_stp_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_stp_port failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_stp_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t stp_port_id)
{
  send_sai_thrift_get_stp_port_attribute(stp_port_id);
  recv_sai_thrift_get_stp_port_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_stp_port_attribute(const sai_thrift_object_id_t stp_port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_stp_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_stp_port_attribute_pargs args;
  args.stp_port_id = &stp_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_stp_port_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_stp_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_stp_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_stp_port_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state)
{
  send_sai_thrift_set_stp_port_state(stp_id, port_id, stp_port_state);
  return recv_sai_thrift_set_stp_port_state();
}

void switch_sai_rpcClient::send_sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_stp_port_state", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_stp_port_state_pargs args;
  args.stp_id = &stp_id;
  args.port_id = &port_id;
  args.stp_port_state = &stp_port_state;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_stp_port_state()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_stp_port_state") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_stp_port_state_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_stp_port_state failed: unknown result");
}

sai_thrift_port_stp_port_state_t switch_sai_rpcClient::sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id)
{
  send_sai_thrift_get_stp_port_state(stp_id, port_id);
  return recv_sai_thrift_get_stp_port_state();
}

void switch_sai_rpcClient::send_sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_stp_port_state", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_stp_port_state_pargs args;
  args.stp_id = &stp_id;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_port_stp_port_state_t switch_sai_rpcClient::recv_sai_thrift_get_stp_port_state()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_stp_port_state") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_port_stp_port_state_t _return;
  switch_sai_rpc_sai_thrift_get_stp_port_state_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_stp_port_state failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_create_stp_ports(sai_thrift_results_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_lists, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  send_sai_thrift_create_stp_ports(thrift_attr_lists, thrift_attr_count_lists, mode);
  recv_sai_thrift_create_stp_ports(_return);
}

void switch_sai_rpcClient::send_sai_thrift_create_stp_ports(const std::vector<sai_thrift_attribute_t> & thrift_attr_lists, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_stp_ports", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_stp_ports_pargs args;
  args.thrift_attr_lists = &thrift_attr_lists;
  args.thrift_attr_count_lists = &thrift_attr_count_lists;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_create_stp_ports(sai_thrift_results_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_stp_ports") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_create_stp_ports_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_stp_ports failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_remove_stp_ports(sai_thrift_status_list_t& _return, const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, const int8_t mode)
{
  send_sai_thrift_remove_stp_ports(thrift_object_id_list, mode);
  recv_sai_thrift_remove_stp_ports(_return);
}

void switch_sai_rpcClient::send_sai_thrift_remove_stp_ports(const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, const int8_t mode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_stp_ports", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_stp_ports_pargs args;
  args.thrift_object_id_list = &thrift_object_id_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_remove_stp_ports(sai_thrift_status_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_stp_ports") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_remove_stp_ports_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_stp_ports failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_neighbor_entry(thrift_neighbor_entry, thrift_attr_list);
  return recv_sai_thrift_create_neighbor_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_neighbor_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_neighbor_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_neighbor_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_neighbor_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  send_sai_thrift_remove_neighbor_entry(thrift_neighbor_entry);
  return recv_sai_thrift_remove_neighbor_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_neighbor_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_neighbor_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_neighbor_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_all_neighbor_entry()
{
  send_sai_thrift_remove_all_neighbor_entry();
  return recv_sai_thrift_remove_all_neighbor_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_all_neighbor_entry()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_all_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_all_neighbor_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_all_neighbor_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_all_neighbor_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_neighbor_entry_attribute(thrift_neighbor_entry, thrift_attr);
  return recv_sai_thrift_set_neighbor_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_neighbor_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_neighbor_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_neighbor_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_neighbor_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_neighbor_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  send_sai_thrift_get_neighbor_entry_attribute(thrift_neighbor_entry);
  recv_sai_thrift_get_neighbor_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_neighbor_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_neighbor_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_neighbor_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_neighbor_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& _return, const std::vector<int32_t> & thrift_attr_ids)
{
  send_sai_thrift_get_switch_attribute(thrift_attr_ids);
  recv_sai_thrift_get_switch_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_switch_attribute(const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_switch_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_attribute_pargs args;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_switch_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_switch_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& _return)
{
  send_sai_thrift_get_port_list_by_front_port();
  recv_sai_thrift_get_port_list_by_front_port(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_port_list_by_front_port()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_list_by_front_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_list_by_front_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_list_by_front_port failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_cpu_port_id()
{
  send_sai_thrift_get_cpu_port_id();
  return recv_sai_thrift_get_cpu_port_id();
}

void switch_sai_rpcClient::send_sai_thrift_get_cpu_port_id()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_cpu_port_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_cpu_port_id()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_cpu_port_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_cpu_port_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_cpu_port_id failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_default_trap_group()
{
  send_sai_thrift_get_default_trap_group();
  return recv_sai_thrift_get_default_trap_group();
}

void switch_sai_rpcClient::send_sai_thrift_get_default_trap_group()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_default_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_trap_group_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_default_trap_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_default_trap_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_default_trap_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_trap_group failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_default_router_id()
{
  send_sai_thrift_get_default_router_id();
  return recv_sai_thrift_get_default_router_id();
}

void switch_sai_rpcClient::send_sai_thrift_get_default_router_id()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_default_router_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_router_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_default_router_id()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_default_router_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_default_router_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_router_id failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_default_1q_bridge_id()
{
  send_sai_thrift_get_default_1q_bridge_id();
  return recv_sai_thrift_get_default_1q_bridge_id();
}

void switch_sai_rpcClient::send_sai_thrift_get_default_1q_bridge_id()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_default_1q_bridge_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_default_1q_bridge_id()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_default_1q_bridge_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_1q_bridge_id failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_default_vlan_id(sai_thrift_result_t& _return)
{
  send_sai_thrift_get_default_vlan_id();
  recv_sai_thrift_get_default_vlan_id(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_default_vlan_id()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_default_vlan_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_default_vlan_id(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_default_vlan_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_default_vlan_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_vlan_id failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_port_id_by_front_port(const std::string& port_name)
{
  send_sai_thrift_get_port_id_by_front_port(port_name);
  return recv_sai_thrift_get_port_id_by_front_port();
}

void switch_sai_rpcClient::send_sai_thrift_get_port_id_by_front_port(const std::string& port_name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_id_by_front_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs args;
  args.port_name = &port_name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_port_id_by_front_port()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_id_by_front_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_id_by_front_port failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attribute)
{
  send_sai_thrift_set_switch_attribute(attribute);
  return recv_sai_thrift_set_switch_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attribute)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_switch_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_switch_attribute_pargs args;
  args.attribute = &attribute;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_switch_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_switch_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_switch_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_switch_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_switch()
{
  send_sai_thrift_create_switch();
  return recv_sai_thrift_create_switch();
}

void switch_sai_rpcClient::send_sai_thrift_create_switch()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_switch", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_switch_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_switch()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_switch") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_switch_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_switch failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_switch()
{
  send_sai_thrift_remove_switch();
  return recv_sai_thrift_remove_switch();
}

void switch_sai_rpcClient::send_sai_thrift_remove_switch()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_switch", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_switch_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_switch()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_switch") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_switch_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_switch failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_switch_stats(std::vector<int64_t> & _return, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_switch_stats(counter_ids, number_of_counters);
  recv_sai_thrift_get_switch_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_switch_stats(const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_switch_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_stats_pargs args;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_switch_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_switch_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_switch_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_stats failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_switch_stats_ext(std::vector<int64_t> & _return, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  send_sai_thrift_get_switch_stats_ext(counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_switch_stats_ext(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_switch_stats_ext(const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_switch_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_stats_ext_pargs args;
  args.counter_ids = &counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_switch_stats_ext(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_switch_stats_ext") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_switch_stats_ext_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_stats_ext failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_switch_stats(const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_clear_switch_stats(counter_ids, number_of_counters);
  return recv_sai_thrift_clear_switch_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_switch_stats(const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_switch_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_switch_stats_pargs args;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_switch_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_switch_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_switch_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_switch_stats failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_create_bridge_port(sai_thrift_result_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_bridge_port(thrift_attr_list);
  recv_sai_thrift_create_bridge_port(_return);
}

void switch_sai_rpcClient::send_sai_thrift_create_bridge_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_bridge_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bridge_port_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_create_bridge_port(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_bridge_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_create_bridge_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bridge_port failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
{
  send_sai_thrift_remove_bridge_port(bridge_port_id);
  return recv_sai_thrift_remove_bridge_port();
}

void switch_sai_rpcClient::send_sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_bridge_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bridge_port_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_bridge_port()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_bridge_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_bridge_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bridge_port failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_bridge_port_list(sai_thrift_result_t& _return, const sai_thrift_object_id_t bridge_id)
{
  send_sai_thrift_get_bridge_port_list(bridge_id);
  recv_sai_thrift_get_bridge_port_list(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_bridge_port_list(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_list", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_bridge_port_list(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_bridge_port_list") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_bridge_port_list_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_list failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t bridge_port_id)
{
  send_sai_thrift_get_bridge_port_attribute(bridge_port_id);
  recv_sai_thrift_get_bridge_port_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_bridge_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_bridge_port_attribute(bridge_port_id, thrift_attr);
  return recv_sai_thrift_set_bridge_port_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_bridge_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_bridge_port_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_bridge_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_bridge_port_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_create_bridge(sai_thrift_result_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_bridge(thrift_attr_list);
  recv_sai_thrift_create_bridge(_return);
}

void switch_sai_rpcClient::send_sai_thrift_create_bridge(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_bridge", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bridge_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_create_bridge(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_bridge") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_create_bridge_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bridge failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_id)
{
  send_sai_thrift_remove_bridge(bridge_id);
  return recv_sai_thrift_remove_bridge();
}

void switch_sai_rpcClient::send_sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_bridge", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bridge_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_bridge()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_bridge") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_bridge_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bridge failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_bridge_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t bridge_id)
{
  send_sai_thrift_get_bridge_attribute(bridge_id);
  recv_sai_thrift_get_bridge_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_bridge_attribute(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_bridge_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_attribute_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_bridge_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_bridge_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_bridge_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_bridge_attribute(const sai_thrift_object_id_t bridge_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_bridge_attribute(bridge_id, thrift_attr);
  return recv_sai_thrift_set_bridge_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_bridge_attribute(const sai_thrift_object_id_t bridge_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_bridge_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_bridge_attribute_pargs args;
  args.bridge_id = &bridge_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_bridge_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_bridge_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_bridge_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_bridge_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_bridge_port_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_bridge_port_stats(bridge_port_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_bridge_port_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_bridge_port_stats(const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_stats_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_bridge_port_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_bridge_port_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_bridge_port_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_stats failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_bridge_port_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  send_sai_thrift_get_bridge_port_stats_ext(bridge_port_id, thrift_counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_bridge_port_stats_ext(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_bridge_port_stats_ext(const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_bridge_port_stats_ext(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_bridge_port_stats_ext") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_stats_ext failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_bridge_port_stats(const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_clear_bridge_port_stats(bridge_port_id, thrift_counter_ids, number_of_counters);
  return recv_sai_thrift_clear_bridge_port_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_bridge_port_stats(const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_bridge_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_bridge_port_stats_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_bridge_port_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_bridge_port_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_bridge_port_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_bridge_port_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hostif(thrift_attr_list);
  return recv_sai_thrift_create_hostif();
}

void switch_sai_rpcClient::send_sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hostif", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hostif()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hostif") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hostif_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id)
{
  send_sai_thrift_remove_hostif(thrift_hif_id);
  return recv_sai_thrift_remove_hostif();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hostif", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hostif()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hostif") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hostif_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_hostif_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hif_id)
{
  send_sai_thrift_get_hostif_attribute(thrift_hif_id);
  recv_sai_thrift_get_hostif_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_hostif_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hostif_attribute_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_hostif_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_hostif_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_hostif_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hostif_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hostif_attribute(thrift_hif_id, thrift_attr);
  return recv_sai_thrift_set_hostif_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hostif_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hostif_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hostif_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hostif_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hostif_table_entry(thrift_attr_list);
  return recv_sai_thrift_create_hostif_table_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hostif_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hostif_table_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hostif_table_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_table_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t thrift_hostif_table_entry_id)
{
  send_sai_thrift_remove_hostif_table_entry(thrift_hostif_table_entry_id);
  return recv_sai_thrift_remove_hostif_table_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t thrift_hostif_table_entry_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs args;
  args.thrift_hostif_table_entry_id = &thrift_hostif_table_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hostif_table_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hostif_table_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_table_entry failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_hostif_table_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hostif_table_entry_id)
{
  send_sai_thrift_get_hostif_table_entry_attribute(thrift_hostif_table_entry_id);
  recv_sai_thrift_get_hostif_table_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hostif_table_entry_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_hostif_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_pargs args;
  args.thrift_hostif_table_entry_id = &thrift_hostif_table_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_hostif_table_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_hostif_table_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hostif_table_entry_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hostif_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hostif_table_entry_attribute(thrift_hostif_table_entry_id, thrift_attr);
  return recv_sai_thrift_set_hostif_table_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hostif_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hostif_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs args;
  args.thrift_hostif_table_entry_id = &thrift_hostif_table_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hostif_table_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hostif_table_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_table_entry_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hostif_trap_group(thrift_attr_list);
  return recv_sai_thrift_create_hostif_trap_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hostif_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hostif_trap_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hostif_trap_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_trap_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  send_sai_thrift_remove_hostif_trap_group(thrift_hostif_trap_group_id);
  return recv_sai_thrift_remove_hostif_trap_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hostif_trap_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hostif_trap_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_trap_group failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_hostif_trap_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  send_sai_thrift_get_hostif_trap_group_attribute(thrift_hostif_trap_group_id);
  recv_sai_thrift_get_hostif_trap_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_hostif_trap_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_hostif_trap_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_hostif_trap_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hostif_trap_group_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hostif_trap_group_attribute(thrift_hostif_trap_group_id, thrift_attr);
  return recv_sai_thrift_set_hostif_trap_group_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hostif_trap_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hostif_trap_group_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hostif_trap_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_trap_group_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hostif_trap(thrift_attr_list);
  return recv_sai_thrift_create_hostif_trap();
}

void switch_sai_rpcClient::send_sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hostif_trap", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_trap_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hostif_trap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hostif_trap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hostif_trap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_trap failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  send_sai_thrift_remove_hostif_trap(thrift_hostif_trap_id);
  return recv_sai_thrift_remove_hostif_trap();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_trap", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hostif_trap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hostif_trap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hostif_trap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_trap failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_hostif_trap_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  send_sai_thrift_get_hostif_trap_attribute(thrift_hostif_trap_id);
  recv_sai_thrift_get_hostif_trap_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_hostif_trap_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_hostif_trap_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_hostif_trap_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hostif_trap_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hostif_trap_attribute(thrift_hostif_trap_id, thrift_attr);
  return recv_sai_thrift_set_hostif_trap_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hostif_trap_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hostif_trap_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hostif_trap_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_trap_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_send_hostif_packet(const sai_thrift_object_id_t thrift_hif_id, const std::string& packet_data, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_send_hostif_packet(thrift_hif_id, packet_data, thrift_attr_list);
  return recv_sai_thrift_send_hostif_packet();
}

void switch_sai_rpcClient::send_sai_thrift_send_hostif_packet(const sai_thrift_object_id_t thrift_hif_id, const std::string& packet_data, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_send_hostif_packet", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_send_hostif_packet_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.packet_data = &packet_data;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_send_hostif_packet()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_send_hostif_packet") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_send_hostif_packet_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_send_hostif_packet failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_table(thrift_attr_list);
  return recv_sai_thrift_create_acl_table();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_table", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_table()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_table") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_table_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
{
  send_sai_thrift_remove_acl_table(acl_table_id);
  return recv_sai_thrift_remove_acl_table();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_pargs args;
  args.acl_table_id = &acl_table_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_table()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_table") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_table_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_acl_table_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t acl_table_id, const std::vector<int32_t> & thrift_attr_ids)
{
  send_sai_thrift_get_acl_table_attribute(acl_table_id, thrift_attr_ids);
  recv_sai_thrift_get_acl_table_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_acl_table_attribute(const sai_thrift_object_id_t acl_table_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_acl_table_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_table_attribute_pargs args;
  args.acl_table_id = &acl_table_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_acl_table_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_acl_table_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_acl_table_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_table_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_entry(thrift_attr_list);
  return recv_sai_thrift_create_acl_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
{
  send_sai_thrift_remove_acl_entry(acl_entry);
  return recv_sai_thrift_remove_acl_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_entry_pargs args;
  args.acl_entry = &acl_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_acl_entry_attribute(acl_entry_id, thrift_attr);
  return recv_sai_thrift_set_acl_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_acl_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_acl_entry_attribute_pargs args;
  args.acl_entry_id = &acl_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_acl_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_acl_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_acl_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_acl_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_acl_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t acl_entry_id, const std::vector<int32_t> & thrift_attr_ids)
{
  send_sai_thrift_get_acl_entry_attribute(acl_entry_id, thrift_attr_ids);
  recv_sai_thrift_get_acl_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_acl_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_entry_attribute_pargs args;
  args.acl_entry_id = &acl_entry_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_acl_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_acl_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_acl_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_entry_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_table_group(thrift_attr_list);
  return recv_sai_thrift_create_acl_table_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_table_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_table_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_table_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_table_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
{
  send_sai_thrift_remove_acl_table_group(acl_table_group_id);
  return recv_sai_thrift_remove_acl_table_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs args;
  args.acl_table_group_id = &acl_table_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_table_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_table_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_table_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table_group failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_acl_table_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t acl_table_group_id)
{
  send_sai_thrift_get_acl_table_group_attribute(acl_table_group_id);
  recv_sai_thrift_get_acl_table_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_acl_table_group_attribute(const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_acl_table_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_pargs args;
  args.acl_table_group_id = &acl_table_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_acl_table_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_acl_table_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_table_group_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_table_group_member(thrift_attr_list);
  return recv_sai_thrift_create_acl_table_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_table_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_table_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_table_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
{
  send_sai_thrift_remove_acl_table_group_member(acl_table_group_member_id);
  return recv_sai_thrift_remove_acl_table_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs args;
  args.acl_table_group_member_id = &acl_table_group_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_table_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_table_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table_group_member failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_acl_table_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t acl_table_group_member_id)
{
  send_sai_thrift_get_acl_table_group_member_attribute(acl_table_group_member_id);
  recv_sai_thrift_get_acl_table_group_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_acl_table_group_member_attribute(const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_acl_table_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_pargs args;
  args.acl_table_group_member_id = &acl_table_group_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_acl_table_group_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_acl_table_group_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_table_group_member_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_counter(thrift_attr_list);
  return recv_sai_thrift_create_acl_counter();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_counter failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
{
  send_sai_thrift_remove_acl_counter(acl_counter_id);
  return recv_sai_thrift_remove_acl_counter();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_counter_pargs args;
  args.acl_counter_id = &acl_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_counter failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_acl_counter_attribute(std::vector<sai_thrift_attribute_value_t> & _return, const sai_thrift_object_id_t acl_counter_id, const std::vector<int32_t> & thrift_attr_ids)
{
  send_sai_thrift_get_acl_counter_attribute(acl_counter_id, thrift_attr_ids);
  recv_sai_thrift_get_acl_counter_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_acl_counter_attribute(const sai_thrift_object_id_t acl_counter_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_acl_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs args;
  args.acl_counter_id = &acl_counter_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_acl_counter_attribute(std::vector<sai_thrift_attribute_value_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_acl_counter_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_counter_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_range(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_range(thrift_attr_list);
  return recv_sai_thrift_create_acl_range();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_range(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_range", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_range_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_range()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_range") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_range_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_range failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_range(const sai_thrift_object_id_t acl_range_id)
{
  send_sai_thrift_remove_acl_range(acl_range_id);
  return recv_sai_thrift_remove_acl_range();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_range(const sai_thrift_object_id_t acl_range_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_range", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_range_pargs args;
  args.acl_range_id = &acl_range_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_range()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_range") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_range_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_range failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hash(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hash(thrift_attr_list);
  return recv_sai_thrift_create_hash();
}

void switch_sai_rpcClient::send_sai_thrift_create_hash(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hash", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hash_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hash()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hash") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hash_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hash failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hash(const sai_thrift_object_id_t hash_id)
{
  send_sai_thrift_remove_hash(hash_id);
  return recv_sai_thrift_remove_hash();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hash(const sai_thrift_object_id_t hash_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hash", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hash_pargs args;
  args.hash_id = &hash_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hash()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hash") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hash_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hash failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hash_attribute(const sai_thrift_object_id_t thrift_hash_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hash_attribute(thrift_hash_id, thrift_attr);
  return recv_sai_thrift_set_hash_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hash_attribute(const sai_thrift_object_id_t thrift_hash_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hash_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hash_attribute_pargs args;
  args.thrift_hash_id = &thrift_hash_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hash_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hash_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hash_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hash_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_hash_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hash_id)
{
  send_sai_thrift_get_hash_attribute(thrift_hash_id);
  recv_sai_thrift_get_hash_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_hash_attribute(const sai_thrift_object_id_t thrift_hash_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_hash_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hash_attribute_pargs args;
  args.thrift_hash_id = &thrift_hash_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_hash_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_hash_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_hash_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hash_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_udf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_udf_group(thrift_attr_list);
  return recv_sai_thrift_create_udf_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_udf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_udf_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_udf_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_udf_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_udf_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_udf_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_udf_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_udf_group(const sai_thrift_object_id_t udf_group_id)
{
  send_sai_thrift_remove_udf_group(udf_group_id);
  return recv_sai_thrift_remove_udf_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_udf_group(const sai_thrift_object_id_t udf_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_udf_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_udf_group_pargs args;
  args.udf_group_id = &udf_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_udf_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_udf_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_udf_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_udf_group failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_udf_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_udf_group_id)
{
  send_sai_thrift_get_udf_group_attribute(thrift_udf_group_id);
  recv_sai_thrift_get_udf_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_udf_group_attribute(const sai_thrift_object_id_t thrift_udf_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_udf_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_udf_group_attribute_pargs args;
  args.thrift_udf_group_id = &thrift_udf_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_udf_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_udf_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_udf_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_udf_group_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_udf_match(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_udf_match(thrift_attr_list);
  return recv_sai_thrift_create_udf_match();
}

void switch_sai_rpcClient::send_sai_thrift_create_udf_match(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_udf_match", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_udf_match_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_udf_match()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_udf_match") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_udf_match_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_udf_match failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_udf_match(const sai_thrift_object_id_t udf_match_id)
{
  send_sai_thrift_remove_udf_match(udf_match_id);
  return recv_sai_thrift_remove_udf_match();
}

void switch_sai_rpcClient::send_sai_thrift_remove_udf_match(const sai_thrift_object_id_t udf_match_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_udf_match", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_udf_match_pargs args;
  args.udf_match_id = &udf_match_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_udf_match()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_udf_match") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_udf_match_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_udf_match failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_udf_match_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_udf_match_id)
{
  send_sai_thrift_get_udf_match_attribute(thrift_udf_match_id);
  recv_sai_thrift_get_udf_match_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_udf_match_attribute(const sai_thrift_object_id_t thrift_udf_match_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_udf_match_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_udf_match_attribute_pargs args;
  args.thrift_udf_match_id = &thrift_udf_match_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_udf_match_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_udf_match_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_udf_match_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_udf_match_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_udf(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_udf(thrift_attr_list);
  return recv_sai_thrift_create_udf();
}

void switch_sai_rpcClient::send_sai_thrift_create_udf(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_udf", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_udf_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_udf()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_udf") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_udf_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_udf failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_udf(const sai_thrift_object_id_t udf_id)
{
  send_sai_thrift_remove_udf(udf_id);
  return recv_sai_thrift_remove_udf();
}

void switch_sai_rpcClient::send_sai_thrift_remove_udf(const sai_thrift_object_id_t udf_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_udf", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_udf_pargs args;
  args.udf_id = &udf_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_udf()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_udf") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_udf_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_udf failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_udf_attribute(const sai_thrift_object_id_t thrift_udf_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_udf_attribute(thrift_udf_id, thrift_attr);
  return recv_sai_thrift_set_udf_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_udf_attribute(const sai_thrift_object_id_t thrift_udf_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_udf_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_udf_attribute_pargs args;
  args.thrift_udf_id = &thrift_udf_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_udf_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_udf_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_udf_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_udf_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_udf_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_udf_id)
{
  send_sai_thrift_get_udf_attribute(thrift_udf_id);
  recv_sai_thrift_get_udf_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_udf_attribute(const sai_thrift_object_id_t thrift_udf_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_udf_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_udf_attribute_pargs args;
  args.thrift_udf_id = &thrift_udf_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_udf_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_udf_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_udf_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_udf_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_twamp_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_twamp_session(thrift_attr_list);
  return recv_sai_thrift_create_twamp_session();
}

void switch_sai_rpcClient::send_sai_thrift_create_twamp_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_twamp_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_twamp_session_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_twamp_session()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_twamp_session") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_twamp_session_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_twamp_session failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_twamp_session(const sai_thrift_object_id_t session_id)
{
  send_sai_thrift_remove_twamp_session(session_id);
  return recv_sai_thrift_remove_twamp_session();
}

void switch_sai_rpcClient::send_sai_thrift_remove_twamp_session(const sai_thrift_object_id_t session_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_twamp_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_twamp_session_pargs args;
  args.session_id = &session_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_twamp_session()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_twamp_session") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_twamp_session_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_twamp_session failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_twamp_attribute(const sai_thrift_object_id_t thrift_twamp_session_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_twamp_attribute(thrift_twamp_session_id, thrift_attr);
  return recv_sai_thrift_set_twamp_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_twamp_attribute(const sai_thrift_object_id_t thrift_twamp_session_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_twamp_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_twamp_attribute_pargs args;
  args.thrift_twamp_session_id = &thrift_twamp_session_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_twamp_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_twamp_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_twamp_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_twamp_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_mirror_session(thrift_attr_list);
  return recv_sai_thrift_create_mirror_session();
}

void switch_sai_rpcClient::send_sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_mirror_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_mirror_session_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_mirror_session()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_mirror_session") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_mirror_session_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_mirror_session failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
{
  send_sai_thrift_remove_mirror_session(session_id);
  return recv_sai_thrift_remove_mirror_session();
}

void switch_sai_rpcClient::send_sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_mirror_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_mirror_session_pargs args;
  args.session_id = &session_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_mirror_session()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_mirror_session") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_mirror_session_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_mirror_session failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_mirror_attribute(const sai_thrift_object_id_t thrift_mirror_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_mirror_attribute(thrift_mirror_id, thrift_attr);
  return recv_sai_thrift_set_mirror_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_mirror_attribute(const sai_thrift_object_id_t thrift_mirror_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_mirror_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_mirror_attribute_pargs args;
  args.thrift_mirror_id = &thrift_mirror_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_mirror_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_mirror_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_mirror_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_mirror_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_mirror_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_mirror_id)
{
  send_sai_thrift_get_mirror_attribute(thrift_mirror_id);
  recv_sai_thrift_get_mirror_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_mirror_attribute(const sai_thrift_object_id_t thrift_mirror_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_mirror_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_mirror_attribute_pargs args;
  args.thrift_mirror_id = &thrift_mirror_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_mirror_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_mirror_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_mirror_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_mirror_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_inseg_entry(const sai_thrift_inseg_entry_t& thrift_inseg_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_inseg_entry(thrift_inseg_entry, thrift_attr_list);
  return recv_sai_thrift_create_inseg_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_inseg_entry(const sai_thrift_inseg_entry_t& thrift_inseg_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_inseg_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_inseg_entry_pargs args;
  args.thrift_inseg_entry = &thrift_inseg_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_inseg_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_inseg_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_inseg_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_inseg_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_inseg_entry(const sai_thrift_inseg_entry_t& thrift_inseg_entry)
{
  send_sai_thrift_remove_inseg_entry(thrift_inseg_entry);
  return recv_sai_thrift_remove_inseg_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_inseg_entry(const sai_thrift_inseg_entry_t& thrift_inseg_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_inseg_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_inseg_entry_pargs args;
  args.thrift_inseg_entry = &thrift_inseg_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_inseg_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_inseg_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_inseg_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_inseg_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_inseg_entry_attribute(const sai_thrift_inseg_entry_t& thrift_inseg_entry, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_inseg_entry_attribute(thrift_inseg_entry, thrift_attr);
  return recv_sai_thrift_set_inseg_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_inseg_entry_attribute(const sai_thrift_inseg_entry_t& thrift_inseg_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_inseg_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_pargs args;
  args.thrift_inseg_entry = &thrift_inseg_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_inseg_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_inseg_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_inseg_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_inseg_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_inseg_entry_t& thrift_inseg_entry)
{
  send_sai_thrift_get_inseg_entry_attribute(thrift_inseg_entry);
  recv_sai_thrift_get_inseg_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_inseg_entry_attribute(const sai_thrift_inseg_entry_t& thrift_inseg_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_inseg_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_pargs args;
  args.thrift_inseg_entry = &thrift_inseg_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_inseg_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_inseg_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_inseg_entry_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_dump_log(const std::string& dump_file_name)
{
  send_sai_thrift_dump_log(dump_file_name);
  return recv_sai_thrift_dump_log();
}

void switch_sai_rpcClient::send_sai_thrift_dump_log(const std::string& dump_file_name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_dump_log", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_dump_log_pargs args;
  args.dump_file_name = &dump_file_name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_dump_log()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_dump_log") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_dump_log_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_dump_log failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_policer(thrift_attr_list);
  return recv_sai_thrift_create_policer();
}

void switch_sai_rpcClient::send_sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_policer", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_policer_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_policer()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_policer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_policer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_policer failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id)
{
  send_sai_thrift_remove_policer(thrift_policer_id);
  return recv_sai_thrift_remove_policer();
}

void switch_sai_rpcClient::send_sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_policer", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_policer_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_policer()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_policer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_policer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_policer failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_policer_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_policer_id)
{
  send_sai_thrift_get_policer_attribute(thrift_policer_id);
  recv_sai_thrift_get_policer_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_policer_attribute(const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_policer_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_policer_attribute_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_policer_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_policer_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_policer_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_policer_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_policer_attribute(thrift_policer_id, thrift_attr);
  return recv_sai_thrift_set_policer_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_policer_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_policer_attribute_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_policer_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_policer_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_policer_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_policer_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & _return, const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  send_sai_thrift_get_policer_stats(thrift_policer_id, thrift_counter_ids);
  recv_sai_thrift_get_policer_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_policer_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_policer_stats_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_policer_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_policer_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_policer_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  send_sai_thrift_clear_policer_stats(thrift_policer_id, thrift_counter_ids);
  return recv_sai_thrift_clear_policer_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_policer_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_policer_stats_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_policer_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_policer_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_policer_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_policer_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_scheduler_profile(thrift_attr_list);
  return recv_sai_thrift_create_scheduler_profile();
}

void switch_sai_rpcClient::send_sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_scheduler_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_scheduler_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_scheduler_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_scheduler_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_scheduler_profile failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
{
  send_sai_thrift_remove_scheduler_profile(scheduler_id);
  return recv_sai_thrift_remove_scheduler_profile();
}

void switch_sai_rpcClient::send_sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_scheduler_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs args;
  args.scheduler_id = &scheduler_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_scheduler_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_scheduler_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_scheduler_profile failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_scheduler_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_scheduler_id)
{
  send_sai_thrift_get_scheduler_attribute(thrift_scheduler_id);
  recv_sai_thrift_get_scheduler_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_scheduler_attribute(const sai_thrift_object_id_t thrift_scheduler_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_scheduler_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_scheduler_attribute_pargs args;
  args.thrift_scheduler_id = &thrift_scheduler_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_scheduler_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_scheduler_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_scheduler_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_scheduler_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_scheduler_attribute(const sai_thrift_object_id_t thrift_scheduler_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_scheduler_attribute(thrift_scheduler_id, thrift_attr);
  return recv_sai_thrift_set_scheduler_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_scheduler_attribute(const sai_thrift_object_id_t thrift_scheduler_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_scheduler_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_scheduler_attribute_pargs args;
  args.thrift_scheduler_id = &thrift_scheduler_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_scheduler_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_scheduler_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_scheduler_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_scheduler_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_scheduler_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_scheduler_group(thrift_attr_list);
  return recv_sai_thrift_create_scheduler_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_scheduler_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_scheduler_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_scheduler_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_scheduler_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_scheduler_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_scheduler_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_scheduler_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_scheduler_group(const sai_thrift_object_id_t scheduler_group_id)
{
  send_sai_thrift_remove_scheduler_group(scheduler_group_id);
  return recv_sai_thrift_remove_scheduler_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_scheduler_group(const sai_thrift_object_id_t scheduler_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_scheduler_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_scheduler_group_pargs args;
  args.scheduler_group_id = &scheduler_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_scheduler_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_scheduler_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_scheduler_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_scheduler_group failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_scheduler_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t scheduler_group_id)
{
  send_sai_thrift_get_scheduler_group_attribute(scheduler_group_id);
  recv_sai_thrift_get_scheduler_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_scheduler_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_pargs args;
  args.scheduler_group_id = &scheduler_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_scheduler_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_scheduler_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_scheduler_group_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_scheduler_group_attribute(scheduler_group_id, thrift_attr);
  return recv_sai_thrift_set_scheduler_group_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_scheduler_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_pargs args;
  args.scheduler_group_id = &scheduler_group_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_scheduler_group_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_scheduler_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_scheduler_group_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_queue_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_queue_stats(queue_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_queue_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_queue_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_queue_stats_pargs args;
  args.queue_id = &queue_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_queue_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_queue_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_queue_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_queue_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_clear_queue_stats(queue_id, counter_ids, number_of_counters);
  return recv_sai_thrift_clear_queue_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_queue_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_queue_stats_pargs args;
  args.queue_id = &queue_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_queue_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_queue_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_queue_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_queue_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_queue(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_queue(thrift_attr_list);
  return recv_sai_thrift_create_queue();
}

void switch_sai_rpcClient::send_sai_thrift_create_queue(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_queue", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_queue_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_queue()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_queue") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_queue_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_queue failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_queue(const sai_thrift_object_id_t queue_id)
{
  send_sai_thrift_remove_queue(queue_id);
  return recv_sai_thrift_remove_queue();
}

void switch_sai_rpcClient::send_sai_thrift_remove_queue(const sai_thrift_object_id_t queue_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_queue", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_queue_pargs args;
  args.queue_id = &queue_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_queue()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_queue") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_queue_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_queue failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_queue_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t queue_id)
{
  send_sai_thrift_get_queue_attribute(queue_id);
  recv_sai_thrift_get_queue_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_queue_attribute(const sai_thrift_object_id_t queue_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_queue_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_queue_attribute_pargs args;
  args.queue_id = &queue_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_queue_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_queue_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_queue_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_queue_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_queue_attribute(queue_id, thrift_attr);
  return recv_sai_thrift_set_queue_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_queue_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_queue_attribute_pargs args;
  args.queue_id = &queue_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_queue_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_queue_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_queue_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_queue_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_buffer_profile(thrift_attr_list);
  return recv_sai_thrift_create_buffer_profile();
}

void switch_sai_rpcClient::send_sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_buffer_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_buffer_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_buffer_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_buffer_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_buffer_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_buffer_profile failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_buffer_profile(const sai_thrift_object_id_t buffer_profile_id)
{
  send_sai_thrift_remove_buffer_profile(buffer_profile_id);
  return recv_sai_thrift_remove_buffer_profile();
}

void switch_sai_rpcClient::send_sai_thrift_remove_buffer_profile(const sai_thrift_object_id_t buffer_profile_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_buffer_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_buffer_profile_pargs args;
  args.buffer_profile_id = &buffer_profile_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_buffer_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_buffer_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_buffer_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_buffer_profile failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_buffer_profile_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t buffer_profile_id)
{
  send_sai_thrift_get_buffer_profile_attribute(buffer_profile_id);
  recv_sai_thrift_get_buffer_profile_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_buffer_profile_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_pargs args;
  args.buffer_profile_id = &buffer_profile_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_buffer_profile_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_buffer_profile_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_buffer_profile_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_buffer_profile_attribute(buffer_profile_id, thrift_attr);
  return recv_sai_thrift_set_buffer_profile_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_buffer_profile_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_pargs args;
  args.buffer_profile_id = &buffer_profile_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_buffer_profile_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_buffer_profile_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_buffer_profile_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_pool_profile(thrift_attr_list);
  return recv_sai_thrift_create_pool_profile();
}

void switch_sai_rpcClient::send_sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_pool_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_pool_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_pool_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_pool_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_pool_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_pool_profile failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_priority_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_priority_group(thrift_attr_list);
  return recv_sai_thrift_create_priority_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_priority_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_priority_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_priority_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_priority_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_priority_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_priority_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_priority_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_priority_group(const sai_thrift_object_id_t priority_group_id)
{
  send_sai_thrift_remove_priority_group(priority_group_id);
  return recv_sai_thrift_remove_priority_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_priority_group(const sai_thrift_object_id_t priority_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_priority_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_priority_group_pargs args;
  args.priority_group_id = &priority_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_priority_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_priority_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_priority_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_priority_group failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_priority_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t priority_group_id)
{
  send_sai_thrift_get_priority_group_attribute(priority_group_id);
  recv_sai_thrift_get_priority_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_priority_group_attribute(const sai_thrift_object_id_t priority_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_priority_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_priority_group_attribute_pargs args;
  args.priority_group_id = &priority_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_priority_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_priority_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_priority_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_priority_group_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_priority_group_attribute(pg_id, thrift_attr);
  return recv_sai_thrift_set_priority_group_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_priority_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs args;
  args.pg_id = &pg_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_priority_group_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_priority_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_priority_group_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_pg_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t pg_id, const std::vector<sai_thrift_pg_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_pg_stats(pg_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_pg_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_pg_stats(const sai_thrift_object_id_t pg_id, const std::vector<sai_thrift_pg_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_pg_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_pg_stats_pargs args;
  args.pg_id = &pg_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_pg_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_pg_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_pg_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_pg_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_wred_profile(thrift_attr_list);
  return recv_sai_thrift_create_wred_profile();
}

void switch_sai_rpcClient::send_sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_wred_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_wred_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_wred_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_wred_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_wred_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_wred_profile failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
{
  send_sai_thrift_remove_wred_profile(wred_id);
  return recv_sai_thrift_remove_wred_profile();
}

void switch_sai_rpcClient::send_sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_wred_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_wred_profile_pargs args;
  args.wred_id = &wred_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_wred_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_wred_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_wred_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_wred_profile failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_wred_attribute_profile(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t wred_id)
{
  send_sai_thrift_get_wred_attribute_profile(wred_id);
  recv_sai_thrift_get_wred_attribute_profile(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_wred_attribute_profile(const sai_thrift_object_id_t wred_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_wred_attribute_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_wred_attribute_profile_pargs args;
  args.wred_id = &wred_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_wred_attribute_profile(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_wred_attribute_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_wred_attribute_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_wred_attribute_profile failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_wred_attribute_profile(const sai_thrift_object_id_t wred_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_wred_attribute_profile(wred_id, thrift_attr);
  return recv_sai_thrift_set_wred_attribute_profile();
}

void switch_sai_rpcClient::send_sai_thrift_set_wred_attribute_profile(const sai_thrift_object_id_t wred_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_wred_attribute_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_wred_attribute_profile_pargs args;
  args.wred_id = &wred_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_wred_attribute_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_wred_attribute_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_wred_attribute_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_wred_attribute_profile failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_qos_map(thrift_attr_list);
  return recv_sai_thrift_create_qos_map();
}

void switch_sai_rpcClient::send_sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_qos_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_qos_map_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_qos_map()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_qos_map") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_qos_map_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_qos_map failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
{
  send_sai_thrift_remove_qos_map(qos_map_id);
  return recv_sai_thrift_remove_qos_map();
}

void switch_sai_rpcClient::send_sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_qos_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_qos_map_pargs args;
  args.qos_map_id = &qos_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_qos_map()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_qos_map") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_qos_map_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_qos_map failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_qos_map_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t qos_map_id)
{
  send_sai_thrift_get_qos_map_attribute(qos_map_id);
  recv_sai_thrift_get_qos_map_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_qos_map_attribute(const sai_thrift_object_id_t qos_map_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_qos_map_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_qos_map_attribute_pargs args;
  args.qos_map_id = &qos_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_qos_map_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_qos_map_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_qos_map_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_qos_map_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_qos_map_attribute(const sai_thrift_object_id_t qos_map_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_qos_map_attribute(qos_map_id, thrift_attr);
  return recv_sai_thrift_set_qos_map_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_qos_map_attribute(const sai_thrift_object_id_t qos_map_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_qos_map_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_qos_map_attribute_pargs args;
  args.qos_map_id = &qos_map_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_qos_map_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_qos_map_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_qos_map_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_qos_map_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_l2mc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_l2mc_group(thrift_attr_list);
  return recv_sai_thrift_create_l2mc_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_l2mc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_l2mc_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_l2mc_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_l2mc_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_l2mc_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_l2mc_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_l2mc_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_l2mc_group(const sai_thrift_object_id_t grp_id)
{
  send_sai_thrift_remove_l2mc_group(grp_id);
  return recv_sai_thrift_remove_l2mc_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_l2mc_group(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_l2mc_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_l2mc_group_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_l2mc_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_l2mc_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_l2mc_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_l2mc_group failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_l2mc_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t grp_id)
{
  send_sai_thrift_get_l2mc_group_attribute(grp_id);
  recv_sai_thrift_get_l2mc_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_l2mc_group_attribute(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_l2mc_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_l2mc_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_l2mc_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_l2mc_group_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_l2mc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_l2mc_group_member(thrift_attr_list);
  return recv_sai_thrift_create_l2mc_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_l2mc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_l2mc_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_l2mc_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_l2mc_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_l2mc_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_l2mc_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_l2mc_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_l2mc_group_member(const sai_thrift_object_id_t member_id)
{
  send_sai_thrift_remove_l2mc_group_member(member_id);
  return recv_sai_thrift_remove_l2mc_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_l2mc_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_l2mc_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_l2mc_group_member_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_l2mc_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_l2mc_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_l2mc_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_l2mc_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_l2mc_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_l2mc_group_member_attribute(member_id, thrift_attr);
  return recv_sai_thrift_set_l2mc_group_member_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_l2mc_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_l2mc_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_l2mc_group_member_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_l2mc_group_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_l2mc_group_member_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_l2mc_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t member_id)
{
  send_sai_thrift_get_l2mc_group_member_attribute(member_id);
  recv_sai_thrift_get_l2mc_group_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_l2mc_group_member_attribute(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_l2mc_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_l2mc_group_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_l2mc_group_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_l2mc_group_member_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_l2mc_entry(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_l2mc_entry(thrift_l2mc_entry, thrift_attr_list);
  return recv_sai_thrift_create_l2mc_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_l2mc_entry(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_l2mc_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_l2mc_entry_pargs args;
  args.thrift_l2mc_entry = &thrift_l2mc_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_l2mc_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_l2mc_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_l2mc_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_l2mc_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_l2mc_entry(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry)
{
  send_sai_thrift_remove_l2mc_entry(thrift_l2mc_entry);
  return recv_sai_thrift_remove_l2mc_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_l2mc_entry(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_l2mc_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_l2mc_entry_pargs args;
  args.thrift_l2mc_entry = &thrift_l2mc_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_l2mc_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_l2mc_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_l2mc_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_l2mc_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_l2mc_entry_attribute(thrift_l2mc_entry, thrift_attr);
  return recv_sai_thrift_set_l2mc_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_l2mc_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_pargs args;
  args.thrift_l2mc_entry = &thrift_l2mc_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_l2mc_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_l2mc_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_l2mc_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_l2mc_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_l2mc_entry_t& thrift_l2mc_entry)
{
  send_sai_thrift_get_l2mc_entry_attribute(thrift_l2mc_entry);
  recv_sai_thrift_get_l2mc_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_l2mc_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_pargs args;
  args.thrift_l2mc_entry = &thrift_l2mc_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_l2mc_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_l2mc_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_l2mc_entry_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_mcast_fdb_entry(thrift_mcast_fdb_entry, thrift_attr_list);
  return recv_sai_thrift_create_mcast_fdb_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_mcast_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_pargs args;
  args.thrift_mcast_fdb_entry = &thrift_mcast_fdb_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_mcast_fdb_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_mcast_fdb_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_mcast_fdb_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry)
{
  send_sai_thrift_remove_mcast_fdb_entry(thrift_mcast_fdb_entry);
  return recv_sai_thrift_remove_mcast_fdb_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_mcast_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_pargs args;
  args.thrift_mcast_fdb_entry = &thrift_mcast_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_mcast_fdb_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_mcast_fdb_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_mcast_fdb_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_mcast_fdb_entry_attribute(thrift_mcast_fdb_entry, thrift_attr);
  return recv_sai_thrift_set_mcast_fdb_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_mcast_fdb_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_pargs args;
  args.thrift_mcast_fdb_entry = &thrift_mcast_fdb_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_mcast_fdb_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_mcast_fdb_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_mcast_fdb_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_mcast_fdb_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry)
{
  send_sai_thrift_get_mcast_fdb_entry_attribute(thrift_mcast_fdb_entry);
  recv_sai_thrift_get_mcast_fdb_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_mcast_fdb_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_pargs args;
  args.thrift_mcast_fdb_entry = &thrift_mcast_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_mcast_fdb_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_mcast_fdb_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_mcast_fdb_entry_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_ipmc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_ipmc_group(thrift_attr_list);
  return recv_sai_thrift_create_ipmc_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_ipmc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_ipmc_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_ipmc_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_ipmc_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_ipmc_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_ipmc_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_ipmc_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_ipmc_group(const sai_thrift_object_id_t grp_id)
{
  send_sai_thrift_remove_ipmc_group(grp_id);
  return recv_sai_thrift_remove_ipmc_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_ipmc_group(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_ipmc_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_ipmc_group_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_ipmc_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_ipmc_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_ipmc_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_ipmc_group failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_ipmc_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t grp_id)
{
  send_sai_thrift_get_ipmc_group_attribute(grp_id);
  recv_sai_thrift_get_ipmc_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_ipmc_group_attribute(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_ipmc_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_ipmc_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_ipmc_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_ipmc_group_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_ipmc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_ipmc_group_member(thrift_attr_list);
  return recv_sai_thrift_create_ipmc_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_ipmc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_ipmc_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_ipmc_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_ipmc_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_ipmc_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_ipmc_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_ipmc_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_ipmc_group_member(const sai_thrift_object_id_t member_id)
{
  send_sai_thrift_remove_ipmc_group_member(member_id);
  return recv_sai_thrift_remove_ipmc_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_ipmc_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_ipmc_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_ipmc_group_member_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_ipmc_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_ipmc_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_ipmc_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_ipmc_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_ipmc_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_ipmc_group_member_attribute(member_id, thrift_attr);
  return recv_sai_thrift_set_ipmc_group_member_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_ipmc_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_ipmc_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_ipmc_group_member_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_ipmc_group_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_ipmc_group_member_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_ipmc_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t member_id)
{
  send_sai_thrift_get_ipmc_group_member_attribute(member_id);
  recv_sai_thrift_get_ipmc_group_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_ipmc_group_member_attribute(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_ipmc_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_ipmc_group_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_ipmc_group_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_ipmc_group_member_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_rpf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_rpf_group(thrift_attr_list);
  return recv_sai_thrift_create_rpf_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_rpf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_rpf_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_rpf_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_rpf_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_rpf_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_rpf_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_rpf_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_rpf_group(const sai_thrift_object_id_t grp_id)
{
  send_sai_thrift_remove_rpf_group(grp_id);
  return recv_sai_thrift_remove_rpf_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_rpf_group(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_rpf_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_rpf_group_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_rpf_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_rpf_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_rpf_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_rpf_group failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_rpf_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t grp_id)
{
  send_sai_thrift_get_rpf_group_attribute(grp_id);
  recv_sai_thrift_get_rpf_group_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_rpf_group_attribute(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_rpf_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_rpf_group_attribute_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_rpf_group_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_rpf_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_rpf_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_rpf_group_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_rpf_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_rpf_group_member(thrift_attr_list);
  return recv_sai_thrift_create_rpf_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_rpf_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_rpf_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_rpf_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_rpf_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_rpf_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_rpf_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_rpf_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_rpf_group_member(const sai_thrift_object_id_t member_id)
{
  send_sai_thrift_remove_rpf_group_member(member_id);
  return recv_sai_thrift_remove_rpf_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_rpf_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_rpf_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_rpf_group_member_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_rpf_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_rpf_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_rpf_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_rpf_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_rpf_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_rpf_group_member_attribute(member_id, thrift_attr);
  return recv_sai_thrift_set_rpf_group_member_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_rpf_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_rpf_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_rpf_group_member_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_rpf_group_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_rpf_group_member_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_rpf_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t member_id)
{
  send_sai_thrift_get_rpf_group_member_attribute(member_id);
  recv_sai_thrift_get_rpf_group_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_rpf_group_member_attribute(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_rpf_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_rpf_group_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_rpf_group_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_rpf_group_member_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_ipmc_entry(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_ipmc_entry(thrift_ipmc_entry, thrift_attr_list);
  return recv_sai_thrift_create_ipmc_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_ipmc_entry(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_ipmc_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_ipmc_entry_pargs args;
  args.thrift_ipmc_entry = &thrift_ipmc_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_ipmc_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_ipmc_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_ipmc_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_ipmc_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_ipmc_entry(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry)
{
  send_sai_thrift_remove_ipmc_entry(thrift_ipmc_entry);
  return recv_sai_thrift_remove_ipmc_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_ipmc_entry(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_ipmc_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_ipmc_entry_pargs args;
  args.thrift_ipmc_entry = &thrift_ipmc_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_ipmc_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_ipmc_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_ipmc_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_ipmc_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_ipmc_entry_attribute(thrift_ipmc_entry, thrift_attr);
  return recv_sai_thrift_set_ipmc_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_ipmc_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_pargs args;
  args.thrift_ipmc_entry = &thrift_ipmc_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_ipmc_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_ipmc_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_ipmc_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_ipmc_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_ipmc_entry_t& thrift_ipmc_entry)
{
  send_sai_thrift_get_ipmc_entry_attribute(thrift_ipmc_entry);
  recv_sai_thrift_get_ipmc_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_ipmc_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_pargs args;
  args.thrift_ipmc_entry = &thrift_ipmc_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_ipmc_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_ipmc_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_ipmc_entry_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_samplepacket(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_samplepacket(thrift_attr_list);
  return recv_sai_thrift_create_samplepacket();
}

void switch_sai_rpcClient::send_sai_thrift_create_samplepacket(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_samplepacket", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_samplepacket_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_samplepacket()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_samplepacket") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_samplepacket_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_samplepacket failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_samplepacket(const sai_thrift_object_id_t samplepacket_id)
{
  send_sai_thrift_remove_samplepacket(samplepacket_id);
  return recv_sai_thrift_remove_samplepacket();
}

void switch_sai_rpcClient::send_sai_thrift_remove_samplepacket(const sai_thrift_object_id_t samplepacket_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_samplepacket", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_samplepacket_pargs args;
  args.samplepacket_id = &samplepacket_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_samplepacket()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_samplepacket") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_samplepacket_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_samplepacket failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_samplepacket_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t samplepacket_id)
{
  send_sai_thrift_get_samplepacket_attribute(samplepacket_id);
  recv_sai_thrift_get_samplepacket_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_samplepacket_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_samplepacket_attribute_pargs args;
  args.samplepacket_id = &samplepacket_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_samplepacket_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_samplepacket_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_samplepacket_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_samplepacket_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_samplepacket_attribute(samplepacket_id, thrift_attr);
  return recv_sai_thrift_set_samplepacket_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_samplepacket_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_samplepacket_attribute_pargs args;
  args.samplepacket_id = &samplepacket_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_samplepacket_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_samplepacket_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_samplepacket_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_samplepacket_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_tunnel_map_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_tunnel_map_entry(thrift_attr_list);
  return recv_sai_thrift_create_tunnel_map_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_tunnel_map_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_tunnel_map_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_map_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_tunnel_map_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_tunnel_map_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_tunnel_map_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel_map_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_tunnel_map_entry(const sai_thrift_object_id_t tunnel_map_entry_id)
{
  send_sai_thrift_remove_tunnel_map_entry(tunnel_map_entry_id);
  return recv_sai_thrift_remove_tunnel_map_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_tunnel_map_entry(const sai_thrift_object_id_t tunnel_map_entry_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel_map_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_pargs args;
  args.tunnel_map_entry_id = &tunnel_map_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_tunnel_map_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_tunnel_map_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel_map_entry failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_tunnel_map_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t tunnel_map_entry_id)
{
  send_sai_thrift_get_tunnel_map_entry_attribute(tunnel_map_entry_id);
  recv_sai_thrift_get_tunnel_map_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_map_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_pargs args;
  args.tunnel_map_entry_id = &tunnel_map_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_tunnel_map_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_tunnel_map_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_map_entry_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_tunnel_map_entry_attribute(tunnel_map_entry_id, thrift_attr);
  return recv_sai_thrift_set_tunnel_map_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_tunnel_map_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_pargs args;
  args.tunnel_map_entry_id = &tunnel_map_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_tunnel_map_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_tunnel_map_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_tunnel_map_entry_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_tunnel_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_tunnel_map(thrift_attr_list);
  return recv_sai_thrift_create_tunnel_map();
}

void switch_sai_rpcClient::send_sai_thrift_create_tunnel_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_tunnel_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_map_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_tunnel_map()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_tunnel_map") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_tunnel_map_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel_map failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_tunnel_map(const sai_thrift_object_id_t tunnel_map_id)
{
  send_sai_thrift_remove_tunnel_map(tunnel_map_id);
  return recv_sai_thrift_remove_tunnel_map();
}

void switch_sai_rpcClient::send_sai_thrift_remove_tunnel_map(const sai_thrift_object_id_t tunnel_map_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_map_pargs args;
  args.tunnel_map_id = &tunnel_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_tunnel_map()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_tunnel_map") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_tunnel_map_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel_map failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_tunnel_map_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t tunnel_map_id)
{
  send_sai_thrift_get_tunnel_map_attribute(tunnel_map_id);
  recv_sai_thrift_get_tunnel_map_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_map_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_pargs args;
  args.tunnel_map_id = &tunnel_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_tunnel_map_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_tunnel_map_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_map_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_tunnel_map_attribute(tunnel_map_id, thrift_attr);
  return recv_sai_thrift_set_tunnel_map_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_tunnel_map_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_pargs args;
  args.tunnel_map_id = &tunnel_map_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_tunnel_map_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_tunnel_map_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_tunnel_map_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_tunnel(thrift_attr_list);
  return recv_sai_thrift_create_tunnel();
}

void switch_sai_rpcClient::send_sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_tunnel", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_tunnel()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_tunnel") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_tunnel_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_tunnel(const sai_thrift_object_id_t tunnel_id)
{
  send_sai_thrift_remove_tunnel(tunnel_id);
  return recv_sai_thrift_remove_tunnel();
}

void switch_sai_rpcClient::send_sai_thrift_remove_tunnel(const sai_thrift_object_id_t tunnel_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_pargs args;
  args.tunnel_id = &tunnel_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_tunnel()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_tunnel") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_tunnel_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_tunnel_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t tunnel_id, const std::vector<int32_t> & thrift_attr_ids)
{
  send_sai_thrift_get_tunnel_attribute(tunnel_id, thrift_attr_ids);
  recv_sai_thrift_get_tunnel_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_tunnel_attribute(const sai_thrift_object_id_t tunnel_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_attribute_pargs args;
  args.tunnel_id = &tunnel_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_tunnel_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_tunnel_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_tunnel_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_tunnel_attribute(const sai_thrift_object_id_t tunnel_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_tunnel_attribute(tunnel_id, thrift_attr);
  return recv_sai_thrift_set_tunnel_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_tunnel_attribute(const sai_thrift_object_id_t tunnel_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_tunnel_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_tunnel_attribute_pargs args;
  args.tunnel_id = &tunnel_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_tunnel_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_tunnel_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_tunnel_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_tunnel_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_tunnel_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t tunnel_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_tunnel_stats(tunnel_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_tunnel_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_tunnel_stats(const sai_thrift_object_id_t tunnel_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_stats_pargs args;
  args.tunnel_id = &tunnel_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_tunnel_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_tunnel_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_tunnel_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_tunnel_stats(const sai_thrift_object_id_t tunnel_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_clear_tunnel_stats(tunnel_id, counter_ids, number_of_counters);
  return recv_sai_thrift_clear_tunnel_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_tunnel_stats(const sai_thrift_object_id_t tunnel_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_tunnel_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_tunnel_stats_pargs args;
  args.tunnel_id = &tunnel_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_tunnel_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_tunnel_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_tunnel_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_tunnel_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_tunnel_term_table_entry(thrift_attr_list);
  return recv_sai_thrift_create_tunnel_term_table_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_tunnel_term_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_tunnel_term_table_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_tunnel_term_table_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel_term_table_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t tunnel_term_table_entry_id)
{
  send_sai_thrift_remove_tunnel_term_table_entry(tunnel_term_table_entry_id);
  return recv_sai_thrift_remove_tunnel_term_table_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t tunnel_term_table_entry_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel_term_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs args;
  args.tunnel_term_table_entry_id = &tunnel_term_table_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_tunnel_term_table_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_tunnel_term_table_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel_term_table_entry failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_tunnel_term_table_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t tunnel_term_table_entry_id, const std::vector<int32_t> & thrift_attr_ids)
{
  send_sai_thrift_get_tunnel_term_table_entry_attribute(tunnel_term_table_entry_id, thrift_attr_ids);
  recv_sai_thrift_get_tunnel_term_table_entry_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_term_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_pargs args;
  args.tunnel_term_table_entry_id = &tunnel_term_table_entry_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_tunnel_term_table_entry_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_tunnel_term_table_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_term_table_entry_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_tunnel_term_table_entry_attribute(tunnel_term_table_entry_id, thrift_attr);
  return recv_sai_thrift_set_tunnel_term_table_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_tunnel_term_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_pargs args;
  args.tunnel_term_table_entry_id = &tunnel_term_table_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_tunnel_term_table_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_tunnel_term_table_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_tunnel_term_table_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_cpu_packet_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t switch_id)
{
  send_sai_thrift_get_cpu_packet_attribute(switch_id);
  recv_sai_thrift_get_cpu_packet_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_cpu_packet_attribute(const sai_thrift_object_id_t switch_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_cpu_packet_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_pargs args;
  args.switch_id = &switch_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_cpu_packet_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_cpu_packet_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_cpu_packet_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_cpu_packet_count(sai_thrift_result_t& _return)
{
  send_sai_thrift_get_cpu_packet_count();
  recv_sai_thrift_get_cpu_packet_count(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_cpu_packet_count()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_cpu_packet_count", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_cpu_packet_count_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_cpu_packet_count(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_cpu_packet_count") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_cpu_packet_count_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_cpu_packet_count failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_clear_cpu_packet_info(sai_thrift_result_t& _return)
{
  send_sai_thrift_clear_cpu_packet_info();
  recv_sai_thrift_clear_cpu_packet_info(_return);
}

void switch_sai_rpcClient::send_sai_thrift_clear_cpu_packet_info()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_cpu_packet_info", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_cpu_packet_info_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_clear_cpu_packet_info(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_cpu_packet_info") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_clear_cpu_packet_info_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_cpu_packet_info failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_log_set(const int32_t sai_api_id, const int32_t log_level)
{
  send_sai_thrift_log_set(sai_api_id, log_level);
  return recv_sai_thrift_log_set();
}

void switch_sai_rpcClient::send_sai_thrift_log_set(const int32_t sai_api_id, const int32_t log_level)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_log_set", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_log_set_pargs args;
  args.sai_api_id = &sai_api_id;
  args.log_level = &log_level;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_log_set()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_log_set") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_log_set_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_log_set failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_isolation_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_isolation_group(thrift_attr_list);
  return recv_sai_thrift_create_isolation_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_isolation_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_isolation_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_isolation_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_isolation_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_isolation_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_isolation_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_isolation_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_isolation_group(const sai_thrift_object_id_t iso_group_oid)
{
  send_sai_thrift_remove_isolation_group(iso_group_oid);
  return recv_sai_thrift_remove_isolation_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_isolation_group(const sai_thrift_object_id_t iso_group_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_isolation_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_isolation_group_pargs args;
  args.iso_group_oid = &iso_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_isolation_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_isolation_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_isolation_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_isolation_group failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_isolation_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_isolation_group_member(thrift_attr_list);
  return recv_sai_thrift_create_isolation_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_isolation_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_isolation_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_isolation_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_isolation_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_isolation_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_isolation_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_isolation_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_isolation_group_member(const sai_thrift_object_id_t member_oid)
{
  send_sai_thrift_remove_isolation_group_member(member_oid);
  return recv_sai_thrift_remove_isolation_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_isolation_group_member(const sai_thrift_object_id_t member_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_isolation_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_isolation_group_member_pargs args;
  args.member_oid = &member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_isolation_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_isolation_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_isolation_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_isolation_group_member failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_isolation_group_attributes(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t iso_group_oid)
{
  send_sai_thrift_get_isolation_group_attributes(iso_group_oid);
  recv_sai_thrift_get_isolation_group_attributes(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_isolation_group_attributes(const sai_thrift_object_id_t iso_group_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_isolation_group_attributes", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_isolation_group_attributes_pargs args;
  args.iso_group_oid = &iso_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_isolation_group_attributes(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_isolation_group_attributes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_isolation_group_attributes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_isolation_group_attributes failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_isolation_group_member_attributes(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t member_oid)
{
  send_sai_thrift_get_isolation_group_member_attributes(member_oid);
  recv_sai_thrift_get_isolation_group_member_attributes(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_isolation_group_member_attributes(const sai_thrift_object_id_t member_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_isolation_group_member_attributes", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_pargs args;
  args.member_oid = &member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_isolation_group_member_attributes(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_isolation_group_member_attributes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_isolation_group_member_attributes failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_counter(thrift_attr_list);
  return recv_sai_thrift_create_counter();
}

void switch_sai_rpcClient::send_sai_thrift_create_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_counter failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_counter(const sai_thrift_object_id_t counter_oid)
{
  send_sai_thrift_remove_counter(counter_oid);
  return recv_sai_thrift_remove_counter();
}

void switch_sai_rpcClient::send_sai_thrift_remove_counter(const sai_thrift_object_id_t counter_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_counter_pargs args;
  args.counter_oid = &counter_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_counter failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_counter_attribute(const sai_thrift_object_id_t thrift_counter_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_counter_attribute(thrift_counter_id, thrift_attr);
  return recv_sai_thrift_set_counter_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_counter_attribute(const sai_thrift_object_id_t thrift_counter_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_counter_attribute_pargs args;
  args.thrift_counter_id = &thrift_counter_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_counter_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_counter_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_counter_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_counter_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_counter_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_counter_id)
{
  send_sai_thrift_get_counter_attribute(thrift_counter_id);
  recv_sai_thrift_get_counter_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_counter_attribute(const sai_thrift_object_id_t thrift_counter_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_counter_attribute_pargs args;
  args.thrift_counter_id = &thrift_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_counter_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_counter_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_counter_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_counter_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_counter_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_counter_stats(counter_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_counter_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_counter_stats(const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_counter_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_counter_stats_pargs args;
  args.counter_id = &counter_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_counter_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_counter_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_counter_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_counter_stats failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_counter_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  send_sai_thrift_get_counter_stats_ext(counter_id, counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_counter_stats_ext(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_counter_stats_ext(const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_counter_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_counter_stats_ext_pargs args;
  args.counter_id = &counter_id;
  args.counter_ids = &counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_counter_stats_ext(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_counter_stats_ext") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_counter_stats_ext_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_counter_stats_ext failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_counter_stats(const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_clear_counter_stats(counter_id, thrift_counter_ids, number_of_counters);
  return recv_sai_thrift_clear_counter_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_counter_stats(const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_counter_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_counter_stats_pargs args;
  args.counter_id = &counter_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_counter_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_counter_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_counter_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_counter_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_debug_counter(thrift_attr_list);
  return recv_sai_thrift_create_debug_counter();
}

void switch_sai_rpcClient::send_sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_debug_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_debug_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_debug_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_debug_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_debug_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_debug_counter failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_debug_counter(const sai_thrift_object_id_t debug_counter_oid)
{
  send_sai_thrift_remove_debug_counter(debug_counter_oid);
  return recv_sai_thrift_remove_debug_counter();
}

void switch_sai_rpcClient::send_sai_thrift_remove_debug_counter(const sai_thrift_object_id_t debug_counter_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_debug_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_debug_counter_pargs args;
  args.debug_counter_oid = &debug_counter_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_debug_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_debug_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_debug_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_debug_counter failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t thrift_debug_counter_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_debug_counter_attribute(thrift_debug_counter_id, thrift_attr);
  return recv_sai_thrift_set_debug_counter_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t thrift_debug_counter_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_debug_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs args;
  args.thrift_debug_counter_id = &thrift_debug_counter_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_debug_counter_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_debug_counter_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_debug_counter_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_debug_counter_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_debug_counter_id)
{
  send_sai_thrift_get_debug_counter_attribute(thrift_debug_counter_id);
  recv_sai_thrift_get_debug_counter_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_debug_counter_attribute(const sai_thrift_object_id_t thrift_debug_counter_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_debug_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_debug_counter_attribute_pargs args;
  args.thrift_debug_counter_id = &thrift_debug_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_debug_counter_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_debug_counter_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_debug_counter_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_debug_counter_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_nat(const sai_thrift_nat_entry_t& thrift_nat_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_nat(thrift_nat_entry, thrift_attr_list);
  return recv_sai_thrift_create_nat();
}

void switch_sai_rpcClient::send_sai_thrift_create_nat(const sai_thrift_nat_entry_t& thrift_nat_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_nat", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_nat_pargs args;
  args.thrift_nat_entry = &thrift_nat_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_nat()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_nat") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_nat_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_nat failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_nat(const sai_thrift_nat_entry_t& thrift_nat_entry)
{
  send_sai_thrift_remove_nat(thrift_nat_entry);
  return recv_sai_thrift_remove_nat();
}

void switch_sai_rpcClient::send_sai_thrift_remove_nat(const sai_thrift_nat_entry_t& thrift_nat_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_nat", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_nat_pargs args;
  args.thrift_nat_entry = &thrift_nat_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_nat()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_nat") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_nat_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_nat failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_nat_attribute(const sai_thrift_nat_entry_t& thrift_nat_entry, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_nat_attribute(thrift_nat_entry, thrift_attr);
  return recv_sai_thrift_set_nat_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_nat_attribute(const sai_thrift_nat_entry_t& thrift_nat_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_nat_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_nat_attribute_pargs args;
  args.thrift_nat_entry = &thrift_nat_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_nat_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_nat_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_nat_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_nat_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_nat_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_nat_entry_t& thrift_nat_entry)
{
  send_sai_thrift_get_nat_attribute(thrift_nat_entry);
  recv_sai_thrift_get_nat_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_nat_attribute(const sai_thrift_nat_entry_t& thrift_nat_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_nat_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_nat_attribute_pargs args;
  args.thrift_nat_entry = &thrift_nat_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_nat_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_nat_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_nat_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_nat_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_bfd(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_bfd(thrift_attr_list);
  return recv_sai_thrift_create_bfd();
}

void switch_sai_rpcClient::send_sai_thrift_create_bfd(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_bfd", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bfd_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_bfd()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_bfd") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_bfd_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bfd failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_bfd(const sai_thrift_object_id_t bfd_oid)
{
  send_sai_thrift_remove_bfd(bfd_oid);
  return recv_sai_thrift_remove_bfd();
}

void switch_sai_rpcClient::send_sai_thrift_remove_bfd(const sai_thrift_object_id_t bfd_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_bfd", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bfd_pargs args;
  args.bfd_oid = &bfd_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_bfd()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_bfd") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_bfd_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bfd failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_bfd_attribute(const sai_thrift_object_id_t bfd_oid, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_bfd_attribute(bfd_oid, thrift_attr);
  return recv_sai_thrift_set_bfd_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_bfd_attribute(const sai_thrift_object_id_t bfd_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_bfd_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_bfd_attribute_pargs args;
  args.bfd_oid = &bfd_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_bfd_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_bfd_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_bfd_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_bfd_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_bfd_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t bfd_oid)
{
  send_sai_thrift_get_bfd_attribute(bfd_oid);
  recv_sai_thrift_get_bfd_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_bfd_attribute(const sai_thrift_object_id_t bfd_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_bfd_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bfd_attribute_pargs args;
  args.bfd_oid = &bfd_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_bfd_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_bfd_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_bfd_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bfd_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_y1731_meg(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_y1731_meg(thrift_attr_list);
  return recv_sai_thrift_create_y1731_meg();
}

void switch_sai_rpcClient::send_sai_thrift_create_y1731_meg(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_y1731_meg", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_y1731_meg_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_y1731_meg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_y1731_meg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_y1731_meg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_y1731_meg failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_y1731_meg(const sai_thrift_object_id_t y1731_meg_oid)
{
  send_sai_thrift_remove_y1731_meg(y1731_meg_oid);
  return recv_sai_thrift_remove_y1731_meg();
}

void switch_sai_rpcClient::send_sai_thrift_remove_y1731_meg(const sai_thrift_object_id_t y1731_meg_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_y1731_meg", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_y1731_meg_pargs args;
  args.y1731_meg_oid = &y1731_meg_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_y1731_meg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_y1731_meg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_y1731_meg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_y1731_meg failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_y1731_meg_attribute(const sai_thrift_object_id_t y1731_meg_oid, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_y1731_meg_attribute(y1731_meg_oid, thrift_attr);
  return recv_sai_thrift_set_y1731_meg_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_y1731_meg_attribute(const sai_thrift_object_id_t y1731_meg_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_y1731_meg_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_pargs args;
  args.y1731_meg_oid = &y1731_meg_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_y1731_meg_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_y1731_meg_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_y1731_meg_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_y1731_meg_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t y1731_meg_oid)
{
  send_sai_thrift_get_y1731_meg_attribute(y1731_meg_oid);
  recv_sai_thrift_get_y1731_meg_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_y1731_meg_attribute(const sai_thrift_object_id_t y1731_meg_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_y1731_meg_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_pargs args;
  args.y1731_meg_oid = &y1731_meg_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_y1731_meg_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_y1731_meg_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_y1731_meg_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_y1731_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_y1731_session(thrift_attr_list);
  return recv_sai_thrift_create_y1731_session();
}

void switch_sai_rpcClient::send_sai_thrift_create_y1731_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_y1731_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_y1731_session_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_y1731_session()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_y1731_session") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_y1731_session_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_y1731_session failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_y1731_session(const sai_thrift_object_id_t y1731_session_oid)
{
  send_sai_thrift_remove_y1731_session(y1731_session_oid);
  return recv_sai_thrift_remove_y1731_session();
}

void switch_sai_rpcClient::send_sai_thrift_remove_y1731_session(const sai_thrift_object_id_t y1731_session_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_y1731_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_y1731_session_pargs args;
  args.y1731_session_oid = &y1731_session_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_y1731_session()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_y1731_session") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_y1731_session_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_y1731_session failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_y1731_session_attribute(const sai_thrift_object_id_t y1731_session_oid, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_y1731_session_attribute(y1731_session_oid, thrift_attr);
  return recv_sai_thrift_set_y1731_session_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_y1731_session_attribute(const sai_thrift_object_id_t y1731_session_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_y1731_session_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_y1731_session_attribute_pargs args;
  args.y1731_session_oid = &y1731_session_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_y1731_session_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_y1731_session_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_y1731_session_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_y1731_session_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_y1731_session_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t y1731_session_oid)
{
  send_sai_thrift_get_y1731_session_attribute(y1731_session_oid);
  recv_sai_thrift_get_y1731_session_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_y1731_session_attribute(const sai_thrift_object_id_t y1731_session_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_y1731_session_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_y1731_session_attribute_pargs args;
  args.y1731_session_oid = &y1731_session_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_y1731_session_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_y1731_session_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_y1731_session_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_y1731_session_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_y1731_rmep(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_y1731_rmep(thrift_attr_list);
  return recv_sai_thrift_create_y1731_rmep();
}

void switch_sai_rpcClient::send_sai_thrift_create_y1731_rmep(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_y1731_rmep", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_y1731_rmep_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_y1731_rmep()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_y1731_rmep") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_y1731_rmep_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_y1731_rmep failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_y1731_rmep(const sai_thrift_object_id_t y1731_rmep_oid)
{
  send_sai_thrift_remove_y1731_rmep(y1731_rmep_oid);
  return recv_sai_thrift_remove_y1731_rmep();
}

void switch_sai_rpcClient::send_sai_thrift_remove_y1731_rmep(const sai_thrift_object_id_t y1731_rmep_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_y1731_rmep", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_y1731_rmep_pargs args;
  args.y1731_rmep_oid = &y1731_rmep_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_y1731_rmep()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_y1731_rmep") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_y1731_rmep_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_y1731_rmep failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_y1731_rmep_attribute(const sai_thrift_object_id_t y1731_rmep_oid, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_y1731_rmep_attribute(y1731_rmep_oid, thrift_attr);
  return recv_sai_thrift_set_y1731_rmep_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_y1731_rmep_attribute(const sai_thrift_object_id_t y1731_rmep_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_y1731_rmep_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_pargs args;
  args.y1731_rmep_oid = &y1731_rmep_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_y1731_rmep_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_y1731_rmep_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_y1731_rmep_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_y1731_rmep_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t y1731_rmep_oid)
{
  send_sai_thrift_get_y1731_rmep_attribute(y1731_rmep_oid);
  recv_sai_thrift_get_y1731_rmep_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_y1731_rmep_attribute(const sai_thrift_object_id_t y1731_rmep_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_y1731_rmep_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_pargs args;
  args.y1731_rmep_oid = &y1731_rmep_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_y1731_rmep_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_y1731_rmep_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_y1731_rmep_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_y1731_session_lm_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t y1731_session_oid, const std::vector<sai_thrift_stat_id_t> & lm_stats_ids, const int32_t number_of_stats)
{
  send_sai_thrift_get_y1731_session_lm_stats(y1731_session_oid, lm_stats_ids, number_of_stats);
  recv_sai_thrift_get_y1731_session_lm_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_y1731_session_lm_stats(const sai_thrift_object_id_t y1731_session_oid, const std::vector<sai_thrift_stat_id_t> & lm_stats_ids, const int32_t number_of_stats)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_y1731_session_lm_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_pargs args;
  args.y1731_session_oid = &y1731_session_oid;
  args.lm_stats_ids = &lm_stats_ids;
  args.number_of_stats = &number_of_stats;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_y1731_session_lm_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_y1731_session_lm_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_y1731_session_lm_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_port(const std::string& port_name, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_port(port_name, thrift_attr_list);
  return recv_sai_thrift_create_port();
}

void switch_sai_rpcClient::send_sai_thrift_create_port(const std::string& port_name, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_port_pargs args;
  args.port_name = &port_name;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_port()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_port failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_port(const sai_thrift_object_id_t port_oid)
{
  send_sai_thrift_remove_port(port_oid);
  return recv_sai_thrift_remove_port();
}

void switch_sai_rpcClient::send_sai_thrift_remove_port(const sai_thrift_object_id_t port_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_port_pargs args;
  args.port_oid = &port_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_port()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_port failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_ptp_domain(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_ptp_domain(thrift_attr_list);
  return recv_sai_thrift_create_ptp_domain();
}

void switch_sai_rpcClient::send_sai_thrift_create_ptp_domain(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_ptp_domain", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_ptp_domain_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_ptp_domain()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_ptp_domain") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_ptp_domain_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_ptp_domain failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_ptp_domain(const sai_thrift_object_id_t ptp_oid)
{
  send_sai_thrift_remove_ptp_domain(ptp_oid);
  return recv_sai_thrift_remove_ptp_domain();
}

void switch_sai_rpcClient::send_sai_thrift_remove_ptp_domain(const sai_thrift_object_id_t ptp_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_ptp_domain", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_ptp_domain_pargs args;
  args.ptp_oid = &ptp_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_ptp_domain()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_ptp_domain") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_ptp_domain_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_ptp_domain failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_ptp_domain_attribute(const sai_thrift_object_id_t ptp_oid, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_ptp_domain_attribute(ptp_oid, thrift_attr);
  return recv_sai_thrift_set_ptp_domain_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_ptp_domain_attribute(const sai_thrift_object_id_t ptp_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_ptp_domain_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_pargs args;
  args.ptp_oid = &ptp_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_ptp_domain_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_ptp_domain_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_ptp_domain_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_ptp_domain_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t ptp_oid)
{
  send_sai_thrift_get_ptp_domain_attribute(ptp_oid);
  recv_sai_thrift_get_ptp_domain_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_ptp_domain_attribute(const sai_thrift_object_id_t ptp_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_ptp_domain_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_pargs args;
  args.ptp_oid = &ptp_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_ptp_domain_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_ptp_domain_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_ptp_domain_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_es(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_es(thrift_attr_list);
  return recv_sai_thrift_create_es();
}

void switch_sai_rpcClient::send_sai_thrift_create_es(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_es", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_es_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_es()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_es") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_es_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_es failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_es(const sai_thrift_object_id_t es_oid)
{
  send_sai_thrift_remove_es(es_oid);
  return recv_sai_thrift_remove_es();
}

void switch_sai_rpcClient::send_sai_thrift_remove_es(const sai_thrift_object_id_t es_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_es", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_es_pargs args;
  args.es_oid = &es_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_es()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_es") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_es_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_es failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_es_attribute(const sai_thrift_object_id_t es_oid, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_es_attribute(es_oid, thrift_attr);
  return recv_sai_thrift_set_es_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_es_attribute(const sai_thrift_object_id_t es_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_es_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_es_attribute_pargs args;
  args.es_oid = &es_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_es_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_es_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_es_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_es_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_es_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t es_oid)
{
  send_sai_thrift_get_es_attribute(es_oid);
  recv_sai_thrift_get_es_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_es_attribute(const sai_thrift_object_id_t es_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_es_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_es_attribute_pargs args;
  args.es_oid = &es_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_es_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_es_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_es_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_es_attribute failed: unknown result");
}

bool switch_sai_rpcProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void switch_sai_rpcProcessor::process_sai_thrift_set_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_port_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute");
  }

  switch_sai_rpc_sai_thrift_set_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_port_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_port_attribute(args.port_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute");
  }

  switch_sai_rpc_sai_thrift_get_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_attribute_result result;
  try {
    iface_->sai_thrift_get_port_attribute(result.success, args.port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_stats");
  }

  switch_sai_rpc_sai_thrift_get_port_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_stats_result result;
  try {
    iface_->sai_thrift_get_port_stats(result.success, args.port_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_stats_ext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_stats_ext", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_stats_ext");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_stats_ext");
  }

  switch_sai_rpc_sai_thrift_get_port_stats_ext_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_stats_ext", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_stats_ext_result result;
  try {
    iface_->sai_thrift_get_port_stats_ext(result.success, args.port_id, args.counter_ids, args.mode, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_stats_ext");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_stats_ext", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_stats_ext");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_stats_ext", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_stats_ext", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_port_all_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_port_all_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats");
  }

  switch_sai_rpc_sai_thrift_clear_port_all_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_port_all_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_port_all_stats(args.port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_port_all_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_port_all_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_port_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_port_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_port_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_port_stats");
  }

  switch_sai_rpc_sai_thrift_clear_port_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_port_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_port_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_port_stats(args.port_id, args.number_of_counters, args.counter_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_port_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_port_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_port_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_port_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_port_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_fdb_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_fdb_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry");
  }

  switch_sai_rpc_sai_thrift_create_fdb_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_fdb_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_fdb_entry(args.thrift_fdb_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_fdb_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_fdb_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_delete_fdb_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_delete_fdb_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry");
  }

  switch_sai_rpc_sai_thrift_delete_fdb_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_delete_fdb_entry_result result;
  try {
    result.success = iface_->sai_thrift_delete_fdb_entry(args.thrift_fdb_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_delete_fdb_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry");
  }

  oprot->writeMessageBegin("sai_thrift_delete_fdb_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_flush_fdb_entries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_flush_fdb_entries", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries");
  }

  switch_sai_rpc_sai_thrift_flush_fdb_entries_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries", bytes);
  }

  switch_sai_rpc_sai_thrift_flush_fdb_entries_result result;
  try {
    result.success = iface_->sai_thrift_flush_fdb_entries(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_flush_fdb_entries", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries");
  }

  oprot->writeMessageBegin("sai_thrift_flush_fdb_entries", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_fdb_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_fdb_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_fdb_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_fdb_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_fdb_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_fdb_entry_attribute(args.thrift_fdb_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_fdb_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_fdb_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_fdb_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_fdb_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_fdb_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_fdb_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_fdb_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_fdb_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_fdb_entry_attribute(result.success, args.thrift_fdb_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_fdb_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_fdb_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_vlan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_vlan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_vlan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan");
  }

  switch_sai_rpc_sai_thrift_create_vlan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan", bytes);
  }

  switch_sai_rpc_sai_thrift_create_vlan_result result;
  try {
    result.success = iface_->sai_thrift_create_vlan(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_vlan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_vlan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan");
  }

  oprot->writeMessageBegin("sai_thrift_create_vlan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_vlan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_vlan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_vlan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan");
  }

  switch_sai_rpc_sai_thrift_remove_vlan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_vlan_result result;
  try {
    result.success = iface_->sai_thrift_remove_vlan(args.vlan_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_vlan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_vlan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan");
  }

  oprot->writeMessageBegin("sai_thrift_remove_vlan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats");
  }

  switch_sai_rpc_sai_thrift_get_vlan_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_stats_result result;
  try {
    iface_->sai_thrift_get_vlan_stats(result.success, args.vlan_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_stats_ext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_stats_ext", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats_ext");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats_ext");
  }

  switch_sai_rpc_sai_thrift_get_vlan_stats_ext_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats_ext", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_stats_ext_result result;
  try {
    iface_->sai_thrift_get_vlan_stats_ext(result.success, args.vlan_id, args.thrift_counter_ids, args.mode, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats_ext");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_stats_ext", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats_ext");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_stats_ext", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats_ext", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_vlan_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_vlan_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_vlan_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_vlan_stats");
  }

  switch_sai_rpc_sai_thrift_clear_vlan_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_vlan_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_vlan_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_vlan_stats(args.vlan_id, args.thrift_counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_vlan_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_vlan_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_vlan_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_vlan_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_vlan_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_vlan_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_vlan_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_vlan_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member");
  }

  switch_sai_rpc_sai_thrift_create_vlan_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_vlan_member_result result;
  try {
    result.success = iface_->sai_thrift_create_vlan_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_vlan_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_vlan_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result result;
  try {
    iface_->sai_thrift_get_vlan_member_attribute(result.success, args.vlan_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_vlan_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_vlan_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member");
  }

  switch_sai_rpc_sai_thrift_remove_vlan_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_vlan_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_vlan_member(args.vlan_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_vlan_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_vlan_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_vlan_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_vlan_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute");
  }

  switch_sai_rpc_sai_thrift_set_vlan_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_vlan_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_vlan_attribute(args.vlan_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_vlan_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_vlan_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_vlan_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_vlan_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_vlan_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_vlan_member_attribute");
  }

  switch_sai_rpc_sai_thrift_set_vlan_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_vlan_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_vlan_member_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_vlan_member_attribute(args.vlan_member_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_vlan_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_vlan_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_vlan_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_vlan_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_vlan_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute");
  }

  switch_sai_rpc_sai_thrift_get_vlan_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_attribute_result result;
  try {
    iface_->sai_thrift_get_vlan_attribute(result.success, args.vlan_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_id");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id");
  }

  switch_sai_rpc_sai_thrift_get_vlan_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_id_result result;
  try {
    iface_->sai_thrift_get_vlan_id(result.success, args.vlan_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_vlan_members(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_vlan_members", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_vlan_members");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan_members");
  }

  switch_sai_rpc_sai_thrift_create_vlan_members_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan_members", bytes);
  }

  switch_sai_rpc_sai_thrift_create_vlan_members_result result;
  try {
    iface_->sai_thrift_create_vlan_members(result.success, args.thrift_attr_lists, args.thrift_attr_count_lists, args.mode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_vlan_members");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_vlan_members", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan_members");
  }

  oprot->writeMessageBegin("sai_thrift_create_vlan_members", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan_members", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_vlan_members(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_vlan_members", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_vlan_members");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_members");
  }

  switch_sai_rpc_sai_thrift_remove_vlan_members_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_members", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_vlan_members_result result;
  try {
    iface_->sai_thrift_remove_vlan_members(result.success, args.thrift_object_id_list, args.mode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_members");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_vlan_members", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_members");
  }

  oprot->writeMessageBegin("sai_thrift_remove_vlan_members", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_members", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_virtual_router(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_virtual_router", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_virtual_router");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router");
  }

  switch_sai_rpc_sai_thrift_create_virtual_router_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router", bytes);
  }

  switch_sai_rpc_sai_thrift_create_virtual_router_result result;
  try {
    result.success = iface_->sai_thrift_create_virtual_router(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_virtual_router", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router");
  }

  oprot->writeMessageBegin("sai_thrift_create_virtual_router", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_virtual_router(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_virtual_router", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router");
  }

  switch_sai_rpc_sai_thrift_remove_virtual_router_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_virtual_router_result result;
  try {
    result.success = iface_->sai_thrift_remove_virtual_router(args.vr_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_virtual_router", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router");
  }

  oprot->writeMessageBegin("sai_thrift_remove_virtual_router", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_virtual_router_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_virtual_router_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_virtual_router_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_virtual_router_attribute");
  }

  switch_sai_rpc_sai_thrift_set_virtual_router_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_virtual_router_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_virtual_router_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_virtual_router_attribute(args.vr_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_virtual_router_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_virtual_router_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_virtual_router_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_virtual_router_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_virtual_router_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_virtual_router_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_virtual_router_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_virtual_router_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_virtual_router_attribute");
  }

  switch_sai_rpc_sai_thrift_get_virtual_router_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_virtual_router_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_virtual_router_attribute_result result;
  try {
    iface_->sai_thrift_get_virtual_router_attribute(result.success, args.vr_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_virtual_router_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_virtual_router_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_virtual_router_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_virtual_router_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_virtual_router_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_route(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_route", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_route");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_route");
  }

  switch_sai_rpc_sai_thrift_create_route_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_route", bytes);
  }

  switch_sai_rpc_sai_thrift_create_route_result result;
  try {
    result.success = iface_->sai_thrift_create_route(args.thrift_route_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_route");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_route", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_route");
  }

  oprot->writeMessageBegin("sai_thrift_create_route", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_route", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_route(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_route", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_route");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_route");
  }

  switch_sai_rpc_sai_thrift_remove_route_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_route", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_route_result result;
  try {
    result.success = iface_->sai_thrift_remove_route(args.thrift_route_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_route");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_route", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_route");
  }

  oprot->writeMessageBegin("sai_thrift_remove_route", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_route", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_route_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_route_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_route_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_route_attribute");
  }

  switch_sai_rpc_sai_thrift_set_route_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_route_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_route_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_route_attribute(args.thrift_route_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_route_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_route_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_route_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_route_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_route_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_route_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_route_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_route_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_route_attribute");
  }

  switch_sai_rpc_sai_thrift_get_route_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_route_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_route_attribute_result result;
  try {
    iface_->sai_thrift_get_route_attribute(result.success, args.thrift_route_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_route_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_route_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_route_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_route_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_route_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_routes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_routes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_routes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_routes");
  }

  switch_sai_rpc_sai_thrift_create_routes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_routes", bytes);
  }

  switch_sai_rpc_sai_thrift_create_routes_result result;
  try {
    result.success = iface_->sai_thrift_create_routes(args.thrift_route_entry_list, args.thrift_attr_list, args.thrift_attr_count_lists, args.mode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_routes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_routes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_routes");
  }

  oprot->writeMessageBegin("sai_thrift_create_routes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_routes", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_routes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_routes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_routes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_routes");
  }

  switch_sai_rpc_sai_thrift_remove_routes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_routes", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_routes_result result;
  try {
    result.success = iface_->sai_thrift_remove_routes(args.thrift_route_entry_list, args.mode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_routes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_routes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_routes");
  }

  oprot->writeMessageBegin("sai_thrift_remove_routes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_routes", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_routes_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_routes_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_routes_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_routes_attribute");
  }

  switch_sai_rpc_sai_thrift_set_routes_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_routes_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_routes_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_routes_attribute(args.thrift_route_entry_list, args.thrift_attr_list, args.mode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_routes_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_routes_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_routes_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_routes_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_routes_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_routes_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_routes_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_routes_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_routes_attribute");
  }

  switch_sai_rpc_sai_thrift_get_routes_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_routes_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_routes_attribute_result result;
  try {
    iface_->sai_thrift_get_routes_attribute(result.success, args.thrift_route_entry_list, args.mode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_routes_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_routes_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_routes_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_routes_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_routes_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_router_interface(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_router_interface", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_router_interface");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_router_interface");
  }

  switch_sai_rpc_sai_thrift_create_router_interface_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_router_interface", bytes);
  }

  switch_sai_rpc_sai_thrift_create_router_interface_result result;
  try {
    result.success = iface_->sai_thrift_create_router_interface(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_router_interface");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_router_interface", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_router_interface");
  }

  oprot->writeMessageBegin("sai_thrift_create_router_interface", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_router_interface", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_router_interface(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_router_interface", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_router_interface");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface");
  }

  switch_sai_rpc_sai_thrift_remove_router_interface_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_router_interface_result result;
  try {
    result.success = iface_->sai_thrift_remove_router_interface(args.rif_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_router_interface", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface");
  }

  oprot->writeMessageBegin("sai_thrift_remove_router_interface", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_router_interface_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_router_interface_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute");
  }

  switch_sai_rpc_sai_thrift_set_router_interface_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_router_interface_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_router_interface_attribute(args.rif_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_router_interface_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_router_interface_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_router_interface_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_router_interface_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_router_interface_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_router_interface_attribute");
  }

  switch_sai_rpc_sai_thrift_get_router_interface_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_router_interface_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_router_interface_attribute_result result;
  try {
    iface_->sai_thrift_get_router_interface_attribute(result.success, args.rif_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_router_interface_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_router_interface_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_router_interface_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_router_interface_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_router_interface_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_router_interface_get_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_router_interface_get_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats");
  }

  switch_sai_rpc_sai_thrift_router_interface_get_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_router_interface_get_stats_result result;
  try {
    iface_->sai_thrift_router_interface_get_stats(result.success, args.rif_id, args.thrift_counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_router_interface_get_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats");
  }

  oprot->writeMessageBegin("sai_thrift_router_interface_get_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_router_interface_get_stats_ext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_router_interface_get_stats_ext", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats_ext");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats_ext");
  }

  switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats_ext", bytes);
  }

  switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_result result;
  try {
    iface_->sai_thrift_router_interface_get_stats_ext(result.success, args.rif_id, args.thrift_counter_ids, args.mode, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats_ext");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_router_interface_get_stats_ext", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats_ext");
  }

  oprot->writeMessageBegin("sai_thrift_router_interface_get_stats_ext", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_router_interface_get_stats_ext", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_router_interface_clear_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_router_interface_clear_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_router_interface_clear_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_router_interface_clear_stats");
  }

  switch_sai_rpc_sai_thrift_router_interface_clear_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_router_interface_clear_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_router_interface_clear_stats_result result;
  try {
    result.success = iface_->sai_thrift_router_interface_clear_stats(args.rif_id, args.thrift_counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_router_interface_clear_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_router_interface_clear_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_router_interface_clear_stats");
  }

  oprot->writeMessageBegin("sai_thrift_router_interface_clear_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_router_interface_clear_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_next_hop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_next_hop", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_next_hop");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop");
  }

  switch_sai_rpc_sai_thrift_create_next_hop_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop", bytes);
  }

  switch_sai_rpc_sai_thrift_create_next_hop_result result;
  try {
    result.success = iface_->sai_thrift_create_next_hop(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_next_hop");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_next_hop", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop");
  }

  oprot->writeMessageBegin("sai_thrift_create_next_hop", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_next_hop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_next_hop", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_next_hop");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop");
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_result result;
  try {
    result.success = iface_->sai_thrift_remove_next_hop(args.next_hop_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_next_hop", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop");
  }

  oprot->writeMessageBegin("sai_thrift_remove_next_hop", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_next_hop_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_next_hop_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_next_hop_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_attribute");
  }

  switch_sai_rpc_sai_thrift_get_next_hop_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_next_hop_attribute_result result;
  try {
    iface_->sai_thrift_get_next_hop_attribute(result.success, args.next_hop_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_next_hop_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_next_hop_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_next_hop_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_next_hop_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group");
  }

  switch_sai_rpc_sai_thrift_create_next_hop_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_next_hop_group_result result;
  try {
    result.success = iface_->sai_thrift_create_next_hop_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_next_hop_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_next_hop_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_next_hop_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_next_hop_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group");
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_next_hop_group(args.nhop_group_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_next_hop_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_next_hop_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_next_hop_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_next_hop_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_next_hop_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_next_hop_group_attribute");
  }

  switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_next_hop_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_next_hop_group_attribute(args.nhop_group_oid, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_next_hop_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_next_hop_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_next_hop_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_next_hop_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_next_hop_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_next_hop_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_next_hop_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_result result;
  try {
    iface_->sai_thrift_get_next_hop_group_attribute(result.success, args.nhop_group_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_next_hop_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_next_hop_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_next_hop_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_next_hop_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member");
  }

  switch_sai_rpc_sai_thrift_create_next_hop_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_next_hop_group_member_result result;
  try {
    result.success = iface_->sai_thrift_create_next_hop_group_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_next_hop_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_next_hop_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_next_hop_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_next_hop_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member");
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_next_hop_group_member(args.nhop_group_member_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_next_hop_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_next_hop_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_next_hop_group_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_next_hop_group_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_result result;
  try {
    iface_->sai_thrift_get_next_hop_group_member_attribute(result.success, args.nhop_group_member_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_next_hop_group_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_next_hop_group_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_next_hop_group_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_lag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_lag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_lag");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_lag");
  }

  switch_sai_rpc_sai_thrift_create_lag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_lag", bytes);
  }

  switch_sai_rpc_sai_thrift_create_lag_result result;
  try {
    result.success = iface_->sai_thrift_create_lag(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_lag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_lag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_lag");
  }

  oprot->writeMessageBegin("sai_thrift_create_lag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_lag", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_lag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_lag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_lag");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_lag");
  }

  switch_sai_rpc_sai_thrift_remove_lag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_lag", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_lag_result result;
  try {
    result.success = iface_->sai_thrift_remove_lag(args.lag_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_lag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_lag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_lag");
  }

  oprot->writeMessageBegin("sai_thrift_remove_lag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_lag", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_lag_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_lag_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute");
  }

  switch_sai_rpc_sai_thrift_set_lag_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_lag_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_lag_attribute(args.lag_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_lag_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_lag_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_lag_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_lag_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_lag_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_lag_attribute");
  }

  switch_sai_rpc_sai_thrift_get_lag_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_lag_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_lag_attribute_result result;
  try {
    iface_->sai_thrift_get_lag_attribute(result.success, args.lag_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_lag_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_lag_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_lag_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_lag_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_lag_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_lag_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_lag_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_lag_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_lag_member");
  }

  switch_sai_rpc_sai_thrift_create_lag_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_lag_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_lag_member_result result;
  try {
    result.success = iface_->sai_thrift_create_lag_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_lag_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_lag_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_lag_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_lag_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_lag_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_lag_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_lag_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_lag_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member");
  }

  switch_sai_rpc_sai_thrift_remove_lag_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_lag_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_lag_member(args.lag_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_lag_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_lag_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_lag_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_lag_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_lag_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_lag_member_attribute");
  }

  switch_sai_rpc_sai_thrift_set_lag_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_lag_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_lag_member_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_lag_member_attribute(args.lag_member_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_lag_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_lag_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_lag_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_lag_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_lag_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_lag_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_lag_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_lag_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_lag_member_attribute_result result;
  try {
    iface_->sai_thrift_get_lag_member_attribute(result.success, args.lag_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_lag_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_lag_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_stp_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_stp_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_stp_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry");
  }

  switch_sai_rpc_sai_thrift_create_stp_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_stp_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_stp_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_stp_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_stp_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_stp_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_stp_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry");
  }

  switch_sai_rpc_sai_thrift_remove_stp_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_stp_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_stp_entry(args.stp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_stp_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_stp_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_stp_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_stp_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_stp_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_stp_attribute");
  }

  switch_sai_rpc_sai_thrift_get_stp_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_stp_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_stp_attribute_result result;
  try {
    iface_->sai_thrift_get_stp_attribute(result.success, args.stp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_stp_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_stp_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_stp_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_stp_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_stp_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_stp_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_stp_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_stp_port");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_stp_port");
  }

  switch_sai_rpc_sai_thrift_create_stp_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_stp_port", bytes);
  }

  switch_sai_rpc_sai_thrift_create_stp_port_result result;
  try {
    result.success = iface_->sai_thrift_create_stp_port(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_stp_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_stp_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_stp_port");
  }

  oprot->writeMessageBegin("sai_thrift_create_stp_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_stp_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_stp_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_stp_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_stp_port");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_stp_port");
  }

  switch_sai_rpc_sai_thrift_remove_stp_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_stp_port", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_stp_port_result result;
  try {
    result.success = iface_->sai_thrift_remove_stp_port(args.stp_port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_stp_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_stp_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_stp_port");
  }

  oprot->writeMessageBegin("sai_thrift_remove_stp_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_stp_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_stp_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_stp_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_stp_port_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_attribute");
  }

  switch_sai_rpc_sai_thrift_get_stp_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_stp_port_attribute_result result;
  try {
    iface_->sai_thrift_get_stp_port_attribute(result.success, args.stp_port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_stp_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_stp_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_stp_port_state(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_stp_port_state", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state");
  }

  switch_sai_rpc_sai_thrift_set_stp_port_state_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state", bytes);
  }

  switch_sai_rpc_sai_thrift_set_stp_port_state_result result;
  try {
    result.success = iface_->sai_thrift_set_stp_port_state(args.stp_id, args.port_id, args.stp_port_state);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_stp_port_state", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state");
  }

  oprot->writeMessageBegin("sai_thrift_set_stp_port_state", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_stp_port_state(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_stp_port_state", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state");
  }

  switch_sai_rpc_sai_thrift_get_stp_port_state_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state", bytes);
  }

  switch_sai_rpc_sai_thrift_get_stp_port_state_result result;
  try {
    result.success = iface_->sai_thrift_get_stp_port_state(args.stp_id, args.port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_stp_port_state", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state");
  }

  oprot->writeMessageBegin("sai_thrift_get_stp_port_state", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_stp_ports(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_stp_ports", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_stp_ports");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_stp_ports");
  }

  switch_sai_rpc_sai_thrift_create_stp_ports_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_stp_ports", bytes);
  }

  switch_sai_rpc_sai_thrift_create_stp_ports_result result;
  try {
    iface_->sai_thrift_create_stp_ports(result.success, args.thrift_attr_lists, args.thrift_attr_count_lists, args.mode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_stp_ports");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_stp_ports", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_stp_ports");
  }

  oprot->writeMessageBegin("sai_thrift_create_stp_ports", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_stp_ports", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_stp_ports(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_stp_ports", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_stp_ports");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_stp_ports");
  }

  switch_sai_rpc_sai_thrift_remove_stp_ports_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_stp_ports", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_stp_ports_result result;
  try {
    iface_->sai_thrift_remove_stp_ports(result.success, args.thrift_object_id_list, args.mode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_stp_ports");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_stp_ports", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_stp_ports");
  }

  oprot->writeMessageBegin("sai_thrift_remove_stp_ports", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_stp_ports", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_neighbor_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_neighbor_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry");
  }

  switch_sai_rpc_sai_thrift_create_neighbor_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_neighbor_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_neighbor_entry(args.thrift_neighbor_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_neighbor_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_neighbor_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_neighbor_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_neighbor_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry");
  }

  switch_sai_rpc_sai_thrift_remove_neighbor_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_neighbor_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_neighbor_entry(args.thrift_neighbor_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_neighbor_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_neighbor_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_all_neighbor_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_all_neighbor_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_all_neighbor_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_all_neighbor_entry");
  }

  switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_all_neighbor_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_all_neighbor_entry();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_all_neighbor_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_all_neighbor_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_all_neighbor_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_all_neighbor_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_all_neighbor_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_neighbor_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_neighbor_entry_attribute(args.thrift_neighbor_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_neighbor_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_neighbor_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_neighbor_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_neighbor_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_neighbor_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_neighbor_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_neighbor_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_neighbor_entry_attribute(result.success, args.thrift_neighbor_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_neighbor_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_neighbor_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_neighbor_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_neighbor_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_neighbor_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_switch_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_switch_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute");
  }

  switch_sai_rpc_sai_thrift_get_switch_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_switch_attribute_result result;
  try {
    iface_->sai_thrift_get_switch_attribute(result.success, args.thrift_attr_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_switch_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_switch_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_list_by_front_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_list_by_front_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port");
  }

  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result result;
  try {
    iface_->sai_thrift_get_port_list_by_front_port(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_list_by_front_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_list_by_front_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_cpu_port_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_cpu_port_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id");
  }

  switch_sai_rpc_sai_thrift_get_cpu_port_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_cpu_port_id_result result;
  try {
    result.success = iface_->sai_thrift_get_cpu_port_id();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_cpu_port_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_cpu_port_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_default_trap_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_default_trap_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group");
  }

  switch_sai_rpc_sai_thrift_get_default_trap_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group", bytes);
  }

  switch_sai_rpc_sai_thrift_get_default_trap_group_result result;
  try {
    result.success = iface_->sai_thrift_get_default_trap_group();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_default_trap_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group");
  }

  oprot->writeMessageBegin("sai_thrift_get_default_trap_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_default_router_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_default_router_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_default_router_id");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id");
  }

  switch_sai_rpc_sai_thrift_get_default_router_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_default_router_id_result result;
  try {
    result.success = iface_->sai_thrift_get_default_router_id();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_default_router_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_default_router_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_default_1q_bridge_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_default_1q_bridge_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id");
  }

  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result result;
  try {
    result.success = iface_->sai_thrift_get_default_1q_bridge_id();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_default_1q_bridge_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_default_1q_bridge_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_default_vlan_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_default_vlan_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id");
  }

  switch_sai_rpc_sai_thrift_get_default_vlan_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_default_vlan_id_result result;
  try {
    iface_->sai_thrift_get_default_vlan_id(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_default_vlan_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_default_vlan_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_id_by_front_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_id_by_front_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port");
  }

  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result result;
  try {
    result.success = iface_->sai_thrift_get_port_id_by_front_port(args.port_name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_id_by_front_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_id_by_front_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_switch_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_switch_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute");
  }

  switch_sai_rpc_sai_thrift_set_switch_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_switch_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_switch_attribute(args.attribute);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_switch_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_switch_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_switch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_switch", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_switch");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_switch");
  }

  switch_sai_rpc_sai_thrift_create_switch_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_switch", bytes);
  }

  switch_sai_rpc_sai_thrift_create_switch_result result;
  try {
    result.success = iface_->sai_thrift_create_switch();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_switch");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_switch", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_switch");
  }

  oprot->writeMessageBegin("sai_thrift_create_switch", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_switch", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_switch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_switch", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_switch");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_switch");
  }

  switch_sai_rpc_sai_thrift_remove_switch_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_switch", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_switch_result result;
  try {
    result.success = iface_->sai_thrift_remove_switch();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_switch");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_switch", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_switch");
  }

  oprot->writeMessageBegin("sai_thrift_remove_switch", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_switch", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_switch_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_switch_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_switch_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats");
  }

  switch_sai_rpc_sai_thrift_get_switch_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_switch_stats_result result;
  try {
    iface_->sai_thrift_get_switch_stats(result.success, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_switch_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_switch_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_switch_stats_ext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_switch_stats_ext", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_ext");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_ext");
  }

  switch_sai_rpc_sai_thrift_get_switch_stats_ext_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_ext", bytes);
  }

  switch_sai_rpc_sai_thrift_get_switch_stats_ext_result result;
  try {
    iface_->sai_thrift_get_switch_stats_ext(result.success, args.counter_ids, args.mode, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_ext");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_switch_stats_ext", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_ext");
  }

  oprot->writeMessageBegin("sai_thrift_get_switch_stats_ext", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_ext", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_switch_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_switch_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_switch_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_switch_stats");
  }

  switch_sai_rpc_sai_thrift_clear_switch_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_switch_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_switch_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_switch_stats(args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_switch_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_switch_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_switch_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_switch_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_switch_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_bridge_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_bridge_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_bridge_port");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port");
  }

  switch_sai_rpc_sai_thrift_create_bridge_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port", bytes);
  }

  switch_sai_rpc_sai_thrift_create_bridge_port_result result;
  try {
    iface_->sai_thrift_create_bridge_port(result.success, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_bridge_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port");
  }

  oprot->writeMessageBegin("sai_thrift_create_bridge_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_bridge_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_bridge_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port");
  }

  switch_sai_rpc_sai_thrift_remove_bridge_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_bridge_port_result result;
  try {
    result.success = iface_->sai_thrift_remove_bridge_port(args.bridge_port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_bridge_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port");
  }

  oprot->writeMessageBegin("sai_thrift_remove_bridge_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_bridge_port_list(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_bridge_port_list", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list");
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_list_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list", bytes);
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_list_result result;
  try {
    iface_->sai_thrift_get_bridge_port_list(result.success, args.bridge_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_bridge_port_list", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list");
  }

  oprot->writeMessageBegin("sai_thrift_get_bridge_port_list", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_bridge_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_bridge_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute");
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result result;
  try {
    iface_->sai_thrift_get_bridge_port_attribute(result.success, args.bridge_port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_bridge_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_bridge_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_bridge_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_bridge_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute");
  }

  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_bridge_port_attribute(args.bridge_port_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_bridge_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_bridge_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_bridge(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_bridge", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_bridge");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_bridge");
  }

  switch_sai_rpc_sai_thrift_create_bridge_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_bridge", bytes);
  }

  switch_sai_rpc_sai_thrift_create_bridge_result result;
  try {
    iface_->sai_thrift_create_bridge(result.success, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_bridge");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_bridge", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_bridge");
  }

  oprot->writeMessageBegin("sai_thrift_create_bridge", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_bridge", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_bridge(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_bridge", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_bridge");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_bridge");
  }

  switch_sai_rpc_sai_thrift_remove_bridge_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_bridge", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_bridge_result result;
  try {
    result.success = iface_->sai_thrift_remove_bridge(args.bridge_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_bridge");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_bridge", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bridge");
  }

  oprot->writeMessageBegin("sai_thrift_remove_bridge", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bridge", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_bridge_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_bridge_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_bridge_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_attribute");
  }

  switch_sai_rpc_sai_thrift_get_bridge_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_bridge_attribute_result result;
  try {
    iface_->sai_thrift_get_bridge_attribute(result.success, args.bridge_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_bridge_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_bridge_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_bridge_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_bridge_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_bridge_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_bridge_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_bridge_attribute");
  }

  switch_sai_rpc_sai_thrift_set_bridge_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_bridge_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_bridge_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_bridge_attribute(args.bridge_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_bridge_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_bridge_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_bridge_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_bridge_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_bridge_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_bridge_port_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_bridge_port_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats");
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_stats_result result;
  try {
    iface_->sai_thrift_get_bridge_port_stats(result.success, args.bridge_port_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_bridge_port_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_bridge_port_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_bridge_port_stats_ext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_bridge_port_stats_ext", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats_ext");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats_ext");
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats_ext", bytes);
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_result result;
  try {
    iface_->sai_thrift_get_bridge_port_stats_ext(result.success, args.bridge_port_id, args.thrift_counter_ids, args.mode, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats_ext");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_bridge_port_stats_ext", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats_ext");
  }

  oprot->writeMessageBegin("sai_thrift_get_bridge_port_stats_ext", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_stats_ext", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_bridge_port_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_bridge_port_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_bridge_port_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_bridge_port_stats");
  }

  switch_sai_rpc_sai_thrift_clear_bridge_port_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_bridge_port_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_bridge_port_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_bridge_port_stats(args.bridge_port_id, args.thrift_counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_bridge_port_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_bridge_port_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_bridge_port_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_bridge_port_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_bridge_port_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hostif(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hostif", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hostif");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif");
  }

  switch_sai_rpc_sai_thrift_create_hostif_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hostif_result result;
  try {
    result.success = iface_->sai_thrift_create_hostif(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hostif");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hostif", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif");
  }

  oprot->writeMessageBegin("sai_thrift_create_hostif", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hostif(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hostif", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hostif");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif");
  }

  switch_sai_rpc_sai_thrift_remove_hostif_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hostif_result result;
  try {
    result.success = iface_->sai_thrift_remove_hostif(args.thrift_hif_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hostif");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hostif", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hostif", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_hostif_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_hostif_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_hostif_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_hostif_attribute");
  }

  switch_sai_rpc_sai_thrift_get_hostif_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_hostif_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_hostif_attribute_result result;
  try {
    iface_->sai_thrift_get_hostif_attribute(result.success, args.thrift_hif_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_hostif_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_hostif_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_hostif_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_hostif_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_hostif_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hostif_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hostif_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hostif_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hostif_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hostif_attribute(args.thrift_hif_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hostif_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hostif_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hostif_table_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hostif_table_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry");
  }

  switch_sai_rpc_sai_thrift_create_hostif_table_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hostif_table_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_hostif_table_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hostif_table_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_hostif_table_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hostif_table_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hostif_table_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry");
  }

  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_hostif_table_entry(args.thrift_hostif_table_entry_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hostif_table_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hostif_table_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_hostif_table_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_hostif_table_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_hostif_table_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_hostif_table_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_hostif_table_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_hostif_table_entry_attribute(result.success, args.thrift_hostif_table_entry_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_hostif_table_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_hostif_table_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_hostif_table_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_hostif_table_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_hostif_table_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hostif_table_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hostif_table_entry_attribute(args.thrift_hostif_table_entry_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hostif_table_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hostif_table_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hostif_trap_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hostif_trap_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group");
  }

  switch_sai_rpc_sai_thrift_create_hostif_trap_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hostif_trap_group_result result;
  try {
    result.success = iface_->sai_thrift_create_hostif_trap_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hostif_trap_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_hostif_trap_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hostif_trap_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hostif_trap_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group");
  }

  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_hostif_trap_group(args.thrift_hostif_trap_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hostif_trap_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hostif_trap_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_hostif_trap_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_hostif_trap_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_result result;
  try {
    iface_->sai_thrift_get_hostif_trap_group_attribute(result.success, args.thrift_hostif_trap_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_hostif_trap_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_hostif_trap_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hostif_trap_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hostif_trap_group_attribute(args.thrift_hostif_trap_group_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hostif_trap_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hostif_trap_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hostif_trap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hostif_trap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap");
  }

  switch_sai_rpc_sai_thrift_create_hostif_trap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hostif_trap_result result;
  try {
    result.success = iface_->sai_thrift_create_hostif_trap(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hostif_trap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap");
  }

  oprot->writeMessageBegin("sai_thrift_create_hostif_trap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hostif_trap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hostif_trap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap");
  }

  switch_sai_rpc_sai_thrift_remove_hostif_trap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hostif_trap_result result;
  try {
    result.success = iface_->sai_thrift_remove_hostif_trap(args.thrift_hostif_trap_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hostif_trap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hostif_trap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_hostif_trap_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_hostif_trap_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_attribute");
  }

  switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_result result;
  try {
    iface_->sai_thrift_get_hostif_trap_attribute(result.success, args.thrift_hostif_trap_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_hostif_trap_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_hostif_trap_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_hostif_trap_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hostif_trap_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hostif_trap_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hostif_trap_attribute(args.thrift_hostif_trap_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hostif_trap_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hostif_trap_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_send_hostif_packet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_send_hostif_packet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_send_hostif_packet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_send_hostif_packet");
  }

  switch_sai_rpc_sai_thrift_send_hostif_packet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_send_hostif_packet", bytes);
  }

  switch_sai_rpc_sai_thrift_send_hostif_packet_result result;
  try {
    result.success = iface_->sai_thrift_send_hostif_packet(args.thrift_hif_id, args.packet_data, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_send_hostif_packet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_send_hostif_packet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_send_hostif_packet");
  }

  oprot->writeMessageBegin("sai_thrift_send_hostif_packet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_send_hostif_packet", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_table(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_table", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_table");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table");
  }

  switch_sai_rpc_sai_thrift_create_acl_table_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_table_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_table(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_table");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_table", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_table", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_table(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_table", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_table");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table");
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_table(args.acl_table_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_table", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_table", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_acl_table_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_acl_table_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_acl_table_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_attribute");
  }

  switch_sai_rpc_sai_thrift_get_acl_table_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_acl_table_attribute_result result;
  try {
    iface_->sai_thrift_get_acl_table_attribute(result.success, args.acl_table_id, args.thrift_attr_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_acl_table_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_acl_table_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry");
  }

  switch_sai_rpc_sai_thrift_create_acl_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry");
  }

  switch_sai_rpc_sai_thrift_remove_acl_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_entry(args.acl_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_acl_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_acl_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_acl_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_acl_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_acl_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_acl_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_acl_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_acl_entry_attribute(args.acl_entry_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_acl_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_acl_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_acl_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_acl_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_acl_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_acl_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_acl_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_acl_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_acl_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_acl_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_acl_entry_attribute(result.success, args.acl_entry_id, args.thrift_attr_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_acl_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_acl_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_acl_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_table_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_table_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group");
  }

  switch_sai_rpc_sai_thrift_create_acl_table_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_table_group_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_table_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_table_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_table_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_table_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_table_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group");
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_table_group(args.acl_table_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_table_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_table_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_acl_table_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_acl_table_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_result result;
  try {
    iface_->sai_thrift_get_acl_table_group_attribute(result.success, args.acl_table_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_acl_table_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_acl_table_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_table_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_table_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member");
  }

  switch_sai_rpc_sai_thrift_create_acl_table_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_table_group_member_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_table_group_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_table_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_table_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_table_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_table_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member");
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_table_group_member(args.acl_table_group_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_table_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_table_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_acl_table_group_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_acl_table_group_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_result result;
  try {
    iface_->sai_thrift_get_acl_table_group_member_attribute(result.success, args.acl_table_group_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_acl_table_group_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_acl_table_group_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_table_group_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_counter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter");
  }

  switch_sai_rpc_sai_thrift_create_acl_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_counter_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_counter(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter");
  }

  switch_sai_rpc_sai_thrift_remove_acl_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_counter_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_counter(args.acl_counter_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_acl_counter_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_acl_counter_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute");
  }

  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result result;
  try {
    iface_->sai_thrift_get_acl_counter_attribute(result.success, args.acl_counter_id, args.thrift_attr_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_acl_counter_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_acl_counter_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_range(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_range", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_range");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_range");
  }

  switch_sai_rpc_sai_thrift_create_acl_range_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_range", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_range_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_range(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_range");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_range", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_range");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_range", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_range", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_range(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_range", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_range");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_range");
  }

  switch_sai_rpc_sai_thrift_remove_acl_range_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_range", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_range_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_range(args.acl_range_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_range");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_range", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_range");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_range", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_range", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hash(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hash", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hash");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hash");
  }

  switch_sai_rpc_sai_thrift_create_hash_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hash", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hash_result result;
  try {
    result.success = iface_->sai_thrift_create_hash(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hash");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hash", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hash");
  }

  oprot->writeMessageBegin("sai_thrift_create_hash", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hash", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hash(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hash", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hash");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hash");
  }

  switch_sai_rpc_sai_thrift_remove_hash_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hash", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hash_result result;
  try {
    result.success = iface_->sai_thrift_remove_hash(args.hash_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hash");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hash", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hash");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hash", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hash", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hash_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hash_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hash_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hash_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hash_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hash_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hash_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hash_attribute(args.thrift_hash_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hash_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hash_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hash_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hash_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hash_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_hash_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_hash_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_hash_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_hash_attribute");
  }

  switch_sai_rpc_sai_thrift_get_hash_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_hash_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_hash_attribute_result result;
  try {
    iface_->sai_thrift_get_hash_attribute(result.success, args.thrift_hash_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_hash_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_hash_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_hash_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_hash_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_hash_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_udf_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_udf_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_udf_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_udf_group");
  }

  switch_sai_rpc_sai_thrift_create_udf_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_udf_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_udf_group_result result;
  try {
    result.success = iface_->sai_thrift_create_udf_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_udf_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_udf_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_udf_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_udf_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_udf_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_udf_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_udf_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_udf_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_udf_group");
  }

  switch_sai_rpc_sai_thrift_remove_udf_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_udf_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_udf_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_udf_group(args.udf_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_udf_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_udf_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_udf_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_udf_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_udf_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_udf_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_udf_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_udf_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_udf_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_udf_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_udf_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_udf_group_attribute_result result;
  try {
    iface_->sai_thrift_get_udf_group_attribute(result.success, args.thrift_udf_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_udf_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_udf_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_udf_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_udf_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_udf_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_udf_match(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_udf_match", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_udf_match");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_udf_match");
  }

  switch_sai_rpc_sai_thrift_create_udf_match_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_udf_match", bytes);
  }

  switch_sai_rpc_sai_thrift_create_udf_match_result result;
  try {
    result.success = iface_->sai_thrift_create_udf_match(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_udf_match");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_udf_match", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_udf_match");
  }

  oprot->writeMessageBegin("sai_thrift_create_udf_match", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_udf_match", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_udf_match(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_udf_match", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_udf_match");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_udf_match");
  }

  switch_sai_rpc_sai_thrift_remove_udf_match_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_udf_match", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_udf_match_result result;
  try {
    result.success = iface_->sai_thrift_remove_udf_match(args.udf_match_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_udf_match");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_udf_match", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_udf_match");
  }

  oprot->writeMessageBegin("sai_thrift_remove_udf_match", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_udf_match", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_udf_match_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_udf_match_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_udf_match_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_udf_match_attribute");
  }

  switch_sai_rpc_sai_thrift_get_udf_match_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_udf_match_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_udf_match_attribute_result result;
  try {
    iface_->sai_thrift_get_udf_match_attribute(result.success, args.thrift_udf_match_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_udf_match_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_udf_match_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_udf_match_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_udf_match_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_udf_match_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_udf(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_udf", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_udf");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_udf");
  }

  switch_sai_rpc_sai_thrift_create_udf_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_udf", bytes);
  }

  switch_sai_rpc_sai_thrift_create_udf_result result;
  try {
    result.success = iface_->sai_thrift_create_udf(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_udf");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_udf", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_udf");
  }

  oprot->writeMessageBegin("sai_thrift_create_udf", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_udf", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_udf(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_udf", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_udf");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_udf");
  }

  switch_sai_rpc_sai_thrift_remove_udf_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_udf", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_udf_result result;
  try {
    result.success = iface_->sai_thrift_remove_udf(args.udf_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_udf");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_udf", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_udf");
  }

  oprot->writeMessageBegin("sai_thrift_remove_udf", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_udf", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_udf_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_udf_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_udf_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_udf_attribute");
  }

  switch_sai_rpc_sai_thrift_set_udf_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_udf_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_udf_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_udf_attribute(args.thrift_udf_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_udf_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_udf_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_udf_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_udf_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_udf_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_udf_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_udf_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_udf_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_udf_attribute");
  }

  switch_sai_rpc_sai_thrift_get_udf_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_udf_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_udf_attribute_result result;
  try {
    iface_->sai_thrift_get_udf_attribute(result.success, args.thrift_udf_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_udf_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_udf_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_udf_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_udf_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_udf_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_twamp_session(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_twamp_session", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_twamp_session");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_twamp_session");
  }

  switch_sai_rpc_sai_thrift_create_twamp_session_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_twamp_session", bytes);
  }

  switch_sai_rpc_sai_thrift_create_twamp_session_result result;
  try {
    result.success = iface_->sai_thrift_create_twamp_session(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_twamp_session");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_twamp_session", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_twamp_session");
  }

  oprot->writeMessageBegin("sai_thrift_create_twamp_session", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_twamp_session", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_twamp_session(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_twamp_session", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_twamp_session");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_twamp_session");
  }

  switch_sai_rpc_sai_thrift_remove_twamp_session_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_twamp_session", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_twamp_session_result result;
  try {
    result.success = iface_->sai_thrift_remove_twamp_session(args.session_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_twamp_session");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_twamp_session", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_twamp_session");
  }

  oprot->writeMessageBegin("sai_thrift_remove_twamp_session", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_twamp_session", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_twamp_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_twamp_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_twamp_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_twamp_attribute");
  }

  switch_sai_rpc_sai_thrift_set_twamp_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_twamp_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_twamp_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_twamp_attribute(args.thrift_twamp_session_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_twamp_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_twamp_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_twamp_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_twamp_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_twamp_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_mirror_session(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_mirror_session", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_mirror_session");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session");
  }

  switch_sai_rpc_sai_thrift_create_mirror_session_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session", bytes);
  }

  switch_sai_rpc_sai_thrift_create_mirror_session_result result;
  try {
    result.success = iface_->sai_thrift_create_mirror_session(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_mirror_session", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session");
  }

  oprot->writeMessageBegin("sai_thrift_create_mirror_session", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_mirror_session(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_mirror_session", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session");
  }

  switch_sai_rpc_sai_thrift_remove_mirror_session_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_mirror_session_result result;
  try {
    result.success = iface_->sai_thrift_remove_mirror_session(args.session_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_mirror_session", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session");
  }

  oprot->writeMessageBegin("sai_thrift_remove_mirror_session", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_mirror_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_mirror_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_mirror_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_mirror_attribute");
  }

  switch_sai_rpc_sai_thrift_set_mirror_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_mirror_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_mirror_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_mirror_attribute(args.thrift_mirror_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_mirror_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_mirror_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_mirror_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_mirror_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_mirror_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_mirror_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_mirror_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_mirror_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_mirror_attribute");
  }

  switch_sai_rpc_sai_thrift_get_mirror_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_mirror_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_mirror_attribute_result result;
  try {
    iface_->sai_thrift_get_mirror_attribute(result.success, args.thrift_mirror_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_mirror_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_mirror_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_mirror_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_mirror_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_mirror_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_inseg_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_inseg_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_inseg_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_inseg_entry");
  }

  switch_sai_rpc_sai_thrift_create_inseg_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_inseg_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_inseg_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_inseg_entry(args.thrift_inseg_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_inseg_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_inseg_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_inseg_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_inseg_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_inseg_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_inseg_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_inseg_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_inseg_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_inseg_entry");
  }

  switch_sai_rpc_sai_thrift_remove_inseg_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_inseg_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_inseg_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_inseg_entry(args.thrift_inseg_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_inseg_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_inseg_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_inseg_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_inseg_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_inseg_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_inseg_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_inseg_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_inseg_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_inseg_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_inseg_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_inseg_entry_attribute(args.thrift_inseg_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_inseg_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_inseg_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_inseg_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_inseg_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_inseg_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_inseg_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_inseg_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_inseg_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_inseg_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_inseg_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_inseg_entry_attribute(result.success, args.thrift_inseg_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_inseg_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_inseg_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_inseg_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_inseg_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_inseg_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_dump_log(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_dump_log", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_dump_log");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_dump_log");
  }

  switch_sai_rpc_sai_thrift_dump_log_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_dump_log", bytes);
  }

  switch_sai_rpc_sai_thrift_dump_log_result result;
  try {
    result.success = iface_->sai_thrift_dump_log(args.dump_file_name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_dump_log");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_dump_log", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_dump_log");
  }

  oprot->writeMessageBegin("sai_thrift_dump_log", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_dump_log", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_policer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_policer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_policer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_policer");
  }

  switch_sai_rpc_sai_thrift_create_policer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_policer", bytes);
  }

  switch_sai_rpc_sai_thrift_create_policer_result result;
  try {
    result.success = iface_->sai_thrift_create_policer(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_policer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_policer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_policer");
  }

  oprot->writeMessageBegin("sai_thrift_create_policer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_policer", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_policer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_policer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_policer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_policer");
  }

  switch_sai_rpc_sai_thrift_remove_policer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_policer", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_policer_result result;
  try {
    result.success = iface_->sai_thrift_remove_policer(args.thrift_policer_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_policer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_policer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_policer");
  }

  oprot->writeMessageBegin("sai_thrift_remove_policer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_policer", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_policer_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_policer_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_policer_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_policer_attribute");
  }

  switch_sai_rpc_sai_thrift_get_policer_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_policer_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_policer_attribute_result result;
  try {
    iface_->sai_thrift_get_policer_attribute(result.success, args.thrift_policer_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_policer_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_policer_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_policer_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_policer_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_policer_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_policer_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_policer_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute");
  }

  switch_sai_rpc_sai_thrift_set_policer_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_policer_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_policer_attribute(args.thrift_policer_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_policer_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_policer_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_policer_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_policer_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_policer_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats");
  }

  switch_sai_rpc_sai_thrift_get_policer_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_policer_stats_result result;
  try {
    iface_->sai_thrift_get_policer_stats(result.success, args.thrift_policer_id, args.thrift_counter_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_policer_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_policer_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_policer_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_policer_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats");
  }

  switch_sai_rpc_sai_thrift_clear_policer_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_policer_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_policer_stats(args.thrift_policer_id, args.thrift_counter_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_policer_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_policer_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_scheduler_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_scheduler_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile");
  }

  switch_sai_rpc_sai_thrift_create_scheduler_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_create_scheduler_profile_result result;
  try {
    result.success = iface_->sai_thrift_create_scheduler_profile(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_scheduler_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile");
  }

  oprot->writeMessageBegin("sai_thrift_create_scheduler_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_scheduler_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_scheduler_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile");
  }

  switch_sai_rpc_sai_thrift_remove_scheduler_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_scheduler_profile_result result;
  try {
    result.success = iface_->sai_thrift_remove_scheduler_profile(args.scheduler_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_scheduler_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile");
  }

  oprot->writeMessageBegin("sai_thrift_remove_scheduler_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_scheduler_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_scheduler_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_scheduler_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_attribute");
  }

  switch_sai_rpc_sai_thrift_get_scheduler_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_scheduler_attribute_result result;
  try {
    iface_->sai_thrift_get_scheduler_attribute(result.success, args.thrift_scheduler_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_scheduler_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_scheduler_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_scheduler_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_scheduler_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_scheduler_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_attribute");
  }

  switch_sai_rpc_sai_thrift_set_scheduler_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_scheduler_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_scheduler_attribute(args.thrift_scheduler_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_scheduler_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_scheduler_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_scheduler_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_scheduler_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_scheduler_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_group");
  }

  switch_sai_rpc_sai_thrift_create_scheduler_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_scheduler_group_result result;
  try {
    result.success = iface_->sai_thrift_create_scheduler_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_scheduler_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_scheduler_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_scheduler_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_scheduler_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_group");
  }

  switch_sai_rpc_sai_thrift_remove_scheduler_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_scheduler_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_scheduler_group(args.scheduler_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_scheduler_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_scheduler_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_scheduler_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_scheduler_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_scheduler_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_result result;
  try {
    iface_->sai_thrift_get_scheduler_group_attribute(result.success, args.scheduler_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_scheduler_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_scheduler_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_scheduler_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_scheduler_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_scheduler_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_scheduler_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_group_attribute");
  }

  switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_scheduler_group_attribute(args.scheduler_group_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_scheduler_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_scheduler_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_scheduler_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_queue_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_queue_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_queue_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats");
  }

  switch_sai_rpc_sai_thrift_get_queue_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_queue_stats_result result;
  try {
    iface_->sai_thrift_get_queue_stats(result.success, args.queue_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_queue_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_queue_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_queue_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_queue_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats");
  }

  switch_sai_rpc_sai_thrift_clear_queue_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_queue_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_queue_stats(args.queue_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_queue_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_queue_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_queue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_queue", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_queue");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_queue");
  }

  switch_sai_rpc_sai_thrift_create_queue_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_queue", bytes);
  }

  switch_sai_rpc_sai_thrift_create_queue_result result;
  try {
    result.success = iface_->sai_thrift_create_queue(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_queue");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_queue", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_queue");
  }

  oprot->writeMessageBegin("sai_thrift_create_queue", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_queue", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_queue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_queue", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_queue");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_queue");
  }

  switch_sai_rpc_sai_thrift_remove_queue_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_queue", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_queue_result result;
  try {
    result.success = iface_->sai_thrift_remove_queue(args.queue_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_queue");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_queue", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_queue");
  }

  oprot->writeMessageBegin("sai_thrift_remove_queue", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_queue", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_queue_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_queue_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_queue_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_queue_attribute");
  }

  switch_sai_rpc_sai_thrift_get_queue_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_queue_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_queue_attribute_result result;
  try {
    iface_->sai_thrift_get_queue_attribute(result.success, args.queue_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_queue_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_queue_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_queue_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_queue_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_queue_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_queue_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_queue_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute");
  }

  switch_sai_rpc_sai_thrift_set_queue_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_queue_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_queue_attribute(args.queue_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_queue_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_queue_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_buffer_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_buffer_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile");
  }

  switch_sai_rpc_sai_thrift_create_buffer_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_create_buffer_profile_result result;
  try {
    result.success = iface_->sai_thrift_create_buffer_profile(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_buffer_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile");
  }

  oprot->writeMessageBegin("sai_thrift_create_buffer_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_buffer_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_buffer_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_buffer_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_buffer_profile");
  }

  switch_sai_rpc_sai_thrift_remove_buffer_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_buffer_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_buffer_profile_result result;
  try {
    result.success = iface_->sai_thrift_remove_buffer_profile(args.buffer_profile_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_buffer_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_buffer_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_buffer_profile");
  }

  oprot->writeMessageBegin("sai_thrift_remove_buffer_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_buffer_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_buffer_profile_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_buffer_profile_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_buffer_profile_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_buffer_profile_attribute");
  }

  switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_buffer_profile_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_result result;
  try {
    iface_->sai_thrift_get_buffer_profile_attribute(result.success, args.buffer_profile_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_buffer_profile_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_buffer_profile_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_buffer_profile_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_buffer_profile_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_buffer_profile_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_buffer_profile_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_buffer_profile_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_buffer_profile_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_buffer_profile_attribute");
  }

  switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_buffer_profile_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_buffer_profile_attribute(args.buffer_profile_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_buffer_profile_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_buffer_profile_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_buffer_profile_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_buffer_profile_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_buffer_profile_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_pool_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_pool_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_pool_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile");
  }

  switch_sai_rpc_sai_thrift_create_pool_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_create_pool_profile_result result;
  try {
    result.success = iface_->sai_thrift_create_pool_profile(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_pool_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile");
  }

  oprot->writeMessageBegin("sai_thrift_create_pool_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_priority_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_priority_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_priority_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_priority_group");
  }

  switch_sai_rpc_sai_thrift_create_priority_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_priority_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_priority_group_result result;
  try {
    result.success = iface_->sai_thrift_create_priority_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_priority_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_priority_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_priority_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_priority_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_priority_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_priority_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_priority_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_priority_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_priority_group");
  }

  switch_sai_rpc_sai_thrift_remove_priority_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_priority_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_priority_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_priority_group(args.priority_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_priority_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_priority_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_priority_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_priority_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_priority_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_priority_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_priority_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_priority_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_priority_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_priority_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_priority_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_priority_group_attribute_result result;
  try {
    iface_->sai_thrift_get_priority_group_attribute(result.success, args.priority_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_priority_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_priority_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_priority_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_priority_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_priority_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_priority_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_priority_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute");
  }

  switch_sai_rpc_sai_thrift_set_priority_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_priority_group_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_priority_group_attribute(args.pg_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_priority_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_priority_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_pg_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_pg_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_pg_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats");
  }

  switch_sai_rpc_sai_thrift_get_pg_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_pg_stats_result result;
  try {
    iface_->sai_thrift_get_pg_stats(result.success, args.pg_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_pg_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_pg_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_wred_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_wred_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_wred_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile");
  }

  switch_sai_rpc_sai_thrift_create_wred_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_create_wred_profile_result result;
  try {
    result.success = iface_->sai_thrift_create_wred_profile(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_wred_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile");
  }

  oprot->writeMessageBegin("sai_thrift_create_wred_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_wred_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_wred_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile");
  }

  switch_sai_rpc_sai_thrift_remove_wred_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_wred_profile_result result;
  try {
    result.success = iface_->sai_thrift_remove_wred_profile(args.wred_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_wred_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile");
  }

  oprot->writeMessageBegin("sai_thrift_remove_wred_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_wred_attribute_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_wred_attribute_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_wred_attribute_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_wred_attribute_profile");
  }

  switch_sai_rpc_sai_thrift_get_wred_attribute_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_wred_attribute_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_get_wred_attribute_profile_result result;
  try {
    iface_->sai_thrift_get_wred_attribute_profile(result.success, args.wred_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_wred_attribute_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_wred_attribute_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_wred_attribute_profile");
  }

  oprot->writeMessageBegin("sai_thrift_get_wred_attribute_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_wred_attribute_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_wred_attribute_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_wred_attribute_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_wred_attribute_profile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_wred_attribute_profile");
  }

  switch_sai_rpc_sai_thrift_set_wred_attribute_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_wred_attribute_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_set_wred_attribute_profile_result result;
  try {
    result.success = iface_->sai_thrift_set_wred_attribute_profile(args.wred_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_wred_attribute_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_wred_attribute_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_wred_attribute_profile");
  }

  oprot->writeMessageBegin("sai_thrift_set_wred_attribute_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_wred_attribute_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_qos_map(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_qos_map", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_qos_map");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_qos_map");
  }

  switch_sai_rpc_sai_thrift_create_qos_map_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_qos_map", bytes);
  }

  switch_sai_rpc_sai_thrift_create_qos_map_result result;
  try {
    result.success = iface_->sai_thrift_create_qos_map(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_qos_map");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_qos_map", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_qos_map");
  }

  oprot->writeMessageBegin("sai_thrift_create_qos_map", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_qos_map", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_qos_map(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_qos_map", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_qos_map");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map");
  }

  switch_sai_rpc_sai_thrift_remove_qos_map_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_qos_map_result result;
  try {
    result.success = iface_->sai_thrift_remove_qos_map(args.qos_map_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_qos_map", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map");
  }

  oprot->writeMessageBegin("sai_thrift_remove_qos_map", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_qos_map_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_qos_map_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_qos_map_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_qos_map_attribute");
  }

  switch_sai_rpc_sai_thrift_get_qos_map_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_qos_map_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_qos_map_attribute_result result;
  try {
    iface_->sai_thrift_get_qos_map_attribute(result.success, args.qos_map_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_qos_map_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_qos_map_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_qos_map_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_qos_map_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_qos_map_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_qos_map_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_qos_map_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_qos_map_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_qos_map_attribute");
  }

  switch_sai_rpc_sai_thrift_set_qos_map_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_qos_map_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_qos_map_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_qos_map_attribute(args.qos_map_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_qos_map_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_qos_map_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_qos_map_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_qos_map_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_qos_map_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_l2mc_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_l2mc_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group");
  }

  switch_sai_rpc_sai_thrift_create_l2mc_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_l2mc_group_result result;
  try {
    result.success = iface_->sai_thrift_create_l2mc_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_l2mc_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_l2mc_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_l2mc_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_l2mc_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group");
  }

  switch_sai_rpc_sai_thrift_remove_l2mc_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_l2mc_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_l2mc_group(args.grp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_l2mc_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_l2mc_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_l2mc_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_l2mc_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_result result;
  try {
    iface_->sai_thrift_get_l2mc_group_attribute(result.success, args.grp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_l2mc_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_l2mc_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_l2mc_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_l2mc_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group_member");
  }

  switch_sai_rpc_sai_thrift_create_l2mc_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_l2mc_group_member_result result;
  try {
    result.success = iface_->sai_thrift_create_l2mc_group_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_l2mc_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_l2mc_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_l2mc_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_l2mc_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group_member");
  }

  switch_sai_rpc_sai_thrift_remove_l2mc_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_l2mc_group_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_l2mc_group_member(args.member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_l2mc_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_l2mc_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_l2mc_group_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_l2mc_group_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_l2mc_group_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_group_member_attribute");
  }

  switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_group_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_l2mc_group_member_attribute(args.member_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_group_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_l2mc_group_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_group_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_l2mc_group_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_group_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_l2mc_group_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_l2mc_group_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_result result;
  try {
    iface_->sai_thrift_get_l2mc_group_member_attribute(result.success, args.member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_l2mc_group_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_l2mc_group_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_group_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_l2mc_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_l2mc_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_l2mc_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_entry");
  }

  switch_sai_rpc_sai_thrift_create_l2mc_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_l2mc_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_l2mc_entry(args.thrift_l2mc_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_l2mc_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_l2mc_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_l2mc_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_l2mc_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_l2mc_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_entry");
  }

  switch_sai_rpc_sai_thrift_remove_l2mc_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_l2mc_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_l2mc_entry(args.thrift_l2mc_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_l2mc_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_l2mc_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_l2mc_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_l2mc_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_l2mc_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_l2mc_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_l2mc_entry_attribute(args.thrift_l2mc_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_l2mc_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_l2mc_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_l2mc_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_l2mc_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_l2mc_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_l2mc_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_l2mc_entry_attribute(result.success, args.thrift_l2mc_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_l2mc_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_l2mc_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_l2mc_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_mcast_fdb_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_mcast_fdb_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_mcast_fdb_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_mcast_fdb_entry");
  }

  switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_mcast_fdb_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_mcast_fdb_entry(args.thrift_mcast_fdb_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_mcast_fdb_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_mcast_fdb_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_mcast_fdb_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_mcast_fdb_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_mcast_fdb_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_mcast_fdb_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_mcast_fdb_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_mcast_fdb_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_mcast_fdb_entry");
  }

  switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_mcast_fdb_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_mcast_fdb_entry(args.thrift_mcast_fdb_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_mcast_fdb_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_mcast_fdb_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_mcast_fdb_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_mcast_fdb_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_mcast_fdb_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_mcast_fdb_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_mcast_fdb_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_mcast_fdb_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_mcast_fdb_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_mcast_fdb_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_mcast_fdb_entry_attribute(args.thrift_mcast_fdb_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_mcast_fdb_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_mcast_fdb_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_mcast_fdb_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_mcast_fdb_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_mcast_fdb_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_mcast_fdb_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_mcast_fdb_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_mcast_fdb_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_mcast_fdb_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_mcast_fdb_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_mcast_fdb_entry_attribute(result.success, args.thrift_mcast_fdb_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_mcast_fdb_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_mcast_fdb_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_mcast_fdb_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_mcast_fdb_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_mcast_fdb_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_ipmc_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_ipmc_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group");
  }

  switch_sai_rpc_sai_thrift_create_ipmc_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_ipmc_group_result result;
  try {
    result.success = iface_->sai_thrift_create_ipmc_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_ipmc_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_ipmc_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_ipmc_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_ipmc_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group");
  }

  switch_sai_rpc_sai_thrift_remove_ipmc_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_ipmc_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_ipmc_group(args.grp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_ipmc_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_ipmc_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_ipmc_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_ipmc_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_result result;
  try {
    iface_->sai_thrift_get_ipmc_group_attribute(result.success, args.grp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_ipmc_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_ipmc_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_ipmc_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_ipmc_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group_member");
  }

  switch_sai_rpc_sai_thrift_create_ipmc_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_ipmc_group_member_result result;
  try {
    result.success = iface_->sai_thrift_create_ipmc_group_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_ipmc_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_ipmc_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_ipmc_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_ipmc_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group_member");
  }

  switch_sai_rpc_sai_thrift_remove_ipmc_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_ipmc_group_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_ipmc_group_member(args.member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_ipmc_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_ipmc_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_ipmc_group_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_ipmc_group_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_ipmc_group_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_group_member_attribute");
  }

  switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_group_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_ipmc_group_member_attribute(args.member_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_group_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_ipmc_group_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_group_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_ipmc_group_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_group_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_ipmc_group_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_ipmc_group_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_result result;
  try {
    iface_->sai_thrift_get_ipmc_group_member_attribute(result.success, args.member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_ipmc_group_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_ipmc_group_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_group_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_rpf_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_rpf_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_rpf_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group");
  }

  switch_sai_rpc_sai_thrift_create_rpf_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_rpf_group_result result;
  try {
    result.success = iface_->sai_thrift_create_rpf_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_rpf_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_rpf_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_rpf_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_rpf_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group");
  }

  switch_sai_rpc_sai_thrift_remove_rpf_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_rpf_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_rpf_group(args.grp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_rpf_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_rpf_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_rpf_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_rpf_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_attribute");
  }

  switch_sai_rpc_sai_thrift_get_rpf_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_rpf_group_attribute_result result;
  try {
    iface_->sai_thrift_get_rpf_group_attribute(result.success, args.grp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_rpf_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_rpf_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_rpf_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_rpf_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_rpf_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group_member");
  }

  switch_sai_rpc_sai_thrift_create_rpf_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_rpf_group_member_result result;
  try {
    result.success = iface_->sai_thrift_create_rpf_group_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_rpf_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_rpf_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_rpf_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_rpf_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_rpf_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group_member");
  }

  switch_sai_rpc_sai_thrift_remove_rpf_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_rpf_group_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_rpf_group_member(args.member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_rpf_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_rpf_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_rpf_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_rpf_group_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_rpf_group_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_rpf_group_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_rpf_group_member_attribute");
  }

  switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_rpf_group_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_rpf_group_member_attribute(args.member_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_rpf_group_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_rpf_group_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_rpf_group_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_rpf_group_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_rpf_group_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_rpf_group_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_rpf_group_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_member_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_result result;
  try {
    iface_->sai_thrift_get_rpf_group_member_attribute(result.success, args.member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_rpf_group_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_rpf_group_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_rpf_group_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_ipmc_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_ipmc_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_ipmc_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_entry");
  }

  switch_sai_rpc_sai_thrift_create_ipmc_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_ipmc_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_ipmc_entry(args.thrift_ipmc_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_ipmc_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_ipmc_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_ipmc_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_ipmc_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_ipmc_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_entry");
  }

  switch_sai_rpc_sai_thrift_remove_ipmc_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_ipmc_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_ipmc_entry(args.thrift_ipmc_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_ipmc_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_ipmc_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_ipmc_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_ipmc_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_ipmc_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_ipmc_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_ipmc_entry_attribute(args.thrift_ipmc_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_ipmc_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_ipmc_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_ipmc_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_ipmc_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_ipmc_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_ipmc_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_ipmc_entry_attribute(result.success, args.thrift_ipmc_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_ipmc_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_ipmc_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_ipmc_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_samplepacket(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_samplepacket", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_samplepacket");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_samplepacket");
  }

  switch_sai_rpc_sai_thrift_create_samplepacket_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_samplepacket", bytes);
  }

  switch_sai_rpc_sai_thrift_create_samplepacket_result result;
  try {
    result.success = iface_->sai_thrift_create_samplepacket(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_samplepacket");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_samplepacket", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_samplepacket");
  }

  oprot->writeMessageBegin("sai_thrift_create_samplepacket", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_samplepacket", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_samplepacket(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_samplepacket", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_samplepacket");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_samplepacket");
  }

  switch_sai_rpc_sai_thrift_remove_samplepacket_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_samplepacket", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_samplepacket_result result;
  try {
    result.success = iface_->sai_thrift_remove_samplepacket(args.samplepacket_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_samplepacket");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_samplepacket", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_samplepacket");
  }

  oprot->writeMessageBegin("sai_thrift_remove_samplepacket", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_samplepacket", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_samplepacket_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_samplepacket_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_samplepacket_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_samplepacket_attribute");
  }

  switch_sai_rpc_sai_thrift_get_samplepacket_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_samplepacket_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_samplepacket_attribute_result result;
  try {
    iface_->sai_thrift_get_samplepacket_attribute(result.success, args.samplepacket_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_samplepacket_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_samplepacket_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_samplepacket_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_samplepacket_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_samplepacket_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_samplepacket_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_samplepacket_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_samplepacket_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_samplepacket_attribute");
  }

  switch_sai_rpc_sai_thrift_set_samplepacket_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_samplepacket_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_samplepacket_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_samplepacket_attribute(args.samplepacket_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_samplepacket_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_samplepacket_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_samplepacket_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_samplepacket_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_samplepacket_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_tunnel_map_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_tunnel_map_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map_entry");
  }

  switch_sai_rpc_sai_thrift_create_tunnel_map_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_tunnel_map_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_tunnel_map_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_tunnel_map_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_tunnel_map_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_tunnel_map_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_tunnel_map_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map_entry");
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_tunnel_map_entry(args.tunnel_map_entry_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_tunnel_map_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_tunnel_map_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_tunnel_map_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_tunnel_map_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_tunnel_map_entry_attribute(result.success, args.tunnel_map_entry_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_tunnel_map_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_tunnel_map_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_tunnel_map_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_tunnel_map_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_tunnel_map_entry_attribute(args.tunnel_map_entry_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_tunnel_map_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_tunnel_map_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_tunnel_map(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_tunnel_map", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map");
  }

  switch_sai_rpc_sai_thrift_create_tunnel_map_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map", bytes);
  }

  switch_sai_rpc_sai_thrift_create_tunnel_map_result result;
  try {
    result.success = iface_->sai_thrift_create_tunnel_map(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_tunnel_map", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map");
  }

  oprot->writeMessageBegin("sai_thrift_create_tunnel_map", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_map", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_tunnel_map(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_tunnel_map", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map");
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_map_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_map_result result;
  try {
    result.success = iface_->sai_thrift_remove_tunnel_map(args.tunnel_map_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_tunnel_map", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map");
  }

  oprot->writeMessageBegin("sai_thrift_remove_tunnel_map", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_map", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_tunnel_map_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_tunnel_map_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_attribute");
  }

  switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_result result;
  try {
    iface_->sai_thrift_get_tunnel_map_attribute(result.success, args.tunnel_map_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_tunnel_map_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_tunnel_map_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_map_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_tunnel_map_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_tunnel_map_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_attribute");
  }

  switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_tunnel_map_attribute(args.tunnel_map_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_tunnel_map_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_tunnel_map_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_map_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_tunnel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_tunnel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_tunnel");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel");
  }

  switch_sai_rpc_sai_thrift_create_tunnel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel", bytes);
  }

  switch_sai_rpc_sai_thrift_create_tunnel_result result;
  try {
    result.success = iface_->sai_thrift_create_tunnel(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_tunnel");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_tunnel", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel");
  }

  oprot->writeMessageBegin("sai_thrift_create_tunnel", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_tunnel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_tunnel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_tunnel");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel");
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_result result;
  try {
    result.success = iface_->sai_thrift_remove_tunnel(args.tunnel_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_tunnel", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel");
  }

  oprot->writeMessageBegin("sai_thrift_remove_tunnel", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_tunnel_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_tunnel_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_tunnel_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_attribute");
  }

  switch_sai_rpc_sai_thrift_get_tunnel_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_tunnel_attribute_result result;
  try {
    iface_->sai_thrift_get_tunnel_attribute(result.success, args.tunnel_id, args.thrift_attr_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_tunnel_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_tunnel_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_tunnel_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_tunnel_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_tunnel_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_attribute");
  }

  switch_sai_rpc_sai_thrift_set_tunnel_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_tunnel_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_tunnel_attribute(args.tunnel_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_tunnel_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_tunnel_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_tunnel_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_tunnel_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_tunnel_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_stats");
  }

  switch_sai_rpc_sai_thrift_get_tunnel_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_tunnel_stats_result result;
  try {
    iface_->sai_thrift_get_tunnel_stats(result.success, args.tunnel_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_tunnel_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_tunnel_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_tunnel_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_tunnel_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_tunnel_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_tunnel_stats");
  }

  switch_sai_rpc_sai_thrift_clear_tunnel_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_tunnel_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_tunnel_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_tunnel_stats(args.tunnel_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_tunnel_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_tunnel_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_tunnel_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_tunnel_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_tunnel_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_tunnel_term_table_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry");
  }

  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_tunnel_term_table_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_tunnel_term_table_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_tunnel_term_table_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_tunnel_term_table_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry");
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_tunnel_term_table_entry(args.tunnel_term_table_entry_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_tunnel_term_table_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_tunnel_term_table_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_tunnel_term_table_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_tunnel_term_table_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_tunnel_term_table_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_term_table_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_term_table_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_result result;
  try {
    iface_->sai_thrift_get_tunnel_term_table_entry_attribute(result.success, args.tunnel_term_table_entry_id, args.thrift_attr_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_term_table_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_tunnel_term_table_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_term_table_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_tunnel_term_table_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_tunnel_term_table_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_tunnel_term_table_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_tunnel_term_table_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_tunnel_term_table_entry_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_term_table_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_term_table_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_tunnel_term_table_entry_attribute(args.tunnel_term_table_entry_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_term_table_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_tunnel_term_table_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_term_table_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_tunnel_term_table_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_tunnel_term_table_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_cpu_packet_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_cpu_packet_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_attribute");
  }

  switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_result result;
  try {
    iface_->sai_thrift_get_cpu_packet_attribute(result.success, args.switch_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_cpu_packet_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_cpu_packet_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_cpu_packet_count(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_cpu_packet_count", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_count");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_count");
  }

  switch_sai_rpc_sai_thrift_get_cpu_packet_count_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_count", bytes);
  }

  switch_sai_rpc_sai_thrift_get_cpu_packet_count_result result;
  try {
    iface_->sai_thrift_get_cpu_packet_count(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_count");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_cpu_packet_count", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_count");
  }

  oprot->writeMessageBegin("sai_thrift_get_cpu_packet_count", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_cpu_packet_count", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_cpu_packet_info(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_cpu_packet_info", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_cpu_packet_info");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_cpu_packet_info");
  }

  switch_sai_rpc_sai_thrift_clear_cpu_packet_info_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_cpu_packet_info", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_cpu_packet_info_result result;
  try {
    iface_->sai_thrift_clear_cpu_packet_info(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_cpu_packet_info");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_cpu_packet_info", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_cpu_packet_info");
  }

  oprot->writeMessageBegin("sai_thrift_clear_cpu_packet_info", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_cpu_packet_info", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_log_set(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_log_set", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_log_set");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_log_set");
  }

  switch_sai_rpc_sai_thrift_log_set_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_log_set", bytes);
  }

  switch_sai_rpc_sai_thrift_log_set_result result;
  try {
    result.success = iface_->sai_thrift_log_set(args.sai_api_id, args.log_level);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_log_set");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_log_set", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_log_set");
  }

  oprot->writeMessageBegin("sai_thrift_log_set", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_log_set", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_isolation_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_isolation_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_isolation_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group");
  }

  switch_sai_rpc_sai_thrift_create_isolation_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_isolation_group_result result;
  try {
    result.success = iface_->sai_thrift_create_isolation_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_isolation_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_isolation_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_isolation_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_isolation_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group");
  }

  switch_sai_rpc_sai_thrift_remove_isolation_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_isolation_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_isolation_group(args.iso_group_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_isolation_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_isolation_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_isolation_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_isolation_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_isolation_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group_member");
  }

  switch_sai_rpc_sai_thrift_create_isolation_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_isolation_group_member_result result;
  try {
    result.success = iface_->sai_thrift_create_isolation_group_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_isolation_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_isolation_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_isolation_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_isolation_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_isolation_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group_member");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group_member");
  }

  switch_sai_rpc_sai_thrift_remove_isolation_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_isolation_group_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_isolation_group_member(args.member_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_isolation_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_isolation_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_isolation_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_isolation_group_attributes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_isolation_group_attributes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_attributes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_attributes");
  }

  switch_sai_rpc_sai_thrift_get_isolation_group_attributes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_attributes", bytes);
  }

  switch_sai_rpc_sai_thrift_get_isolation_group_attributes_result result;
  try {
    iface_->sai_thrift_get_isolation_group_attributes(result.success, args.iso_group_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_attributes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_isolation_group_attributes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_attributes");
  }

  oprot->writeMessageBegin("sai_thrift_get_isolation_group_attributes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_attributes", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_isolation_group_member_attributes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_isolation_group_member_attributes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_member_attributes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_member_attributes");
  }

  switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_member_attributes", bytes);
  }

  switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_result result;
  try {
    iface_->sai_thrift_get_isolation_group_member_attributes(result.success, args.member_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_member_attributes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_isolation_group_member_attributes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_member_attributes");
  }

  oprot->writeMessageBegin("sai_thrift_get_isolation_group_member_attributes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_isolation_group_member_attributes", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_counter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_counter");
  }

  switch_sai_rpc_sai_thrift_create_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_create_counter_result result;
  try {
    result.success = iface_->sai_thrift_create_counter(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_counter");
  }

  oprot->writeMessageBegin("sai_thrift_create_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_counter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_counter");
  }

  switch_sai_rpc_sai_thrift_remove_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_counter_result result;
  try {
    result.success = iface_->sai_thrift_remove_counter(args.counter_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_counter");
  }

  oprot->writeMessageBegin("sai_thrift_remove_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_counter_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_counter_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_counter_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_counter_attribute");
  }

  switch_sai_rpc_sai_thrift_set_counter_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_counter_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_counter_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_counter_attribute(args.thrift_counter_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_counter_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_counter_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_counter_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_counter_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_counter_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_counter_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_counter_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_counter_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_counter_attribute");
  }

  switch_sai_rpc_sai_thrift_get_counter_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_counter_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_counter_attribute_result result;
  try {
    iface_->sai_thrift_get_counter_attribute(result.success, args.thrift_counter_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_counter_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_counter_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_counter_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_counter_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_counter_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_counter_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_counter_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_counter_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats");
  }

  switch_sai_rpc_sai_thrift_get_counter_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_counter_stats_result result;
  try {
    iface_->sai_thrift_get_counter_stats(result.success, args.counter_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_counter_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_counter_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_counter_stats_ext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_counter_stats_ext", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_counter_stats_ext");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats_ext");
  }

  switch_sai_rpc_sai_thrift_get_counter_stats_ext_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats_ext", bytes);
  }

  switch_sai_rpc_sai_thrift_get_counter_stats_ext_result result;
  try {
    iface_->sai_thrift_get_counter_stats_ext(result.success, args.counter_id, args.counter_ids, args.mode, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats_ext");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_counter_stats_ext", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats_ext");
  }

  oprot->writeMessageBegin("sai_thrift_get_counter_stats_ext", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_counter_stats_ext", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_counter_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_counter_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_counter_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_counter_stats");
  }

  switch_sai_rpc_sai_thrift_clear_counter_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_counter_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_counter_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_counter_stats(args.counter_id, args.thrift_counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_counter_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_counter_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_counter_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_counter_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_counter_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_debug_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_debug_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_debug_counter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter");
  }

  switch_sai_rpc_sai_thrift_create_debug_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_create_debug_counter_result result;
  try {
    result.success = iface_->sai_thrift_create_debug_counter(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_debug_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter");
  }

  oprot->writeMessageBegin("sai_thrift_create_debug_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_debug_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_debug_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter");
  }

  switch_sai_rpc_sai_thrift_remove_debug_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_debug_counter_result result;
  try {
    result.success = iface_->sai_thrift_remove_debug_counter(args.debug_counter_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_debug_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter");
  }

  oprot->writeMessageBegin("sai_thrift_remove_debug_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_debug_counter_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_debug_counter_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute");
  }

  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_debug_counter_attribute(args.thrift_debug_counter_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_debug_counter_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_debug_counter_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_debug_counter_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_debug_counter_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_debug_counter_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_debug_counter_attribute");
  }

  switch_sai_rpc_sai_thrift_get_debug_counter_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_debug_counter_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_debug_counter_attribute_result result;
  try {
    iface_->sai_thrift_get_debug_counter_attribute(result.success, args.thrift_debug_counter_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_debug_counter_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_debug_counter_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_debug_counter_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_debug_counter_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_debug_counter_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_nat(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_nat", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_nat");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_nat");
  }

  switch_sai_rpc_sai_thrift_create_nat_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_nat", bytes);
  }

  switch_sai_rpc_sai_thrift_create_nat_result result;
  try {
    result.success = iface_->sai_thrift_create_nat(args.thrift_nat_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_nat");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_nat", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_nat");
  }

  oprot->writeMessageBegin("sai_thrift_create_nat", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_nat", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_nat(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_nat", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_nat");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_nat");
  }

  switch_sai_rpc_sai_thrift_remove_nat_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_nat", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_nat_result result;
  try {
    result.success = iface_->sai_thrift_remove_nat(args.thrift_nat_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_nat");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_nat", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_nat");
  }

  oprot->writeMessageBegin("sai_thrift_remove_nat", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_nat", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_nat_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_nat_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_nat_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_nat_attribute");
  }

  switch_sai_rpc_sai_thrift_set_nat_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_nat_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_nat_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_nat_attribute(args.thrift_nat_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_nat_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_nat_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_nat_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_nat_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_nat_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_nat_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_nat_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_nat_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_nat_attribute");
  }

  switch_sai_rpc_sai_thrift_get_nat_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_nat_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_nat_attribute_result result;
  try {
    iface_->sai_thrift_get_nat_attribute(result.success, args.thrift_nat_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_nat_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_nat_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_nat_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_nat_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_nat_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_bfd(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_bfd", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_bfd");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_bfd");
  }

  switch_sai_rpc_sai_thrift_create_bfd_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_bfd", bytes);
  }

  switch_sai_rpc_sai_thrift_create_bfd_result result;
  try {
    result.success = iface_->sai_thrift_create_bfd(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_bfd");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_bfd", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_bfd");
  }

  oprot->writeMessageBegin("sai_thrift_create_bfd", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_bfd", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_bfd(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_bfd", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_bfd");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_bfd");
  }

  switch_sai_rpc_sai_thrift_remove_bfd_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_bfd", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_bfd_result result;
  try {
    result.success = iface_->sai_thrift_remove_bfd(args.bfd_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_bfd");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_bfd", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bfd");
  }

  oprot->writeMessageBegin("sai_thrift_remove_bfd", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bfd", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_bfd_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_bfd_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_bfd_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_bfd_attribute");
  }

  switch_sai_rpc_sai_thrift_set_bfd_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_bfd_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_bfd_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_bfd_attribute(args.bfd_oid, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_bfd_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_bfd_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_bfd_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_bfd_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_bfd_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_bfd_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_bfd_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_bfd_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_bfd_attribute");
  }

  switch_sai_rpc_sai_thrift_get_bfd_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_bfd_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_bfd_attribute_result result;
  try {
    iface_->sai_thrift_get_bfd_attribute(result.success, args.bfd_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_bfd_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_bfd_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_bfd_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_bfd_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_bfd_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_y1731_meg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_y1731_meg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_y1731_meg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_y1731_meg");
  }

  switch_sai_rpc_sai_thrift_create_y1731_meg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_y1731_meg", bytes);
  }

  switch_sai_rpc_sai_thrift_create_y1731_meg_result result;
  try {
    result.success = iface_->sai_thrift_create_y1731_meg(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_y1731_meg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_y1731_meg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_y1731_meg");
  }

  oprot->writeMessageBegin("sai_thrift_create_y1731_meg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_y1731_meg", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_y1731_meg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_y1731_meg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_y1731_meg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_meg");
  }

  switch_sai_rpc_sai_thrift_remove_y1731_meg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_meg", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_y1731_meg_result result;
  try {
    result.success = iface_->sai_thrift_remove_y1731_meg(args.y1731_meg_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_meg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_y1731_meg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_meg");
  }

  oprot->writeMessageBegin("sai_thrift_remove_y1731_meg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_meg", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_y1731_meg_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_y1731_meg_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_y1731_meg_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_y1731_meg_attribute");
  }

  switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_y1731_meg_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_y1731_meg_attribute(args.y1731_meg_oid, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_y1731_meg_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_y1731_meg_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_y1731_meg_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_y1731_meg_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_y1731_meg_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_y1731_meg_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_y1731_meg_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_y1731_meg_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_y1731_meg_attribute");
  }

  switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_y1731_meg_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_result result;
  try {
    iface_->sai_thrift_get_y1731_meg_attribute(result.success, args.y1731_meg_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_y1731_meg_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_y1731_meg_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_y1731_meg_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_y1731_meg_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_y1731_meg_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_y1731_session(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_y1731_session", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_y1731_session");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_y1731_session");
  }

  switch_sai_rpc_sai_thrift_create_y1731_session_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_y1731_session", bytes);
  }

  switch_sai_rpc_sai_thrift_create_y1731_session_result result;
  try {
    result.success = iface_->sai_thrift_create_y1731_session(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_y1731_session");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_y1731_session", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_y1731_session");
  }

  oprot->writeMessageBegin("sai_thrift_create_y1731_session", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_y1731_session", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_y1731_session(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_y1731_session", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_y1731_session");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_session");
  }

  switch_sai_rpc_sai_thrift_remove_y1731_session_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_session", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_y1731_session_result result;
  try {
    result.success = iface_->sai_thrift_remove_y1731_session(args.y1731_session_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_session");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_y1731_session", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_session");
  }

  oprot->writeMessageBegin("sai_thrift_remove_y1731_session", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_session", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_y1731_session_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_y1731_session_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_y1731_session_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_y1731_session_attribute");
  }

  switch_sai_rpc_sai_thrift_set_y1731_session_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_y1731_session_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_y1731_session_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_y1731_session_attribute(args.y1731_session_oid, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_y1731_session_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_y1731_session_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_y1731_session_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_y1731_session_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_y1731_session_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_y1731_session_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_y1731_session_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_attribute");
  }

  switch_sai_rpc_sai_thrift_get_y1731_session_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_y1731_session_attribute_result result;
  try {
    iface_->sai_thrift_get_y1731_session_attribute(result.success, args.y1731_session_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_y1731_session_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_y1731_session_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_y1731_rmep(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_y1731_rmep", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_y1731_rmep");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_y1731_rmep");
  }

  switch_sai_rpc_sai_thrift_create_y1731_rmep_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_y1731_rmep", bytes);
  }

  switch_sai_rpc_sai_thrift_create_y1731_rmep_result result;
  try {
    result.success = iface_->sai_thrift_create_y1731_rmep(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_y1731_rmep");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_y1731_rmep", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_y1731_rmep");
  }

  oprot->writeMessageBegin("sai_thrift_create_y1731_rmep", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_y1731_rmep", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_y1731_rmep(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_y1731_rmep", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_y1731_rmep");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_rmep");
  }

  switch_sai_rpc_sai_thrift_remove_y1731_rmep_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_rmep", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_y1731_rmep_result result;
  try {
    result.success = iface_->sai_thrift_remove_y1731_rmep(args.y1731_rmep_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_rmep");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_y1731_rmep", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_rmep");
  }

  oprot->writeMessageBegin("sai_thrift_remove_y1731_rmep", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_y1731_rmep", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_y1731_rmep_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_y1731_rmep_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_y1731_rmep_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_y1731_rmep_attribute");
  }

  switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_y1731_rmep_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_y1731_rmep_attribute(args.y1731_rmep_oid, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_y1731_rmep_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_y1731_rmep_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_y1731_rmep_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_y1731_rmep_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_y1731_rmep_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_y1731_rmep_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_y1731_rmep_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_y1731_rmep_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_y1731_rmep_attribute");
  }

  switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_y1731_rmep_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_result result;
  try {
    iface_->sai_thrift_get_y1731_rmep_attribute(result.success, args.y1731_rmep_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_y1731_rmep_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_y1731_rmep_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_y1731_rmep_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_y1731_rmep_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_y1731_rmep_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_y1731_session_lm_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_y1731_session_lm_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_lm_stats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_lm_stats");
  }

  switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_lm_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_result result;
  try {
    iface_->sai_thrift_get_y1731_session_lm_stats(result.success, args.y1731_session_oid, args.lm_stats_ids, args.number_of_stats);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_lm_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_y1731_session_lm_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_lm_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_y1731_session_lm_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_y1731_session_lm_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_port");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_port");
  }

  switch_sai_rpc_sai_thrift_create_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_port", bytes);
  }

  switch_sai_rpc_sai_thrift_create_port_result result;
  try {
    result.success = iface_->sai_thrift_create_port(args.port_name, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_port");
  }

  oprot->writeMessageBegin("sai_thrift_create_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_port");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_port");
  }

  switch_sai_rpc_sai_thrift_remove_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_port", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_port_result result;
  try {
    result.success = iface_->sai_thrift_remove_port(args.port_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_port");
  }

  oprot->writeMessageBegin("sai_thrift_remove_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_ptp_domain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_ptp_domain", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_ptp_domain");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_ptp_domain");
  }

  switch_sai_rpc_sai_thrift_create_ptp_domain_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_ptp_domain", bytes);
  }

  switch_sai_rpc_sai_thrift_create_ptp_domain_result result;
  try {
    result.success = iface_->sai_thrift_create_ptp_domain(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_ptp_domain");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_ptp_domain", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_ptp_domain");
  }

  oprot->writeMessageBegin("sai_thrift_create_ptp_domain", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_ptp_domain", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_ptp_domain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_ptp_domain", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_ptp_domain");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_ptp_domain");
  }

  switch_sai_rpc_sai_thrift_remove_ptp_domain_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_ptp_domain", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_ptp_domain_result result;
  try {
    result.success = iface_->sai_thrift_remove_ptp_domain(args.ptp_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_ptp_domain");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_ptp_domain", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_ptp_domain");
  }

  oprot->writeMessageBegin("sai_thrift_remove_ptp_domain", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_ptp_domain", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_ptp_domain_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_ptp_domain_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_ptp_domain_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_ptp_domain_attribute");
  }

  switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_ptp_domain_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_ptp_domain_attribute(args.ptp_oid, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_ptp_domain_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_ptp_domain_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_ptp_domain_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_ptp_domain_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_ptp_domain_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_ptp_domain_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_ptp_domain_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_ptp_domain_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_ptp_domain_attribute");
  }

  switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_ptp_domain_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_result result;
  try {
    iface_->sai_thrift_get_ptp_domain_attribute(result.success, args.ptp_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_ptp_domain_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_ptp_domain_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_ptp_domain_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_ptp_domain_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_ptp_domain_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_es(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_es", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_es");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_es");
  }

  switch_sai_rpc_sai_thrift_create_es_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_es", bytes);
  }

  switch_sai_rpc_sai_thrift_create_es_result result;
  try {
    result.success = iface_->sai_thrift_create_es(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_es");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_es", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_es");
  }

  oprot->writeMessageBegin("sai_thrift_create_es", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_es", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_es(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_es", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_es");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_es");
  }

  switch_sai_rpc_sai_thrift_remove_es_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_es", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_es_result result;
  try {
    result.success = iface_->sai_thrift_remove_es(args.es_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_es");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_es", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_es");
  }

  oprot->writeMessageBegin("sai_thrift_remove_es", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_es", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_es_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_es_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_es_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_es_attribute");
  }

  switch_sai_rpc_sai_thrift_set_es_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_es_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_es_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_es_attribute(args.es_oid, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_es_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_es_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_es_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_es_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_es_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_es_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_es_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_es_attribute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_es_attribute");
  }

  switch_sai_rpc_sai_thrift_get_es_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_es_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_es_attribute_result result;
  try {
    iface_->sai_thrift_get_es_attribute(result.success, args.es_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_es_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_es_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_es_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_es_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_es_attribute", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > switch_sai_rpcProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< switch_sai_rpcIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< switch_sai_rpcIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new switch_sai_rpcProcessor(handler));
  return processor;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_port_attribute(port_id, thrift_attr);
  return recv_sai_thrift_set_port_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_port_attribute_pargs args;
  args.port_id = &port_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_port_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t port_id)
{
  int32_t seqid = send_sai_thrift_get_port_attribute(port_id);
  recv_sai_thrift_get_port_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_attribute(const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_attribute_pargs args;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_port_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_port_stats(port_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_port_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_stats(const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_stats_pargs args;
  args.port_id = &port_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_port_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_port_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_port_stats_ext(port_id, counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_port_stats_ext(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_stats_ext(const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_stats_ext_pargs args;
  args.port_id = &port_id;
  args.counter_ids = &counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_stats_ext(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_stats_ext") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_port_stats_ext_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_stats_ext failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
{
  int32_t seqid = send_sai_thrift_clear_port_all_stats(port_id);
  return recv_sai_thrift_clear_port_all_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_port_all_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs args;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_port_all_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_port_all_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_port_all_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_port_all_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_port_stats(const sai_thrift_object_id_t port_id, const int32_t number_of_counters, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids)
{
  int32_t seqid = send_sai_thrift_clear_port_stats(port_id, number_of_counters, counter_ids);
  return recv_sai_thrift_clear_port_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_port_stats(const sai_thrift_object_id_t port_id, const int32_t number_of_counters, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_port_stats_pargs args;
  args.port_id = &port_id;
  args.number_of_counters = &number_of_counters;
  args.counter_ids = &counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_port_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_port_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_port_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_port_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_fdb_entry(thrift_fdb_entry, thrift_attr_list);
  return recv_sai_thrift_create_fdb_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_fdb_entry_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_fdb_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_fdb_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_fdb_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_fdb_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t seqid = send_sai_thrift_delete_fdb_entry(thrift_fdb_entry);
  return recv_sai_thrift_delete_fdb_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_delete_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_delete_fdb_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_delete_fdb_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_delete_fdb_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_delete_fdb_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_flush_fdb_entries(thrift_attr_list);
  return recv_sai_thrift_flush_fdb_entries(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_flush_fdb_entries", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_flush_fdb_entries(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_flush_fdb_entries") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_flush_fdb_entries_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_flush_fdb_entries failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_fdb_entry_attribute(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_fdb_entry_attribute(thrift_fdb_entry, thrift_attr);
  return recv_sai_thrift_set_fdb_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_fdb_entry_attribute(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_fdb_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_fdb_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_fdb_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_fdb_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_fdb_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_fdb_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t seqid = send_sai_thrift_get_fdb_entry_attribute(thrift_fdb_entry);
  recv_sai_thrift_get_fdb_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_fdb_entry_attribute(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_fdb_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_fdb_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_fdb_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_fdb_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_fdb_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_vlan(thrift_attr_list);
  return recv_sai_thrift_create_vlan(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_vlan", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_vlan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_vlan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_vlan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
{
  int32_t seqid = send_sai_thrift_remove_vlan(vlan_oid);
  return recv_sai_thrift_remove_vlan(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_vlan", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_pargs args;
  args.vlan_oid = &vlan_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_vlan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_vlan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_vlan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_vlan_stats(vlan_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_vlan_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_stats(const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_stats_pargs args;
  args.vlan_id = &vlan_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_vlan_stats_ext(vlan_id, thrift_counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_vlan_stats_ext(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_stats_ext(const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_stats_ext_pargs args;
  args.vlan_id = &vlan_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_stats_ext(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_stats_ext") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_stats_ext_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_stats_ext failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_vlan_stats(const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_clear_vlan_stats(vlan_id, thrift_counter_ids, number_of_counters);
  return recv_sai_thrift_clear_vlan_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_vlan_stats(const sai_thrift_object_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_vlan_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_vlan_stats_pargs args;
  args.vlan_id = &vlan_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_vlan_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_vlan_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_vlan_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_vlan_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_vlan_member(thrift_attr_list);
  return recv_sai_thrift_create_vlan_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_vlan_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_vlan_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_vlan_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_vlan_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vlan_member_id)
{
  int32_t seqid = send_sai_thrift_get_vlan_member_attribute(vlan_member_id);
  recv_sai_thrift_get_vlan_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t seqid = send_sai_thrift_remove_vlan_member(vlan_member_id);
  return recv_sai_thrift_remove_vlan_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_vlan_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_member_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_vlan_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_vlan_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_vlan_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_vlan_attribute(vlan_id, thrift_attr);
  return recv_sai_thrift_set_vlan_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_vlan_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs args;
  args.vlan_id = &vlan_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_vlan_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_vlan_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_vlan_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_vlan_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_vlan_member_attribute(vlan_member_id, thrift_attr);
  return recv_sai_thrift_set_vlan_member_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_vlan_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_vlan_member_attribute_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_vlan_member_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_vlan_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_vlan_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_vlan_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vlan_id)
{
  int32_t seqid = send_sai_thrift_get_vlan_attribute(vlan_id);
  recv_sai_thrift_get_vlan_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_attribute(const sai_thrift_object_id_t vlan_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs args;
  args.vlan_id = &vlan_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_id(sai_thrift_result_t& _return, const sai_thrift_object_id_t vlan_id)
{
  int32_t seqid = send_sai_thrift_get_vlan_id(vlan_id);
  recv_sai_thrift_get_vlan_id(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_id(const sai_thrift_object_id_t vlan_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_id_pargs args;
  args.vlan_id = &vlan_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_id(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_create_vlan_members(sai_thrift_results_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_lists, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t seqid = send_sai_thrift_create_vlan_members(thrift_attr_lists, thrift_attr_count_lists, mode);
  recv_sai_thrift_create_vlan_members(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_vlan_members(const std::vector<sai_thrift_attribute_t> & thrift_attr_lists, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_vlan_members", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_members_pargs args;
  args.thrift_attr_lists = &thrift_attr_lists;
  args.thrift_attr_count_lists = &thrift_attr_count_lists;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_create_vlan_members(sai_thrift_results_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_vlan_members") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_create_vlan_members_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan_members failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_remove_vlan_members(sai_thrift_status_list_t& _return, const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, const int8_t mode)
{
  int32_t seqid = send_sai_thrift_remove_vlan_members(thrift_object_id_list, mode);
  recv_sai_thrift_remove_vlan_members(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_vlan_members(const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, const int8_t mode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_vlan_members", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_members_pargs args;
  args.thrift_object_id_list = &thrift_object_id_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_vlan_members(sai_thrift_status_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_vlan_members") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_remove_vlan_members_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan_members failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_virtual_router(thrift_attr_list);
  return recv_sai_thrift_create_virtual_router(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_virtual_router", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_virtual_router_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_virtual_router(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_virtual_router") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_virtual_router_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_virtual_router failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
{
  int32_t seqid = send_sai_thrift_remove_virtual_router(vr_id);
  return recv_sai_thrift_remove_virtual_router(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_virtual_router", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_virtual_router_pargs args;
  args.vr_id = &vr_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_virtual_router(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_virtual_router") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_virtual_router_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_virtual_router failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_virtual_router_attribute(const sai_thrift_object_id_t vr_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_virtual_router_attribute(vr_id, thrift_attr);
  return recv_sai_thrift_set_virtual_router_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_virtual_router_attribute(const sai_thrift_object_id_t vr_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_virtual_router_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_virtual_router_attribute_pargs args;
  args.vr_id = &vr_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_virtual_router_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_virtual_router_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_virtual_router_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_virtual_router_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_virtual_router_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vr_id)
{
  int32_t seqid = send_sai_thrift_get_virtual_router_attribute(vr_id);
  recv_sai_thrift_get_virtual_router_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_virtual_router_attribute(const sai_thrift_object_id_t vr_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_virtual_router_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_virtual_router_attribute_pargs args;
  args.vr_id = &vr_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_virtual_router_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_virtual_router_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_virtual_router_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_virtual_router_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_route(thrift_route_entry, thrift_attr_list);
  return recv_sai_thrift_create_route(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_route", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_route_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_route(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_route") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_route_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_route failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t seqid = send_sai_thrift_remove_route(thrift_route_entry);
  return recv_sai_thrift_remove_route(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_route", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_route_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_route(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_route") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_route_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_route failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_route_attribute(const sai_thrift_route_entry_t& thrift_route_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_route_attribute(thrift_route_entry, thrift_attr);
  return recv_sai_thrift_set_route_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_route_attribute(const sai_thrift_route_entry_t& thrift_route_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_route_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_route_attribute_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_route_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_route_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_route_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_route_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_route_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t seqid = send_sai_thrift_get_route_attribute(thrift_route_entry);
  recv_sai_thrift_get_route_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_route_attribute(const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_route_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_route_attribute_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_route_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_route_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_route_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_route_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const std::vector<sai_thrift_attribute_t> & thrift_attr_list, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t seqid = send_sai_thrift_create_routes(thrift_route_entry_list, thrift_attr_list, thrift_attr_count_lists, mode);
  return recv_sai_thrift_create_routes(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const std::vector<sai_thrift_attribute_t> & thrift_attr_list, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_routes", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_routes_pargs args;
  args.thrift_route_entry_list = &thrift_route_entry_list;
  args.thrift_attr_list = &thrift_attr_list;
  args.thrift_attr_count_lists = &thrift_attr_count_lists;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_routes(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_routes") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_routes_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_routes failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
{
  int32_t seqid = send_sai_thrift_remove_routes(thrift_route_entry_list, mode);
  return recv_sai_thrift_remove_routes(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_routes", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_routes_pargs args;
  args.thrift_route_entry_list = &thrift_route_entry_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_routes(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_routes") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_routes_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_routes failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_routes_attribute(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const std::vector<sai_thrift_attribute_t> & thrift_attr_list, const int8_t mode)
{
  int32_t seqid = send_sai_thrift_set_routes_attribute(thrift_route_entry_list, thrift_attr_list, mode);
  return recv_sai_thrift_set_routes_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_routes_attribute(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const std::vector<sai_thrift_attribute_t> & thrift_attr_list, const int8_t mode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_routes_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_routes_attribute_pargs args;
  args.thrift_route_entry_list = &thrift_route_entry_list;
  args.thrift_attr_list = &thrift_attr_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_routes_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_routes_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_routes_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_routes_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_routes_attribute(sai_thrift_attribute_list_t& _return, const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
{
  int32_t seqid = send_sai_thrift_get_routes_attribute(thrift_route_entry_list, mode);
  recv_sai_thrift_get_routes_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_routes_attribute(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_routes_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_routes_attribute_pargs args;
  args.thrift_route_entry_list = &thrift_route_entry_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_routes_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_routes_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_routes_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_routes_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_router_interface(thrift_attr_list);
  return recv_sai_thrift_create_router_interface(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_router_interface", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_router_interface_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_router_interface(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_router_interface") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_router_interface_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_router_interface failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
{
  int32_t seqid = send_sai_thrift_remove_router_interface(rif_id);
  return recv_sai_thrift_remove_router_interface(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_router_interface", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_router_interface_pargs args;
  args.rif_id = &rif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_router_interface(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_router_interface") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_router_interface_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_router_interface failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_router_interface_attribute(rif_id, thrift_attr);
  return recv_sai_thrift_set_router_interface_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_router_interface_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs args;
  args.rif_id = &rif_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_router_interface_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_router_interface_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_router_interface_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_router_interface_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t rif_id)
{
  int32_t seqid = send_sai_thrift_get_router_interface_attribute(rif_id);
  recv_sai_thrift_get_router_interface_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_router_interface_attribute(const sai_thrift_object_id_t rif_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_router_interface_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_router_interface_attribute_pargs args;
  args.rif_id = &rif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_router_interface_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_router_interface_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_router_interface_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_router_interface_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_router_interface_get_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_router_interface_get_stats(rif_id, thrift_counter_ids, number_of_counters);
  recv_sai_thrift_router_interface_get_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_router_interface_get_stats(const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_router_interface_get_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_router_interface_get_stats_pargs args;
  args.rif_id = &rif_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_router_interface_get_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_router_interface_get_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_router_interface_get_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_router_interface_get_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_router_interface_get_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_router_interface_get_stats_ext(rif_id, thrift_counter_ids, mode, number_of_counters);
  recv_sai_thrift_router_interface_get_stats_ext(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_router_interface_get_stats_ext(const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_router_interface_get_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_pargs args;
  args.rif_id = &rif_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_router_interface_get_stats_ext(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_router_interface_get_stats_ext") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_router_interface_get_stats_ext_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_router_interface_get_stats_ext failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_router_interface_clear_stats(const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_router_interface_clear_stats(rif_id, thrift_counter_ids, number_of_counters);
  return recv_sai_thrift_router_interface_clear_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_router_interface_clear_stats(const sai_thrift_object_id_t rif_id, const std::vector<sai_thrift_router_interface_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_router_interface_clear_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_router_interface_clear_stats_pargs args;
  args.rif_id = &rif_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_router_interface_clear_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_router_interface_clear_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_router_interface_clear_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_router_interface_clear_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_next_hop(thrift_attr_list);
  return recv_sai_thrift_create_next_hop(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_next_hop", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_next_hop(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_next_hop") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_next_hop_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
{
  int32_t seqid = send_sai_thrift_remove_next_hop(next_hop_id);
  return recv_sai_thrift_remove_next_hop(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_pargs args;
  args.next_hop_id = &next_hop_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_next_hop(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_next_hop") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_next_hop_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_next_hop_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t next_hop_id)
{
  int32_t seqid = send_sai_thrift_get_next_hop_attribute(next_hop_id);
  recv_sai_thrift_get_next_hop_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_next_hop_attribute(const sai_thrift_object_id_t next_hop_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_next_hop_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_next_hop_attribute_pargs args;
  args.next_hop_id = &next_hop_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_next_hop_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_next_hop_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_next_hop_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_next_hop_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_next_hop_group(thrift_attr_list);
  return recv_sai_thrift_create_next_hop_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_next_hop_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_next_hop_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_next_hop_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_next_hop_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t seqid = send_sai_thrift_remove_next_hop_group(nhop_group_oid);
  return recv_sai_thrift_remove_next_hop_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs args;
  args.nhop_group_oid = &nhop_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_next_hop_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_next_hop_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_next_hop_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_next_hop_group_attribute(const sai_thrift_object_id_t nhop_group_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_next_hop_group_attribute(nhop_group_oid, thrift_attr);
  return recv_sai_thrift_set_next_hop_group_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_next_hop_group_attribute(const sai_thrift_object_id_t nhop_group_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_next_hop_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_pargs args;
  args.nhop_group_oid = &nhop_group_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_next_hop_group_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_next_hop_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_next_hop_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_next_hop_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_next_hop_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t seqid = send_sai_thrift_get_next_hop_group_attribute(nhop_group_oid);
  recv_sai_thrift_get_next_hop_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_next_hop_group_attribute(const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_next_hop_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_pargs args;
  args.nhop_group_oid = &nhop_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_next_hop_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_next_hop_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_next_hop_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_next_hop_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_next_hop_group_member(thrift_attr_list);
  return recv_sai_thrift_create_next_hop_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_next_hop_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_next_hop_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_next_hop_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t seqid = send_sai_thrift_remove_next_hop_group_member(nhop_group_member_oid);
  return recv_sai_thrift_remove_next_hop_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs args;
  args.nhop_group_member_oid = &nhop_group_member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_next_hop_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_next_hop_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_next_hop_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t seqid = send_sai_thrift_get_next_hop_group_member_attribute(nhop_group_member_oid);
  recv_sai_thrift_get_next_hop_group_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_next_hop_group_member_attribute(const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_next_hop_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_pargs args;
  args.nhop_group_member_oid = &nhop_group_member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_next_hop_group_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_next_hop_group_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_next_hop_group_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_next_hop_group_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_lag(thrift_attr_list);
  return recv_sai_thrift_create_lag(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_lag", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_lag_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_lag(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_lag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_lag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_lag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
{
  int32_t seqid = send_sai_thrift_remove_lag(lag_id);
  return recv_sai_thrift_remove_lag(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_lag", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_lag_pargs args;
  args.lag_id = &lag_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_lag(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_lag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_lag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_lag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_lag_attribute(lag_id, thrift_attr);
  return recv_sai_thrift_set_lag_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_lag_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_lag_attribute_pargs args;
  args.lag_id = &lag_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_lag_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_lag_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_lag_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_lag_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_lag_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t lag_id)
{
  int32_t seqid = send_sai_thrift_get_lag_attribute(lag_id);
  recv_sai_thrift_get_lag_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_lag_attribute(const sai_thrift_object_id_t lag_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_lag_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_lag_attribute_pargs args;
  args.lag_id = &lag_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_lag_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_lag_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_lag_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_lag_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_lag_member(thrift_attr_list);
  return recv_sai_thrift_create_lag_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_lag_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_lag_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_lag_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_lag_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_lag_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_lag_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
{
  int32_t seqid = send_sai_thrift_remove_lag_member(lag_member_id);
  return recv_sai_thrift_remove_lag_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_lag_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_lag_member_pargs args;
  args.lag_member_id = &lag_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_lag_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_lag_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_lag_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_lag_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_lag_member_attribute(const sai_thrift_object_id_t lag_member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_lag_member_attribute(lag_member_id, thrift_attr);
  return recv_sai_thrift_set_lag_member_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_lag_member_attribute(const sai_thrift_object_id_t lag_member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_lag_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_lag_member_attribute_pargs args;
  args.lag_member_id = &lag_member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_lag_member_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_lag_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_lag_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_lag_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t lag_member_id)
{
  int32_t seqid = send_sai_thrift_get_lag_member_attribute(lag_member_id);
  recv_sai_thrift_get_lag_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_lag_member_attribute(const sai_thrift_object_id_t lag_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_lag_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs args;
  args.lag_member_id = &lag_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_lag_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_lag_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_stp_entry(thrift_attr_list);
  return recv_sai_thrift_create_stp_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_stp_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_stp_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_stp_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_stp_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_stp_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_stp_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
{
  int32_t seqid = send_sai_thrift_remove_stp_entry(stp_id);
  return recv_sai_thrift_remove_stp_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_stp_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_stp_entry_pargs args;
  args.stp_id = &stp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_stp_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_stp_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_stp_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_stp_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_stp_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t stp_id)
{
  int32_t seqid = send_sai_thrift_get_stp_attribute(stp_id);
  recv_sai_thrift_get_stp_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_stp_attribute(const sai_thrift_object_id_t stp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_stp_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_stp_attribute_pargs args;
  args.stp_id = &stp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_stp_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_stp_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_stp_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_stp_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_stp_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_stp_port(thrift_attr_list);
  return recv_sai_thrift_create_stp_port(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_stp_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_stp_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_stp_port_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_stp_port(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_stp_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_stp_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_stp_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_id)
{
  int32_t seqid = send_sai_thrift_remove_stp_port(stp_port_id);
  return recv_sai_thrift_remove_stp_port(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_stp_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_stp_port_pargs args;
  args.stp_port_id = &stp_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_stp_port(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_stp_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_stp_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_stp_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_stp_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t stp_port_id)
{
  int32_t seqid = send_sai_thrift_get_stp_port_attribute(stp_port_id);
  recv_sai_thrift_get_stp_port_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_stp_port_attribute(const sai_thrift_object_id_t stp_port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_stp_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_stp_port_attribute_pargs args;
  args.stp_port_id = &stp_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_stp_port_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_stp_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_stp_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_stp_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state)
{
  int32_t seqid = send_sai_thrift_set_stp_port_state(stp_id, port_id, stp_port_state);
  return recv_sai_thrift_set_stp_port_state(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_stp_port_state", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_stp_port_state_pargs args;
  args.stp_id = &stp_id;
  args.port_id = &port_id;
  args.stp_port_state = &stp_port_state;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_stp_port_state(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_stp_port_state") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_stp_port_state_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_stp_port_state failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_port_stp_port_state_t switch_sai_rpcConcurrentClient::sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id)
{
  int32_t seqid = send_sai_thrift_get_stp_port_state(stp_id, port_id);
  return recv_sai_thrift_get_stp_port_state(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_stp_port_state", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_stp_port_state_pargs args;
  args.stp_id = &stp_id;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_port_stp_port_state_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_stp_port_state(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_stp_port_state") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_port_stp_port_state_t _return;
      switch_sai_rpc_sai_thrift_get_stp_port_state_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_stp_port_state failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_create_stp_ports(sai_thrift_results_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_lists, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t seqid = send_sai_thrift_create_stp_ports(thrift_attr_lists, thrift_attr_count_lists, mode);
  recv_sai_thrift_create_stp_ports(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_stp_ports(const std::vector<sai_thrift_attribute_t> & thrift_attr_lists, const std::vector<int32_t> & thrift_attr_count_lists, const int8_t mode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_stp_ports", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_stp_ports_pargs args;
  args.thrift_attr_lists = &thrift_attr_lists;
  args.thrift_attr_count_lists = &thrift_attr_count_lists;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_create_stp_ports(sai_thrift_results_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_stp_ports") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_create_stp_ports_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_stp_ports failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_remove_stp_ports(sai_thrift_status_list_t& _return, const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, const int8_t mode)
{
  int32_t seqid = send_sai_thrift_remove_stp_ports(thrift_object_id_list, mode);
  recv_sai_thrift_remove_stp_ports(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_stp_ports(const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, const int8_t mode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_stp_ports", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_stp_ports_pargs args;
  args.thrift_object_id_list = &thrift_object_id_list;
  args.mode = &mode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_stp_ports(sai_thrift_status_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_stp_ports") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_remove_stp_ports_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_stp_ports failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_neighbor_entry(thrift_neighbor_entry, thrift_attr_list);
  return recv_sai_thrift_create_neighbor_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_neighbor_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_neighbor_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_neighbor_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_neighbor_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t seqid = send_sai_thrift_remove_neighbor_entry(thrift_neighbor_entry);
  return recv_sai_thrift_remove_neighbor_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_neighbor_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_neighbor_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_neighbor_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_all_neighbor_entry()
{
  int32_t seqid = send_sai_thrift_remove_all_neighbor_entry();
  return recv_sai_thrift_remove_all_neighbor_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_all_neighbor_entry()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_all_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_all_neighbor_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_all_neighbor_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_all_neighbor_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_all_neighbor_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_neighbor_entry_attribute(thrift_neighbor_entry, thrift_attr);
  return recv_sai_thrift_set_neighbor_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_neighbor_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_neighbor_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_neighbor_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_neighbor_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_neighbor_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t seqid = send_sai_thrift_get_neighbor_entry_attribute(thrift_neighbor_entry);
  recv_sai_thrift_get_neighbor_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_neighbor_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_neighbor_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_neighbor_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_neighbor_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_neighbor_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& _return, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t seqid = send_sai_thrift_get_switch_attribute(thrift_attr_ids);
  recv_sai_thrift_get_switch_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_switch_attribute(const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_switch_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_attribute_pargs args;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_switch_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_switch_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& _return)
{
  int32_t seqid = send_sai_thrift_get_port_list_by_front_port();
  recv_sai_thrift_get_port_list_by_front_port(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_list_by_front_port()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_list_by_front_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_list_by_front_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_list_by_front_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_cpu_port_id()
{
  int32_t seqid = send_sai_thrift_get_cpu_port_id();
  return recv_sai_thrift_get_cpu_port_id(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_cpu_port_id()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_cpu_port_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_cpu_port_id(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_cpu_port_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_cpu_port_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_cpu_port_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_default_trap_group()
{
  int32_t seqid = send_sai_thrift_get_default_trap_group();
  return recv_sai_thrift_get_default_trap_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_default_trap_group()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_default_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_trap_group_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_default_trap_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_default_trap_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_default_trap_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_trap_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_default_router_id()
{
  int32_t seqid = send_sai_thrift_get_default_router_id();
  return recv_sai_thrift_get_default_router_id(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_default_router_id()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_default_router_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_router_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_default_router_id(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_default_router_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_default_router_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_router_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_default_1q_bridge_id()
{
  int32_t seqid = send_sai_thrift_get_default_1q_bridge_id();
  return recv_sai_thrift_get_default_1q_bridge_id(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_default_1q_bridge_id()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_default_1q_bridge_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_default_1q_bridge_id(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_default_1q_bridge_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_1q_bridge_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_default_vlan_id(sai_thrift_result_t& _return)
{
  int32_t seqid = send_sai_thrift_get_default_vlan_id();
  recv_sai_thrift_get_default_vlan_id(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_default_vlan_id()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_default_vlan_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_default_vlan_id(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_default_vlan_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_default_vlan_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_vlan_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_port_id_by_front_port(const std::string& port_name)
{
  int32_t seqid = send_sai_thrift_get_port_id_by_front_port(port_name);
  return recv_sai_thrift_get_port_id_by_front_port(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_id_by_front_port(const std::string& port_name)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_id_by_front_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs args;
  args.port_name = &port_name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_id_by_front_port(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_id_by_front_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_id_by_front_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attribute)
{
  int32_t seqid = send_sai_thrift_set_switch_attribute(attribute);
  return recv_sai_thrift_set_switch_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attribute)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_switch_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_switch_attribute_pargs args;
  args.attribute = &attribute;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_switch_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_switch_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_switch_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_switch_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_switch()
{
  int32_t seqid = send_sai_thrift_create_switch();
  return recv_sai_thrift_create_switch(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_switch()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_switch", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_switch_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_switch(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_switch") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_switch_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_switch failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_switch()
{
  int32_t seqid = send_sai_thrift_remove_switch();
  return recv_sai_thrift_remove_switch(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_switch()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_switch", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_switch_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_switch(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_switch") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_switch_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_switch failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_switch_stats(std::vector<int64_t> & _return, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_switch_stats(counter_ids, number_of_counters);
  recv_sai_thrift_get_switch_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_switch_stats(const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_switch_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_stats_pargs args;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_switch_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_switch_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_switch_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_switch_stats_ext(std::vector<int64_t> & _return, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_switch_stats_ext(counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_switch_stats_ext(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_switch_stats_ext(const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_switch_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_stats_ext_pargs args;
  args.counter_ids = &counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_switch_stats_ext(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_switch_stats_ext") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_switch_stats_ext_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_stats_ext failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_switch_stats(const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_clear_switch_stats(counter_ids, number_of_counters);
  return recv_sai_thrift_clear_switch_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_switch_stats(const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_switch_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_switch_stats_pargs args;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_switch_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_switch_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_switch_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_switch_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_create_bridge_port(sai_thrift_result_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_bridge_port(thrift_attr_list);
  recv_sai_thrift_create_bridge_port(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_bridge_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_bridge_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bridge_port_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_create_bridge_port(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_bridge_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_create_bridge_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bridge_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t seqid = send_sai_thrift_remove_bridge_port(bridge_port_id);
  return recv_sai_thrift_remove_bridge_port(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_bridge_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bridge_port_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_bridge_port(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_bridge_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_bridge_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bridge_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_bridge_port_list(sai_thrift_result_t& _return, const sai_thrift_object_id_t bridge_id)
{
  int32_t seqid = send_sai_thrift_get_bridge_port_list(bridge_id);
  recv_sai_thrift_get_bridge_port_list(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_bridge_port_list(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_list", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_bridge_port_list(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_bridge_port_list") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_bridge_port_list_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_list failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t bridge_port_id)
{
  int32_t seqid = send_sai_thrift_get_bridge_port_attribute(bridge_port_id);
  recv_sai_thrift_get_bridge_port_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_bridge_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_bridge_port_attribute(bridge_port_id, thrift_attr);
  return recv_sai_thrift_set_bridge_port_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_bridge_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_bridge_port_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_bridge_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_bridge_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_create_bridge(sai_thrift_result_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_bridge(thrift_attr_list);
  recv_sai_thrift_create_bridge(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_bridge(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_bridge", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bridge_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_create_bridge(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_bridge") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_create_bridge_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bridge failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_id)
{
  int32_t seqid = send_sai_thrift_remove_bridge(bridge_id);
  return recv_sai_thrift_remove_bridge(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_bridge", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bridge_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_bridge(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_bridge") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_bridge_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bridge failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_bridge_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t bridge_id)
{
  int32_t seqid = send_sai_thrift_get_bridge_attribute(bridge_id);
  recv_sai_thrift_get_bridge_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_bridge_attribute(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_bridge_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_attribute_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_bridge_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_bridge_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_bridge_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_bridge_attribute(const sai_thrift_object_id_t bridge_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_bridge_attribute(bridge_id, thrift_attr);
  return recv_sai_thrift_set_bridge_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_bridge_attribute(const sai_thrift_object_id_t bridge_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_bridge_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_bridge_attribute_pargs args;
  args.bridge_id = &bridge_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_bridge_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_bridge_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_bridge_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_bridge_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_bridge_port_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_bridge_port_stats(bridge_port_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_bridge_port_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_bridge_port_stats(const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_stats_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_bridge_port_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_bridge_port_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_bridge_port_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_bridge_port_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_bridge_port_stats_ext(bridge_port_id, thrift_counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_bridge_port_stats_ext(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_bridge_port_stats_ext(const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & thrift_counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_bridge_port_stats_ext(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_bridge_port_stats_ext") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_bridge_port_stats_ext_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_stats_ext failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_bridge_port_stats(const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_clear_bridge_port_stats(bridge_port_id, thrift_counter_ids, number_of_counters);
  return recv_sai_thrift_clear_bridge_port_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_bridge_port_stats(const sai_thrift_object_id_t bridge_port_id, const std::vector<sai_thrift_bridge_port_stat_counter_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_bridge_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_bridge_port_stats_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_bridge_port_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_bridge_port_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_bridge_port_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_bridge_port_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hostif(thrift_attr_list);
  return recv_sai_thrift_create_hostif(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hostif", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hostif(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hostif") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hostif_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t seqid = send_sai_thrift_remove_hostif(thrift_hif_id);
  return recv_sai_thrift_remove_hostif(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hostif", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hostif(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hostif") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hostif_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_hostif_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t seqid = send_sai_thrift_get_hostif_attribute(thrift_hif_id);
  recv_sai_thrift_get_hostif_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_hostif_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hostif_attribute_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_hostif_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_hostif_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_hostif_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hostif_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hostif_attribute(thrift_hif_id, thrift_attr);
  return recv_sai_thrift_set_hostif_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hostif_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hostif_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hostif_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hostif_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hostif_table_entry(thrift_attr_list);
  return recv_sai_thrift_create_hostif_table_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hostif_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hostif_table_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hostif_table_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_table_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t thrift_hostif_table_entry_id)
{
  int32_t seqid = send_sai_thrift_remove_hostif_table_entry(thrift_hostif_table_entry_id);
  return recv_sai_thrift_remove_hostif_table_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t thrift_hostif_table_entry_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs args;
  args.thrift_hostif_table_entry_id = &thrift_hostif_table_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hostif_table_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hostif_table_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_table_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_hostif_table_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hostif_table_entry_id)
{
  int32_t seqid = send_sai_thrift_get_hostif_table_entry_attribute(thrift_hostif_table_entry_id);
  recv_sai_thrift_get_hostif_table_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hostif_table_entry_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_hostif_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_pargs args;
  args.thrift_hostif_table_entry_id = &thrift_hostif_table_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_hostif_table_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_hostif_table_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_hostif_table_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hostif_table_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hostif_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hostif_table_entry_attribute(thrift_hostif_table_entry_id, thrift_attr);
  return recv_sai_thrift_set_hostif_table_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hostif_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hostif_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs args;
  args.thrift_hostif_table_entry_id = &thrift_hostif_table_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hostif_table_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hostif_table_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_table_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hostif_trap_group(thrift_attr_list);
  return recv_sai_thrift_create_hostif_trap_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hostif_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hostif_trap_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hostif_trap_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_trap_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t seqid = send_sai_thrift_remove_hostif_trap_group(thrift_hostif_trap_group_id);
  return recv_sai_thrift_remove_hostif_trap_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hostif_trap_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hostif_trap_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_trap_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_hostif_trap_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t seqid = send_sai_thrift_get_hostif_trap_group_attribute(thrift_hostif_trap_group_id);
  recv_sai_thrift_get_hostif_trap_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_hostif_trap_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_hostif_trap_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_hostif_trap_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_hostif_trap_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hostif_trap_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hostif_trap_group_attribute(thrift_hostif_trap_group_id, thrift_attr);
  return recv_sai_thrift_set_hostif_trap_group_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hostif_trap_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hostif_trap_group_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hostif_trap_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_trap_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hostif_trap(thrift_attr_list);
  return recv_sai_thrift_create_hostif_trap(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hostif_trap", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_trap_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hostif_trap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hostif_trap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hostif_trap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_trap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t seqid = send_sai_thrift_remove_hostif_trap(thrift_hostif_trap_id);
  return recv_sai_thrift_remove_hostif_trap(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_trap", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hostif_trap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hostif_trap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hostif_trap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_trap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_hostif_trap_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t seqid = send_sai_thrift_get_hostif_trap_attribute(thrift_hostif_trap_id);
  recv_sai_thrift_get_hostif_trap_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_hostif_trap_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_hostif_trap_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_hostif_trap_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_hostif_trap_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hostif_trap_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hostif_trap_attribute(thrift_hostif_trap_id, thrift_attr);
  return recv_sai_thrift_set_hostif_trap_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hostif_trap_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hostif_trap_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hostif_trap_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_trap_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_send_hostif_packet(const sai_thrift_object_id_t thrift_hif_id, const std::string& packet_data, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_send_hostif_packet(thrift_hif_id, packet_data, thrift_attr_list);
  return recv_sai_thrift_send_hostif_packet(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_send_hostif_packet(const sai_thrift_object_id_t thrift_hif_id, const std::string& packet_data, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_send_hostif_packet", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_send_hostif_packet_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.packet_data = &packet_data;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_send_hostif_packet(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_send_hostif_packet") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_send_hostif_packet_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_send_hostif_packet failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_table(thrift_attr_list);
  return recv_sai_thrift_create_acl_table(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_table", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_table(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_table") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_table_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_table(acl_table_id);
  return recv_sai_thrift_remove_acl_table(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_pargs args;
  args.acl_table_id = &acl_table_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_table(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_table") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_table_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_acl_table_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t acl_table_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t seqid = send_sai_thrift_get_acl_table_attribute(acl_table_id, thrift_attr_ids);
  recv_sai_thrift_get_acl_table_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_acl_table_attribute(const sai_thrift_object_id_t acl_table_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_acl_table_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_table_attribute_pargs args;
  args.acl_table_id = &acl_table_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_acl_table_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_acl_table_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_acl_table_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_table_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_entry(thrift_attr_list);
  return recv_sai_thrift_create_acl_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
{
  int32_t seqid = send_sai_thrift_remove_acl_entry(acl_entry);
  return recv_sai_thrift_remove_acl_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_entry_pargs args;
  args.acl_entry = &acl_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_acl_entry_attribute(acl_entry_id, thrift_attr);
  return recv_sai_thrift_set_acl_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_acl_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_acl_entry_attribute_pargs args;
  args.acl_entry_id = &acl_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_acl_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_acl_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_acl_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_acl_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_acl_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t acl_entry_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t seqid = send_sai_thrift_get_acl_entry_attribute(acl_entry_id, thrift_attr_ids);
  recv_sai_thrift_get_acl_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_acl_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_entry_attribute_pargs args;
  args.acl_entry_id = &acl_entry_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_acl_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_acl_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_acl_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_table_group(thrift_attr_list);
  return recv_sai_thrift_create_acl_table_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_table_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_table_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_table_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_table_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_table_group(acl_table_group_id);
  return recv_sai_thrift_remove_acl_table_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs args;
  args.acl_table_group_id = &acl_table_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_table_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_table_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_table_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_acl_table_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t seqid = send_sai_thrift_get_acl_table_group_attribute(acl_table_group_id);
  recv_sai_thrift_get_acl_table_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_acl_table_group_attribute(const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_acl_table_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_pargs args;
  args.acl_table_group_id = &acl_table_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_acl_table_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_acl_table_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_acl_table_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_table_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_table_group_member(thrift_attr_list);
  return recv_sai_thrift_create_acl_table_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_table_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_table_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_table_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_table_group_member(acl_table_group_member_id);
  return recv_sai_thrift_remove_acl_table_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs args;
  args.acl_table_group_member_id = &acl_table_group_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_table_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_table_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_acl_table_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t seqid = send_sai_thrift_get_acl_table_group_member_attribute(acl_table_group_member_id);
  recv_sai_thrift_get_acl_table_group_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_acl_table_group_member_attribute(const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_acl_table_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_pargs args;
  args.acl_table_group_member_id = &acl_table_group_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_acl_table_group_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_acl_table_group_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_acl_table_group_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_table_group_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_counter(thrift_attr_list);
  return recv_sai_thrift_create_acl_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_counter(acl_counter_id);
  return recv_sai_thrift_remove_acl_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_counter_pargs args;
  args.acl_counter_id = &acl_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_acl_counter_attribute(std::vector<sai_thrift_attribute_value_t> & _return, const sai_thrift_object_id_t acl_counter_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t seqid = send_sai_thrift_get_acl_counter_attribute(acl_counter_id, thrift_attr_ids);
  recv_sai_thrift_get_acl_counter_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_acl_counter_attribute(const sai_thrift_object_id_t acl_counter_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_acl_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs args;
  args.acl_counter_id = &acl_counter_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_acl_counter_attribute(std::vector<sai_thrift_attribute_value_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_acl_counter_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_counter_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_range(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_range(thrift_attr_list);
  return recv_sai_thrift_create_acl_range(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_range(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_range", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_range_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_range(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_range") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_range_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_range failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_range(const sai_thrift_object_id_t acl_range_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_range(acl_range_id);
  return recv_sai_thrift_remove_acl_range(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_range(const sai_thrift_object_id_t acl_range_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_range", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_range_pargs args;
  args.acl_range_id = &acl_range_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_range(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_range") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_range_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_range failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hash(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hash(thrift_attr_list);
  return recv_sai_thrift_create_hash(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hash(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hash", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hash_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hash(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hash") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hash_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hash failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hash(const sai_thrift_object_id_t hash_id)
{
  int32_t seqid = send_sai_thrift_remove_hash(hash_id);
  return recv_sai_thrift_remove_hash(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hash(const sai_thrift_object_id_t hash_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hash", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hash_pargs args;
  args.hash_id = &hash_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hash(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hash") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hash_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hash failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hash_attribute(const sai_thrift_object_id_t thrift_hash_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hash_attribute(thrift_hash_id, thrift_attr);
  return recv_sai_thrift_set_hash_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hash_attribute(const sai_thrift_object_id_t thrift_hash_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hash_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hash_attribute_pargs args;
  args.thrift_hash_id = &thrift_hash_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hash_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hash_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hash_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hash_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_hash_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_hash_id)
{
  int32_t seqid = send_sai_thrift_get_hash_attribute(thrift_hash_id);
  recv_sai_thrift_get_hash_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_hash_attribute(const sai_thrift_object_id_t thrift_hash_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_hash_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_hash_attribute_pargs args;
  args.thrift_hash_id = &thrift_hash_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_hash_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_hash_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_hash_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_hash_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_udf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_udf_group(thrift_attr_list);
  return recv_sai_thrift_create_udf_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_udf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_udf_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_udf_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_udf_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_udf_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_udf_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_udf_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_udf_group(const sai_thrift_object_id_t udf_group_id)
{
  int32_t seqid = send_sai_thrift_remove_udf_group(udf_group_id);
  return recv_sai_thrift_remove_udf_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_udf_group(const sai_thrift_object_id_t udf_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_udf_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_udf_group_pargs args;
  args.udf_group_id = &udf_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_udf_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_udf_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_udf_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_udf_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_udf_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_udf_group_id)
{
  int32_t seqid = send_sai_thrift_get_udf_group_attribute(thrift_udf_group_id);
  recv_sai_thrift_get_udf_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_udf_group_attribute(const sai_thrift_object_id_t thrift_udf_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_udf_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_udf_group_attribute_pargs args;
  args.thrift_udf_group_id = &thrift_udf_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_udf_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_udf_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_udf_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_udf_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_udf_match(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_udf_match(thrift_attr_list);
  return recv_sai_thrift_create_udf_match(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_udf_match(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_udf_match", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_udf_match_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_udf_match(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_udf_match") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_udf_match_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_udf_match failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_udf_match(const sai_thrift_object_id_t udf_match_id)
{
  int32_t seqid = send_sai_thrift_remove_udf_match(udf_match_id);
  return recv_sai_thrift_remove_udf_match(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_udf_match(const sai_thrift_object_id_t udf_match_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_udf_match", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_udf_match_pargs args;
  args.udf_match_id = &udf_match_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_udf_match(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_udf_match") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_udf_match_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_udf_match failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_udf_match_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_udf_match_id)
{
  int32_t seqid = send_sai_thrift_get_udf_match_attribute(thrift_udf_match_id);
  recv_sai_thrift_get_udf_match_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_udf_match_attribute(const sai_thrift_object_id_t thrift_udf_match_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_udf_match_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_udf_match_attribute_pargs args;
  args.thrift_udf_match_id = &thrift_udf_match_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_udf_match_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_udf_match_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_udf_match_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_udf_match_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_udf(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_udf(thrift_attr_list);
  return recv_sai_thrift_create_udf(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_udf(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_udf", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_udf_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_udf(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_udf") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_udf_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_udf failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_udf(const sai_thrift_object_id_t udf_id)
{
  int32_t seqid = send_sai_thrift_remove_udf(udf_id);
  return recv_sai_thrift_remove_udf(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_udf(const sai_thrift_object_id_t udf_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_udf", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_udf_pargs args;
  args.udf_id = &udf_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_udf(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_udf") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_udf_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_udf failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_udf_attribute(const sai_thrift_object_id_t thrift_udf_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_udf_attribute(thrift_udf_id, thrift_attr);
  return recv_sai_thrift_set_udf_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_udf_attribute(const sai_thrift_object_id_t thrift_udf_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_udf_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_udf_attribute_pargs args;
  args.thrift_udf_id = &thrift_udf_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_udf_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_udf_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_udf_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_udf_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_udf_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_udf_id)
{
  int32_t seqid = send_sai_thrift_get_udf_attribute(thrift_udf_id);
  recv_sai_thrift_get_udf_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_udf_attribute(const sai_thrift_object_id_t thrift_udf_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_udf_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_udf_attribute_pargs args;
  args.thrift_udf_id = &thrift_udf_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_udf_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_udf_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_udf_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_udf_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_twamp_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_twamp_session(thrift_attr_list);
  return recv_sai_thrift_create_twamp_session(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_twamp_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_twamp_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_twamp_session_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_twamp_session(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_twamp_session") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_twamp_session_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_twamp_session failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_twamp_session(const sai_thrift_object_id_t session_id)
{
  int32_t seqid = send_sai_thrift_remove_twamp_session(session_id);
  return recv_sai_thrift_remove_twamp_session(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_twamp_session(const sai_thrift_object_id_t session_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_twamp_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_twamp_session_pargs args;
  args.session_id = &session_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_twamp_session(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_twamp_session") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_twamp_session_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_twamp_session failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_twamp_attribute(const sai_thrift_object_id_t thrift_twamp_session_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_twamp_attribute(thrift_twamp_session_id, thrift_attr);
  return recv_sai_thrift_set_twamp_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_twamp_attribute(const sai_thrift_object_id_t thrift_twamp_session_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_twamp_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_twamp_attribute_pargs args;
  args.thrift_twamp_session_id = &thrift_twamp_session_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_twamp_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_twamp_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_twamp_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_twamp_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_mirror_session(thrift_attr_list);
  return recv_sai_thrift_create_mirror_session(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_mirror_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_mirror_session_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_mirror_session(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_mirror_session") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_mirror_session_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_mirror_session failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
{
  int32_t seqid = send_sai_thrift_remove_mirror_session(session_id);
  return recv_sai_thrift_remove_mirror_session(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_mirror_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_mirror_session_pargs args;
  args.session_id = &session_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_mirror_session(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_mirror_session") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_mirror_session_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_mirror_session failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_mirror_attribute(const sai_thrift_object_id_t thrift_mirror_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_mirror_attribute(thrift_mirror_id, thrift_attr);
  return recv_sai_thrift_set_mirror_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_mirror_attribute(const sai_thrift_object_id_t thrift_mirror_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_mirror_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_mirror_attribute_pargs args;
  args.thrift_mirror_id = &thrift_mirror_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_mirror_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_mirror_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_mirror_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_mirror_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_mirror_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_mirror_id)
{
  int32_t seqid = send_sai_thrift_get_mirror_attribute(thrift_mirror_id);
  recv_sai_thrift_get_mirror_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_mirror_attribute(const sai_thrift_object_id_t thrift_mirror_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_mirror_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_mirror_attribute_pargs args;
  args.thrift_mirror_id = &thrift_mirror_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_mirror_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_mirror_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_mirror_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_mirror_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_inseg_entry(const sai_thrift_inseg_entry_t& thrift_inseg_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_inseg_entry(thrift_inseg_entry, thrift_attr_list);
  return recv_sai_thrift_create_inseg_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_inseg_entry(const sai_thrift_inseg_entry_t& thrift_inseg_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_inseg_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_inseg_entry_pargs args;
  args.thrift_inseg_entry = &thrift_inseg_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_inseg_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_inseg_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_inseg_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_inseg_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_inseg_entry(const sai_thrift_inseg_entry_t& thrift_inseg_entry)
{
  int32_t seqid = send_sai_thrift_remove_inseg_entry(thrift_inseg_entry);
  return recv_sai_thrift_remove_inseg_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_inseg_entry(const sai_thrift_inseg_entry_t& thrift_inseg_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_inseg_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_inseg_entry_pargs args;
  args.thrift_inseg_entry = &thrift_inseg_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_inseg_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_inseg_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_inseg_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_inseg_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_inseg_entry_attribute(const sai_thrift_inseg_entry_t& thrift_inseg_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_inseg_entry_attribute(thrift_inseg_entry, thrift_attr);
  return recv_sai_thrift_set_inseg_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_inseg_entry_attribute(const sai_thrift_inseg_entry_t& thrift_inseg_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_inseg_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_pargs args;
  args.thrift_inseg_entry = &thrift_inseg_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_inseg_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_inseg_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_inseg_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_inseg_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_inseg_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_inseg_entry_t& thrift_inseg_entry)
{
  int32_t seqid = send_sai_thrift_get_inseg_entry_attribute(thrift_inseg_entry);
  recv_sai_thrift_get_inseg_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_inseg_entry_attribute(const sai_thrift_inseg_entry_t& thrift_inseg_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_inseg_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_pargs args;
  args.thrift_inseg_entry = &thrift_inseg_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_inseg_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_inseg_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_inseg_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_inseg_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_dump_log(const std::string& dump_file_name)
{
  int32_t seqid = send_sai_thrift_dump_log(dump_file_name);
  return recv_sai_thrift_dump_log(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_dump_log(const std::string& dump_file_name)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_dump_log", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_dump_log_pargs args;
  args.dump_file_name = &dump_file_name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_dump_log(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_dump_log") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_dump_log_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_dump_log failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_policer(thrift_attr_list);
  return recv_sai_thrift_create_policer(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_policer", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_policer_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_policer(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_policer") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_policer_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_policer failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t seqid = send_sai_thrift_remove_policer(thrift_policer_id);
  return recv_sai_thrift_remove_policer(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_policer", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_policer_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_policer(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_policer") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_policer_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_policer failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_policer_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t seqid = send_sai_thrift_get_policer_attribute(thrift_policer_id);
  recv_sai_thrift_get_policer_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_policer_attribute(const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_policer_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_policer_attribute_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_policer_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_policer_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_policer_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_policer_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_policer_attribute(thrift_policer_id, thrift_attr);
  return recv_sai_thrift_set_policer_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_policer_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_policer_attribute_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_policer_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_policer_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_policer_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_policer_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & _return, const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t seqid = send_sai_thrift_get_policer_stats(thrift_policer_id, thrift_counter_ids);
  recv_sai_thrift_get_policer_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_policer_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_policer_stats_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_policer_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_policer_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_policer_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t seqid = send_sai_thrift_clear_policer_stats(thrift_policer_id, thrift_counter_ids);
  return recv_sai_thrift_clear_policer_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_policer_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_policer_stats_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_policer_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_policer_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_policer_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_policer_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_scheduler_profile(thrift_attr_list);
  return recv_sai_thrift_create_scheduler_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_scheduler_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_scheduler_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_scheduler_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_scheduler_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_scheduler_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
{
  int32_t seqid = send_sai_thrift_remove_scheduler_profile(scheduler_id);
  return recv_sai_thrift_remove_scheduler_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_scheduler_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs args;
  args.scheduler_id = &scheduler_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_scheduler_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_scheduler_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_scheduler_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_scheduler_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_scheduler_id)
{
  int32_t seqid = send_sai_thrift_get_scheduler_attribute(thrift_scheduler_id);
  recv_sai_thrift_get_scheduler_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_scheduler_attribute(const sai_thrift_object_id_t thrift_scheduler_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_scheduler_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_scheduler_attribute_pargs args;
  args.thrift_scheduler_id = &thrift_scheduler_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_scheduler_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_scheduler_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_scheduler_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_scheduler_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_scheduler_attribute(const sai_thrift_object_id_t thrift_scheduler_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_scheduler_attribute(thrift_scheduler_id, thrift_attr);
  return recv_sai_thrift_set_scheduler_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_scheduler_attribute(const sai_thrift_object_id_t thrift_scheduler_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_scheduler_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_scheduler_attribute_pargs args;
  args.thrift_scheduler_id = &thrift_scheduler_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_scheduler_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_scheduler_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_scheduler_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_scheduler_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_scheduler_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_scheduler_group(thrift_attr_list);
  return recv_sai_thrift_create_scheduler_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_scheduler_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_scheduler_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_scheduler_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_scheduler_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_scheduler_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_scheduler_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_scheduler_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_scheduler_group(const sai_thrift_object_id_t scheduler_group_id)
{
  int32_t seqid = send_sai_thrift_remove_scheduler_group(scheduler_group_id);
  return recv_sai_thrift_remove_scheduler_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_scheduler_group(const sai_thrift_object_id_t scheduler_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_scheduler_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_scheduler_group_pargs args;
  args.scheduler_group_id = &scheduler_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_scheduler_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_scheduler_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_scheduler_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_scheduler_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_scheduler_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t scheduler_group_id)
{
  int32_t seqid = send_sai_thrift_get_scheduler_group_attribute(scheduler_group_id);
  recv_sai_thrift_get_scheduler_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_scheduler_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_pargs args;
  args.scheduler_group_id = &scheduler_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_scheduler_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_scheduler_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_scheduler_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_scheduler_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_scheduler_group_attribute(scheduler_group_id, thrift_attr);
  return recv_sai_thrift_set_scheduler_group_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_scheduler_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_pargs args;
  args.scheduler_group_id = &scheduler_group_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_scheduler_group_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_scheduler_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_scheduler_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_scheduler_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_queue_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_queue_stats(queue_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_queue_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_queue_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_queue_stats_pargs args;
  args.queue_id = &queue_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_queue_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_queue_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_queue_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_queue_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_clear_queue_stats(queue_id, counter_ids, number_of_counters);
  return recv_sai_thrift_clear_queue_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_queue_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_queue_stats_pargs args;
  args.queue_id = &queue_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_queue_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_queue_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_queue_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_queue_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_queue(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_queue(thrift_attr_list);
  return recv_sai_thrift_create_queue(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_queue(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_queue", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_queue_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_queue(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_queue") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_queue_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_queue failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_queue(const sai_thrift_object_id_t queue_id)
{
  int32_t seqid = send_sai_thrift_remove_queue(queue_id);
  return recv_sai_thrift_remove_queue(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_queue(const sai_thrift_object_id_t queue_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_queue", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_queue_pargs args;
  args.queue_id = &queue_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_queue(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_queue") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_queue_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_queue failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_queue_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t queue_id)
{
  int32_t seqid = send_sai_thrift_get_queue_attribute(queue_id);
  recv_sai_thrift_get_queue_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_queue_attribute(const sai_thrift_object_id_t queue_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_queue_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_queue_attribute_pargs args;
  args.queue_id = &queue_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_queue_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_queue_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_queue_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_queue_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_queue_attribute(queue_id, thrift_attr);
  return recv_sai_thrift_set_queue_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_queue_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_queue_attribute_pargs args;
  args.queue_id = &queue_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_queue_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_queue_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_queue_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_queue_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_buffer_profile(thrift_attr_list);
  return recv_sai_thrift_create_buffer_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_buffer_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_buffer_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_buffer_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_buffer_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_buffer_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_buffer_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_buffer_profile(const sai_thrift_object_id_t buffer_profile_id)
{
  int32_t seqid = send_sai_thrift_remove_buffer_profile(buffer_profile_id);
  return recv_sai_thrift_remove_buffer_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_buffer_profile(const sai_thrift_object_id_t buffer_profile_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_buffer_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_buffer_profile_pargs args;
  args.buffer_profile_id = &buffer_profile_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_buffer_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_buffer_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_buffer_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_buffer_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_buffer_profile_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t buffer_profile_id)
{
  int32_t seqid = send_sai_thrift_get_buffer_profile_attribute(buffer_profile_id);
  recv_sai_thrift_get_buffer_profile_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_buffer_profile_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_pargs args;
  args.buffer_profile_id = &buffer_profile_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_buffer_profile_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_buffer_profile_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_buffer_profile_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_buffer_profile_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_buffer_profile_attribute(buffer_profile_id, thrift_attr);
  return recv_sai_thrift_set_buffer_profile_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_buffer_profile_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_pargs args;
  args.buffer_profile_id = &buffer_profile_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_buffer_profile_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_buffer_profile_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_buffer_profile_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_buffer_profile_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_pool_profile(thrift_attr_list);
  return recv_sai_thrift_create_pool_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_pool_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_pool_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_pool_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_pool_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_pool_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_pool_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_priority_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_priority_group(thrift_attr_list);
  return recv_sai_thrift_create_priority_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_priority_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_priority_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_priority_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_priority_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_priority_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_priority_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_priority_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_priority_group(const sai_thrift_object_id_t priority_group_id)
{
  int32_t seqid = send_sai_thrift_remove_priority_group(priority_group_id);
  return recv_sai_thrift_remove_priority_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_priority_group(const sai_thrift_object_id_t priority_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_priority_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_priority_group_pargs args;
  args.priority_group_id = &priority_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_priority_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_priority_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_priority_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_priority_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_priority_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t priority_group_id)
{
  int32_t seqid = send_sai_thrift_get_priority_group_attribute(priority_group_id);
  recv_sai_thrift_get_priority_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_priority_group_attribute(const sai_thrift_object_id_t priority_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_priority_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_priority_group_attribute_pargs args;
  args.priority_group_id = &priority_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_priority_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_priority_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_priority_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_priority_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_priority_group_attribute(pg_id, thrift_attr);
  return recv_sai_thrift_set_priority_group_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_priority_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs args;
  args.pg_id = &pg_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_priority_group_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_priority_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_priority_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_pg_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t pg_id, const std::vector<sai_thrift_pg_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_pg_stats(pg_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_pg_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_pg_stats(const sai_thrift_object_id_t pg_id, const std::vector<sai_thrift_pg_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_pg_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_pg_stats_pargs args;
  args.pg_id = &pg_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_pg_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_pg_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_pg_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_pg_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_wred_profile(thrift_attr_list);
  return recv_sai_thrift_create_wred_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_wred_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_wred_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_wred_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_wred_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_wred_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_wred_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
{
  int32_t seqid = send_sai_thrift_remove_wred_profile(wred_id);
  return recv_sai_thrift_remove_wred_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_wred_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_wred_profile_pargs args;
  args.wred_id = &wred_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_wred_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_wred_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_wred_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_wred_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_wred_attribute_profile(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t wred_id)
{
  int32_t seqid = send_sai_thrift_get_wred_attribute_profile(wred_id);
  recv_sai_thrift_get_wred_attribute_profile(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_wred_attribute_profile(const sai_thrift_object_id_t wred_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_wred_attribute_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_wred_attribute_profile_pargs args;
  args.wred_id = &wred_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_wred_attribute_profile(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_wred_attribute_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_wred_attribute_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_wred_attribute_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_wred_attribute_profile(const sai_thrift_object_id_t wred_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_wred_attribute_profile(wred_id, thrift_attr);
  return recv_sai_thrift_set_wred_attribute_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_wred_attribute_profile(const sai_thrift_object_id_t wred_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_wred_attribute_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_wred_attribute_profile_pargs args;
  args.wred_id = &wred_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_wred_attribute_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_wred_attribute_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_wred_attribute_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_wred_attribute_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_qos_map(thrift_attr_list);
  return recv_sai_thrift_create_qos_map(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_qos_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_qos_map_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_qos_map(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_qos_map") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_qos_map_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_qos_map failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
{
  int32_t seqid = send_sai_thrift_remove_qos_map(qos_map_id);
  return recv_sai_thrift_remove_qos_map(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_qos_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_qos_map_pargs args;
  args.qos_map_id = &qos_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_qos_map(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_qos_map") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_qos_map_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_qos_map failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_qos_map_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t qos_map_id)
{
  int32_t seqid = send_sai_thrift_get_qos_map_attribute(qos_map_id);
  recv_sai_thrift_get_qos_map_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_qos_map_attribute(const sai_thrift_object_id_t qos_map_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_qos_map_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_qos_map_attribute_pargs args;
  args.qos_map_id = &qos_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_qos_map_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_qos_map_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_qos_map_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_qos_map_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_qos_map_attribute(const sai_thrift_object_id_t qos_map_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_qos_map_attribute(qos_map_id, thrift_attr);
  return recv_sai_thrift_set_qos_map_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_qos_map_attribute(const sai_thrift_object_id_t qos_map_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_qos_map_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_qos_map_attribute_pargs args;
  args.qos_map_id = &qos_map_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_qos_map_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_qos_map_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_qos_map_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_qos_map_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_l2mc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_l2mc_group(thrift_attr_list);
  return recv_sai_thrift_create_l2mc_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_l2mc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_l2mc_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_l2mc_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_l2mc_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_l2mc_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_l2mc_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_l2mc_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_l2mc_group(const sai_thrift_object_id_t grp_id)
{
  int32_t seqid = send_sai_thrift_remove_l2mc_group(grp_id);
  return recv_sai_thrift_remove_l2mc_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_l2mc_group(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_l2mc_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_l2mc_group_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_l2mc_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_l2mc_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_l2mc_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_l2mc_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_l2mc_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t grp_id)
{
  int32_t seqid = send_sai_thrift_get_l2mc_group_attribute(grp_id);
  recv_sai_thrift_get_l2mc_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_l2mc_group_attribute(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_l2mc_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_l2mc_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_l2mc_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_l2mc_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_l2mc_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_l2mc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_l2mc_group_member(thrift_attr_list);
  return recv_sai_thrift_create_l2mc_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_l2mc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_l2mc_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_l2mc_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_l2mc_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_l2mc_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_l2mc_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_l2mc_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_l2mc_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t seqid = send_sai_thrift_remove_l2mc_group_member(member_id);
  return recv_sai_thrift_remove_l2mc_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_l2mc_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_l2mc_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_l2mc_group_member_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_l2mc_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_l2mc_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_l2mc_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_l2mc_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_l2mc_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_l2mc_group_member_attribute(member_id, thrift_attr);
  return recv_sai_thrift_set_l2mc_group_member_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_l2mc_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_l2mc_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_l2mc_group_member_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_l2mc_group_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_l2mc_group_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_l2mc_group_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_l2mc_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t member_id)
{
  int32_t seqid = send_sai_thrift_get_l2mc_group_member_attribute(member_id);
  recv_sai_thrift_get_l2mc_group_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_l2mc_group_member_attribute(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_l2mc_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_l2mc_group_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_l2mc_group_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_l2mc_group_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_l2mc_group_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_l2mc_entry(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_l2mc_entry(thrift_l2mc_entry, thrift_attr_list);
  return recv_sai_thrift_create_l2mc_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_l2mc_entry(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_l2mc_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_l2mc_entry_pargs args;
  args.thrift_l2mc_entry = &thrift_l2mc_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_l2mc_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_l2mc_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_l2mc_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_l2mc_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_l2mc_entry(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry)
{
  int32_t seqid = send_sai_thrift_remove_l2mc_entry(thrift_l2mc_entry);
  return recv_sai_thrift_remove_l2mc_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_l2mc_entry(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_l2mc_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_l2mc_entry_pargs args;
  args.thrift_l2mc_entry = &thrift_l2mc_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_l2mc_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_l2mc_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_l2mc_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_l2mc_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_l2mc_entry_attribute(thrift_l2mc_entry, thrift_attr);
  return recv_sai_thrift_set_l2mc_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_l2mc_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_pargs args;
  args.thrift_l2mc_entry = &thrift_l2mc_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_l2mc_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_l2mc_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_l2mc_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_l2mc_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_l2mc_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_l2mc_entry_t& thrift_l2mc_entry)
{
  int32_t seqid = send_sai_thrift_get_l2mc_entry_attribute(thrift_l2mc_entry);
  recv_sai_thrift_get_l2mc_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t& thrift_l2mc_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_l2mc_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_pargs args;
  args.thrift_l2mc_entry = &thrift_l2mc_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_l2mc_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_l2mc_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_l2mc_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_l2mc_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_mcast_fdb_entry(thrift_mcast_fdb_entry, thrift_attr_list);
  return recv_sai_thrift_create_mcast_fdb_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_mcast_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_pargs args;
  args.thrift_mcast_fdb_entry = &thrift_mcast_fdb_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_mcast_fdb_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_mcast_fdb_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_mcast_fdb_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_mcast_fdb_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry)
{
  int32_t seqid = send_sai_thrift_remove_mcast_fdb_entry(thrift_mcast_fdb_entry);
  return recv_sai_thrift_remove_mcast_fdb_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_mcast_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_pargs args;
  args.thrift_mcast_fdb_entry = &thrift_mcast_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_mcast_fdb_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_mcast_fdb_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_mcast_fdb_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_mcast_fdb_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_mcast_fdb_entry_attribute(thrift_mcast_fdb_entry, thrift_attr);
  return recv_sai_thrift_set_mcast_fdb_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_mcast_fdb_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_pargs args;
  args.thrift_mcast_fdb_entry = &thrift_mcast_fdb_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_mcast_fdb_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_mcast_fdb_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_mcast_fdb_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_mcast_fdb_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_mcast_fdb_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry)
{
  int32_t seqid = send_sai_thrift_get_mcast_fdb_entry_attribute(thrift_mcast_fdb_entry);
  recv_sai_thrift_get_mcast_fdb_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t& thrift_mcast_fdb_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_mcast_fdb_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_pargs args;
  args.thrift_mcast_fdb_entry = &thrift_mcast_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_mcast_fdb_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_mcast_fdb_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_mcast_fdb_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_mcast_fdb_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_ipmc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_ipmc_group(thrift_attr_list);
  return recv_sai_thrift_create_ipmc_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_ipmc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_ipmc_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_ipmc_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_ipmc_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_ipmc_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_ipmc_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_ipmc_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_ipmc_group(const sai_thrift_object_id_t grp_id)
{
  int32_t seqid = send_sai_thrift_remove_ipmc_group(grp_id);
  return recv_sai_thrift_remove_ipmc_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_ipmc_group(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_ipmc_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_ipmc_group_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_ipmc_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_ipmc_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_ipmc_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_ipmc_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_ipmc_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t grp_id)
{
  int32_t seqid = send_sai_thrift_get_ipmc_group_attribute(grp_id);
  recv_sai_thrift_get_ipmc_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_ipmc_group_attribute(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_ipmc_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_ipmc_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_ipmc_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_ipmc_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_ipmc_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_ipmc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_ipmc_group_member(thrift_attr_list);
  return recv_sai_thrift_create_ipmc_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_ipmc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_ipmc_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_ipmc_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_ipmc_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_ipmc_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_ipmc_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_ipmc_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_ipmc_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t seqid = send_sai_thrift_remove_ipmc_group_member(member_id);
  return recv_sai_thrift_remove_ipmc_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_ipmc_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_ipmc_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_ipmc_group_member_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_ipmc_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_ipmc_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_ipmc_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_ipmc_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_ipmc_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_ipmc_group_member_attribute(member_id, thrift_attr);
  return recv_sai_thrift_set_ipmc_group_member_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_ipmc_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_ipmc_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_ipmc_group_member_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_ipmc_group_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_ipmc_group_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_ipmc_group_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_ipmc_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t member_id)
{
  int32_t seqid = send_sai_thrift_get_ipmc_group_member_attribute(member_id);
  recv_sai_thrift_get_ipmc_group_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_ipmc_group_member_attribute(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_ipmc_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_ipmc_group_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_ipmc_group_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_ipmc_group_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_ipmc_group_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_rpf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_rpf_group(thrift_attr_list);
  return recv_sai_thrift_create_rpf_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_rpf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_rpf_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_rpf_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_rpf_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_rpf_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_rpf_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_rpf_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_rpf_group(const sai_thrift_object_id_t grp_id)
{
  int32_t seqid = send_sai_thrift_remove_rpf_group(grp_id);
  return recv_sai_thrift_remove_rpf_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_rpf_group(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_rpf_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_rpf_group_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_rpf_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_rpf_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_rpf_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_rpf_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_rpf_group_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t grp_id)
{
  int32_t seqid = send_sai_thrift_get_rpf_group_attribute(grp_id);
  recv_sai_thrift_get_rpf_group_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_rpf_group_attribute(const sai_thrift_object_id_t grp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_rpf_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_rpf_group_attribute_pargs args;
  args.grp_id = &grp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_rpf_group_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_rpf_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_rpf_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_rpf_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_rpf_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_rpf_group_member(thrift_attr_list);
  return recv_sai_thrift_create_rpf_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_rpf_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_rpf_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_rpf_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_rpf_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_rpf_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_rpf_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_rpf_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_rpf_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t seqid = send_sai_thrift_remove_rpf_group_member(member_id);
  return recv_sai_thrift_remove_rpf_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_rpf_group_member(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_rpf_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_rpf_group_member_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_rpf_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_rpf_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_rpf_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_rpf_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_rpf_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_rpf_group_member_attribute(member_id, thrift_attr);
  return recv_sai_thrift_set_rpf_group_member_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_rpf_group_member_attribute(const sai_thrift_object_id_t member_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_rpf_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_rpf_group_member_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_rpf_group_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_rpf_group_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_rpf_group_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_rpf_group_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t member_id)
{
  int32_t seqid = send_sai_thrift_get_rpf_group_member_attribute(member_id);
  recv_sai_thrift_get_rpf_group_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_rpf_group_member_attribute(const sai_thrift_object_id_t member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_rpf_group_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_pargs args;
  args.member_id = &member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_rpf_group_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_rpf_group_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_rpf_group_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_rpf_group_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_ipmc_entry(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_ipmc_entry(thrift_ipmc_entry, thrift_attr_list);
  return recv_sai_thrift_create_ipmc_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_ipmc_entry(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_ipmc_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_ipmc_entry_pargs args;
  args.thrift_ipmc_entry = &thrift_ipmc_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_ipmc_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_ipmc_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_ipmc_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_ipmc_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_ipmc_entry(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry)
{
  int32_t seqid = send_sai_thrift_remove_ipmc_entry(thrift_ipmc_entry);
  return recv_sai_thrift_remove_ipmc_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_ipmc_entry(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_ipmc_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_ipmc_entry_pargs args;
  args.thrift_ipmc_entry = &thrift_ipmc_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_ipmc_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_ipmc_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_ipmc_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_ipmc_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_ipmc_entry_attribute(thrift_ipmc_entry, thrift_attr);
  return recv_sai_thrift_set_ipmc_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_ipmc_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_pargs args;
  args.thrift_ipmc_entry = &thrift_ipmc_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_ipmc_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_ipmc_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_ipmc_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_ipmc_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_ipmc_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_ipmc_entry_t& thrift_ipmc_entry)
{
  int32_t seqid = send_sai_thrift_get_ipmc_entry_attribute(thrift_ipmc_entry);
  recv_sai_thrift_get_ipmc_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t& thrift_ipmc_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_ipmc_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_pargs args;
  args.thrift_ipmc_entry = &thrift_ipmc_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_ipmc_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_ipmc_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_ipmc_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_ipmc_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_samplepacket(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_samplepacket(thrift_attr_list);
  return recv_sai_thrift_create_samplepacket(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_samplepacket(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_samplepacket", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_samplepacket_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_samplepacket(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_samplepacket") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_samplepacket_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_samplepacket failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_samplepacket(const sai_thrift_object_id_t samplepacket_id)
{
  int32_t seqid = send_sai_thrift_remove_samplepacket(samplepacket_id);
  return recv_sai_thrift_remove_samplepacket(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_samplepacket(const sai_thrift_object_id_t samplepacket_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_samplepacket", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_samplepacket_pargs args;
  args.samplepacket_id = &samplepacket_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_samplepacket(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_samplepacket") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_samplepacket_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_samplepacket failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_samplepacket_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t samplepacket_id)
{
  int32_t seqid = send_sai_thrift_get_samplepacket_attribute(samplepacket_id);
  recv_sai_thrift_get_samplepacket_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_samplepacket_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_samplepacket_attribute_pargs args;
  args.samplepacket_id = &samplepacket_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_samplepacket_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_samplepacket_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_samplepacket_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_samplepacket_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_samplepacket_attribute(samplepacket_id, thrift_attr);
  return recv_sai_thrift_set_samplepacket_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_samplepacket_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_samplepacket_attribute_pargs args;
  args.samplepacket_id = &samplepacket_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_samplepacket_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_samplepacket_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_samplepacket_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_samplepacket_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_tunnel_map_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_tunnel_map_entry(thrift_attr_list);
  return recv_sai_thrift_create_tunnel_map_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_tunnel_map_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_tunnel_map_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_map_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_tunnel_map_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_tunnel_map_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_tunnel_map_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel_map_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_tunnel_map_entry(const sai_thrift_object_id_t tunnel_map_entry_id)
{
  int32_t seqid = send_sai_thrift_remove_tunnel_map_entry(tunnel_map_entry_id);
  return recv_sai_thrift_remove_tunnel_map_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_tunnel_map_entry(const sai_thrift_object_id_t tunnel_map_entry_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel_map_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_pargs args;
  args.tunnel_map_entry_id = &tunnel_map_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_tunnel_map_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_tunnel_map_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_tunnel_map_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel_map_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_tunnel_map_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t tunnel_map_entry_id)
{
  int32_t seqid = send_sai_thrift_get_tunnel_map_entry_attribute(tunnel_map_entry_id);
  recv_sai_thrift_get_tunnel_map_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_map_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_pargs args;
  args.tunnel_map_entry_id = &tunnel_map_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_tunnel_map_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_tunnel_map_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_tunnel_map_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_map_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_tunnel_map_entry_attribute(tunnel_map_entry_id, thrift_attr);
  return recv_sai_thrift_set_tunnel_map_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_tunnel_map_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_pargs args;
  args.tunnel_map_entry_id = &tunnel_map_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_tunnel_map_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_tunnel_map_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_tunnel_map_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_tunnel_map_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_tunnel_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_tunnel_map(thrift_attr_list);
  return recv_sai_thrift_create_tunnel_map(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_tunnel_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_tunnel_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_map_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_tunnel_map(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_tunnel_map") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_tunnel_map_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel_map failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_tunnel_map(const sai_thrift_object_id_t tunnel_map_id)
{
  int32_t seqid = send_sai_thrift_remove_tunnel_map(tunnel_map_id);
  return recv_sai_thrift_remove_tunnel_map(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_tunnel_map(const sai_thrift_object_id_t tunnel_map_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_map_pargs args;
  args.tunnel_map_id = &tunnel_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_tunnel_map(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_tunnel_map") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_tunnel_map_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel_map failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_tunnel_map_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t tunnel_map_id)
{
  int32_t seqid = send_sai_thrift_get_tunnel_map_attribute(tunnel_map_id);
  recv_sai_thrift_get_tunnel_map_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_map_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_pargs args;
  args.tunnel_map_id = &tunnel_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_tunnel_map_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_tunnel_map_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_tunnel_map_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_map_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_tunnel_map_attribute(tunnel_map_id, thrift_attr);
  return recv_sai_thrift_set_tunnel_map_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_tunnel_map_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_pargs args;
  args.tunnel_map_id = &tunnel_map_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_tunnel_map_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_tunnel_map_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_tunnel_map_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_tunnel_map_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_tunnel(thrift_attr_list);
  return recv_sai_thrift_create_tunnel(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_tunnel", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_tunnel(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_tunnel") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_tunnel_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_tunnel(const sai_thrift_object_id_t tunnel_id)
{
  int32_t seqid = send_sai_thrift_remove_tunnel(tunnel_id);
  return recv_sai_thrift_remove_tunnel(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_tunnel(const sai_thrift_object_id_t tunnel_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_pargs args;
  args.tunnel_id = &tunnel_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_tunnel(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_tunnel") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_tunnel_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_tunnel_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t tunnel_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t seqid = send_sai_thrift_get_tunnel_attribute(tunnel_id, thrift_attr_ids);
  recv_sai_thrift_get_tunnel_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_tunnel_attribute(const sai_thrift_object_id_t tunnel_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_attribute_pargs args;
  args.tunnel_id = &tunnel_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_tunnel_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_tunnel_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_tunnel_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_tunnel_attribute(const sai_thrift_object_id_t tunnel_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_tunnel_attribute(tunnel_id, thrift_attr);
  return recv_sai_thrift_set_tunnel_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_tunnel_attribute(const sai_thrift_object_id_t tunnel_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_tunnel_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_tunnel_attribute_pargs args;
  args.tunnel_id = &tunnel_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_tunnel_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_tunnel_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_tunnel_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_tunnel_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_tunnel_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t tunnel_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_tunnel_stats(tunnel_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_tunnel_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_tunnel_stats(const sai_thrift_object_id_t tunnel_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_stats_pargs args;
  args.tunnel_id = &tunnel_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_tunnel_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_tunnel_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_tunnel_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_tunnel_stats(const sai_thrift_object_id_t tunnel_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_clear_tunnel_stats(tunnel_id, counter_ids, number_of_counters);
  return recv_sai_thrift_clear_tunnel_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_tunnel_stats(const sai_thrift_object_id_t tunnel_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_tunnel_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_tunnel_stats_pargs args;
  args.tunnel_id = &tunnel_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_tunnel_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_tunnel_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_tunnel_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_tunnel_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_tunnel_term_table_entry(thrift_attr_list);
  return recv_sai_thrift_create_tunnel_term_table_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_tunnel_term_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_tunnel_term_table_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_tunnel_term_table_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel_term_table_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t tunnel_term_table_entry_id)
{
  int32_t seqid = send_sai_thrift_remove_tunnel_term_table_entry(tunnel_term_table_entry_id);
  return recv_sai_thrift_remove_tunnel_term_table_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t tunnel_term_table_entry_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel_term_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs args;
  args.tunnel_term_table_entry_id = &tunnel_term_table_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_tunnel_term_table_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_tunnel_term_table_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel_term_table_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_tunnel_term_table_entry_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t tunnel_term_table_entry_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t seqid = send_sai_thrift_get_tunnel_term_table_entry_attribute(tunnel_term_table_entry_id, thrift_attr_ids);
  recv_sai_thrift_get_tunnel_term_table_entry_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_tunnel_term_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_pargs args;
  args.tunnel_term_table_entry_id = &tunnel_term_table_entry_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_tunnel_term_table_entry_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_tunnel_term_table_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_tunnel_term_table_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_tunnel_term_table_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_tunnel_term_table_entry_attribute(tunnel_term_table_entry_id, thrift_attr);
  return recv_sai_thrift_set_tunnel_term_table_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_tunnel_term_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_pargs args;
  args.tunnel_term_table_entry_id = &tunnel_term_table_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_tunnel_term_table_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_tunnel_term_table_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_tunnel_term_table_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_tunnel_term_table_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_cpu_packet_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t switch_id)
{
  int32_t seqid = send_sai_thrift_get_cpu_packet_attribute(switch_id);
  recv_sai_thrift_get_cpu_packet_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_cpu_packet_attribute(const sai_thrift_object_id_t switch_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_cpu_packet_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_pargs args;
  args.switch_id = &switch_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_cpu_packet_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_cpu_packet_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_cpu_packet_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_cpu_packet_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_cpu_packet_count(sai_thrift_result_t& _return)
{
  int32_t seqid = send_sai_thrift_get_cpu_packet_count();
  recv_sai_thrift_get_cpu_packet_count(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_cpu_packet_count()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_cpu_packet_count", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_cpu_packet_count_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_cpu_packet_count(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_cpu_packet_count") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_cpu_packet_count_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_cpu_packet_count failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_clear_cpu_packet_info(sai_thrift_result_t& _return)
{
  int32_t seqid = send_sai_thrift_clear_cpu_packet_info();
  recv_sai_thrift_clear_cpu_packet_info(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_cpu_packet_info()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_cpu_packet_info", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_cpu_packet_info_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_cpu_packet_info(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_cpu_packet_info") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_clear_cpu_packet_info_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_cpu_packet_info failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_log_set(const int32_t sai_api_id, const int32_t log_level)
{
  int32_t seqid = send_sai_thrift_log_set(sai_api_id, log_level);
  return recv_sai_thrift_log_set(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_log_set(const int32_t sai_api_id, const int32_t log_level)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_log_set", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_log_set_pargs args;
  args.sai_api_id = &sai_api_id;
  args.log_level = &log_level;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_log_set(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_log_set") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_log_set_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_log_set failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_isolation_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_isolation_group(thrift_attr_list);
  return recv_sai_thrift_create_isolation_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_isolation_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_isolation_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_isolation_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_isolation_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_isolation_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_isolation_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_isolation_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_isolation_group(const sai_thrift_object_id_t iso_group_oid)
{
  int32_t seqid = send_sai_thrift_remove_isolation_group(iso_group_oid);
  return recv_sai_thrift_remove_isolation_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_isolation_group(const sai_thrift_object_id_t iso_group_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_isolation_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_isolation_group_pargs args;
  args.iso_group_oid = &iso_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_isolation_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_isolation_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_isolation_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_isolation_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_isolation_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_isolation_group_member(thrift_attr_list);
  return recv_sai_thrift_create_isolation_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_isolation_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_isolation_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_isolation_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_isolation_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_isolation_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_isolation_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_isolation_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_isolation_group_member(const sai_thrift_object_id_t member_oid)
{
  int32_t seqid = send_sai_thrift_remove_isolation_group_member(member_oid);
  return recv_sai_thrift_remove_isolation_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_isolation_group_member(const sai_thrift_object_id_t member_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_isolation_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_isolation_group_member_pargs args;
  args.member_oid = &member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_isolation_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_isolation_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_isolation_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_isolation_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_isolation_group_attributes(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t iso_group_oid)
{
  int32_t seqid = send_sai_thrift_get_isolation_group_attributes(iso_group_oid);
  recv_sai_thrift_get_isolation_group_attributes(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_isolation_group_attributes(const sai_thrift_object_id_t iso_group_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_isolation_group_attributes", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_isolation_group_attributes_pargs args;
  args.iso_group_oid = &iso_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_isolation_group_attributes(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_isolation_group_attributes") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_isolation_group_attributes_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_isolation_group_attributes failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_isolation_group_member_attributes(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t member_oid)
{
  int32_t seqid = send_sai_thrift_get_isolation_group_member_attributes(member_oid);
  recv_sai_thrift_get_isolation_group_member_attributes(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_isolation_group_member_attributes(const sai_thrift_object_id_t member_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_isolation_group_member_attributes", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_pargs args;
  args.member_oid = &member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_isolation_group_member_attributes(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_isolation_group_member_attributes") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_isolation_group_member_attributes_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_isolation_group_member_attributes failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_counter(thrift_attr_list);
  return recv_sai_thrift_create_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_counter(const sai_thrift_object_id_t counter_oid)
{
  int32_t seqid = send_sai_thrift_remove_counter(counter_oid);
  return recv_sai_thrift_remove_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_counter(const sai_thrift_object_id_t counter_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_counter_pargs args;
  args.counter_oid = &counter_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_counter_attribute(const sai_thrift_object_id_t thrift_counter_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_counter_attribute(thrift_counter_id, thrift_attr);
  return recv_sai_thrift_set_counter_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_counter_attribute(const sai_thrift_object_id_t thrift_counter_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_counter_attribute_pargs args;
  args.thrift_counter_id = &thrift_counter_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_counter_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_counter_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_counter_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_counter_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_counter_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_counter_id)
{
  int32_t seqid = send_sai_thrift_get_counter_attribute(thrift_counter_id);
  recv_sai_thrift_get_counter_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_counter_attribute(const sai_thrift_object_id_t thrift_counter_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_counter_attribute_pargs args;
  args.thrift_counter_id = &thrift_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_counter_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_counter_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_counter_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_counter_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_counter_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_counter_stats(counter_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_counter_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_counter_stats(const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_counter_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_counter_stats_pargs args;
  args.counter_id = &counter_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_counter_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_counter_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_counter_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_counter_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_counter_stats_ext(std::vector<int64_t> & _return, const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_counter_stats_ext(counter_id, counter_ids, mode, number_of_counters);
  recv_sai_thrift_get_counter_stats_ext(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_counter_stats_ext(const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & counter_ids, const int8_t mode, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_counter_stats_ext", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_counter_stats_ext_pargs args;
  args.counter_id = &counter_id;
  args.counter_ids = &counter_ids;
  args.mode = &mode;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_counter_stats_ext(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_counter_stats_ext") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_counter_stats_ext_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_counter_stats_ext failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_counter_stats(const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_clear_counter_stats(counter_id, thrift_counter_ids, number_of_counters);
  return recv_sai_thrift_clear_counter_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_counter_stats(const sai_thrift_object_id_t counter_id, const std::vector<sai_thrift_stat_id_t> & thrift_counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_counter_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_counter_stats_pargs args;
  args.counter_id = &counter_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_counter_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_counter_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_counter_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_counter_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_debug_counter(thrift_attr_list);
  return recv_sai_thrift_create_debug_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_debug_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_debug_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_debug_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_debug_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_debug_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_debug_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_debug_counter(const sai_thrift_object_id_t debug_counter_oid)
{
  int32_t seqid = send_sai_thrift_remove_debug_counter(debug_counter_oid);
  return recv_sai_thrift_remove_debug_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_debug_counter(const sai_thrift_object_id_t debug_counter_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_debug_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_debug_counter_pargs args;
  args.debug_counter_oid = &debug_counter_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_debug_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_debug_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_debug_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_debug_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t thrift_debug_counter_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_debug_counter_attribute(thrift_debug_counter_id, thrift_attr);
  return recv_sai_thrift_set_debug_counter_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t thrift_debug_counter_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_debug_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs args;
  args.thrift_debug_counter_id = &thrift_debug_counter_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_debug_counter_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_debug_counter_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_debug_counter_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_debug_counter_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t thrift_debug_counter_id)
{
  int32_t seqid = send_sai_thrift_get_debug_counter_attribute(thrift_debug_counter_id);
  recv_sai_thrift_get_debug_counter_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_debug_counter_attribute(const sai_thrift_object_id_t thrift_debug_counter_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_debug_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_debug_counter_attribute_pargs args;
  args.thrift_debug_counter_id = &thrift_debug_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_debug_counter_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_debug_counter_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_debug_counter_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_debug_counter_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_nat(const sai_thrift_nat_entry_t& thrift_nat_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_nat(thrift_nat_entry, thrift_attr_list);
  return recv_sai_thrift_create_nat(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_nat(const sai_thrift_nat_entry_t& thrift_nat_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_nat", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_nat_pargs args;
  args.thrift_nat_entry = &thrift_nat_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_nat(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_nat") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_nat_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_nat failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_nat(const sai_thrift_nat_entry_t& thrift_nat_entry)
{
  int32_t seqid = send_sai_thrift_remove_nat(thrift_nat_entry);
  return recv_sai_thrift_remove_nat(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_nat(const sai_thrift_nat_entry_t& thrift_nat_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_nat", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_nat_pargs args;
  args.thrift_nat_entry = &thrift_nat_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_nat(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_nat") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_nat_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_nat failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_nat_attribute(const sai_thrift_nat_entry_t& thrift_nat_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_nat_attribute(thrift_nat_entry, thrift_attr);
  return recv_sai_thrift_set_nat_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_nat_attribute(const sai_thrift_nat_entry_t& thrift_nat_entry, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_nat_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_nat_attribute_pargs args;
  args.thrift_nat_entry = &thrift_nat_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_nat_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_nat_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_nat_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_nat_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_nat_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_nat_entry_t& thrift_nat_entry)
{
  int32_t seqid = send_sai_thrift_get_nat_attribute(thrift_nat_entry);
  recv_sai_thrift_get_nat_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_nat_attribute(const sai_thrift_nat_entry_t& thrift_nat_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_nat_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_nat_attribute_pargs args;
  args.thrift_nat_entry = &thrift_nat_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_nat_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_nat_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_nat_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_nat_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_bfd(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_bfd(thrift_attr_list);
  return recv_sai_thrift_create_bfd(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_bfd(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_bfd", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bfd_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_bfd(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_bfd") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_bfd_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bfd failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_bfd(const sai_thrift_object_id_t bfd_oid)
{
  int32_t seqid = send_sai_thrift_remove_bfd(bfd_oid);
  return recv_sai_thrift_remove_bfd(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_bfd(const sai_thrift_object_id_t bfd_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_bfd", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bfd_pargs args;
  args.bfd_oid = &bfd_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_bfd(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_bfd") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_bfd_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bfd failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_bfd_attribute(const sai_thrift_object_id_t bfd_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_bfd_attribute(bfd_oid, thrift_attr);
  return recv_sai_thrift_set_bfd_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_bfd_attribute(const sai_thrift_object_id_t bfd_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_bfd_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_bfd_attribute_pargs args;
  args.bfd_oid = &bfd_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_bfd_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_bfd_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_bfd_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_bfd_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_bfd_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t bfd_oid)
{
  int32_t seqid = send_sai_thrift_get_bfd_attribute(bfd_oid);
  recv_sai_thrift_get_bfd_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_bfd_attribute(const sai_thrift_object_id_t bfd_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_bfd_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bfd_attribute_pargs args;
  args.bfd_oid = &bfd_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_bfd_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_bfd_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_bfd_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bfd_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_y1731_meg(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_y1731_meg(thrift_attr_list);
  return recv_sai_thrift_create_y1731_meg(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_y1731_meg(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_y1731_meg", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_y1731_meg_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_y1731_meg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_y1731_meg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_y1731_meg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_y1731_meg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_y1731_meg(const sai_thrift_object_id_t y1731_meg_oid)
{
  int32_t seqid = send_sai_thrift_remove_y1731_meg(y1731_meg_oid);
  return recv_sai_thrift_remove_y1731_meg(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_y1731_meg(const sai_thrift_object_id_t y1731_meg_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_y1731_meg", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_y1731_meg_pargs args;
  args.y1731_meg_oid = &y1731_meg_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_y1731_meg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_y1731_meg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_y1731_meg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_y1731_meg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_y1731_meg_attribute(const sai_thrift_object_id_t y1731_meg_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_y1731_meg_attribute(y1731_meg_oid, thrift_attr);
  return recv_sai_thrift_set_y1731_meg_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_y1731_meg_attribute(const sai_thrift_object_id_t y1731_meg_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_y1731_meg_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_pargs args;
  args.y1731_meg_oid = &y1731_meg_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_y1731_meg_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_y1731_meg_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_y1731_meg_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_y1731_meg_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_y1731_meg_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t y1731_meg_oid)
{
  int32_t seqid = send_sai_thrift_get_y1731_meg_attribute(y1731_meg_oid);
  recv_sai_thrift_get_y1731_meg_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_y1731_meg_attribute(const sai_thrift_object_id_t y1731_meg_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_y1731_meg_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_pargs args;
  args.y1731_meg_oid = &y1731_meg_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_y1731_meg_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_y1731_meg_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_y1731_meg_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_y1731_meg_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_y1731_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_y1731_session(thrift_attr_list);
  return recv_sai_thrift_create_y1731_session(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_y1731_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_y1731_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_y1731_session_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_y1731_session(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_y1731_session") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_y1731_session_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_y1731_session failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_y1731_session(const sai_thrift_object_id_t y1731_session_oid)
{
  int32_t seqid = send_sai_thrift_remove_y1731_session(y1731_session_oid);
  return recv_sai_thrift_remove_y1731_session(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_y1731_session(const sai_thrift_object_id_t y1731_session_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_y1731_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_y1731_session_pargs args;
  args.y1731_session_oid = &y1731_session_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_y1731_session(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_y1731_session") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_y1731_session_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_y1731_session failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_y1731_session_attribute(const sai_thrift_object_id_t y1731_session_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_y1731_session_attribute(y1731_session_oid, thrift_attr);
  return recv_sai_thrift_set_y1731_session_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_y1731_session_attribute(const sai_thrift_object_id_t y1731_session_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_y1731_session_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_y1731_session_attribute_pargs args;
  args.y1731_session_oid = &y1731_session_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_y1731_session_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_y1731_session_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_y1731_session_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_y1731_session_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_y1731_session_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t y1731_session_oid)
{
  int32_t seqid = send_sai_thrift_get_y1731_session_attribute(y1731_session_oid);
  recv_sai_thrift_get_y1731_session_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_y1731_session_attribute(const sai_thrift_object_id_t y1731_session_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_y1731_session_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_y1731_session_attribute_pargs args;
  args.y1731_session_oid = &y1731_session_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_y1731_session_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_y1731_session_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_y1731_session_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_y1731_session_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_y1731_rmep(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_y1731_rmep(thrift_attr_list);
  return recv_sai_thrift_create_y1731_rmep(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_y1731_rmep(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_y1731_rmep", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_y1731_rmep_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_y1731_rmep(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_y1731_rmep") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_y1731_rmep_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_y1731_rmep failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_y1731_rmep(const sai_thrift_object_id_t y1731_rmep_oid)
{
  int32_t seqid = send_sai_thrift_remove_y1731_rmep(y1731_rmep_oid);
  return recv_sai_thrift_remove_y1731_rmep(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_y1731_rmep(const sai_thrift_object_id_t y1731_rmep_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_y1731_rmep", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_y1731_rmep_pargs args;
  args.y1731_rmep_oid = &y1731_rmep_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_y1731_rmep(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_y1731_rmep") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_y1731_rmep_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_y1731_rmep failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_y1731_rmep_attribute(const sai_thrift_object_id_t y1731_rmep_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_y1731_rmep_attribute(y1731_rmep_oid, thrift_attr);
  return recv_sai_thrift_set_y1731_rmep_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_y1731_rmep_attribute(const sai_thrift_object_id_t y1731_rmep_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_y1731_rmep_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_pargs args;
  args.y1731_rmep_oid = &y1731_rmep_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_y1731_rmep_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_y1731_rmep_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_y1731_rmep_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_y1731_rmep_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_y1731_rmep_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t y1731_rmep_oid)
{
  int32_t seqid = send_sai_thrift_get_y1731_rmep_attribute(y1731_rmep_oid);
  recv_sai_thrift_get_y1731_rmep_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_y1731_rmep_attribute(const sai_thrift_object_id_t y1731_rmep_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_y1731_rmep_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_pargs args;
  args.y1731_rmep_oid = &y1731_rmep_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_y1731_rmep_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_y1731_rmep_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_y1731_rmep_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_y1731_rmep_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_y1731_session_lm_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t y1731_session_oid, const std::vector<sai_thrift_stat_id_t> & lm_stats_ids, const int32_t number_of_stats)
{
  int32_t seqid = send_sai_thrift_get_y1731_session_lm_stats(y1731_session_oid, lm_stats_ids, number_of_stats);
  recv_sai_thrift_get_y1731_session_lm_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_y1731_session_lm_stats(const sai_thrift_object_id_t y1731_session_oid, const std::vector<sai_thrift_stat_id_t> & lm_stats_ids, const int32_t number_of_stats)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_y1731_session_lm_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_pargs args;
  args.y1731_session_oid = &y1731_session_oid;
  args.lm_stats_ids = &lm_stats_ids;
  args.number_of_stats = &number_of_stats;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_y1731_session_lm_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_y1731_session_lm_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_y1731_session_lm_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_y1731_session_lm_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_port(const std::string& port_name, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_port(port_name, thrift_attr_list);
  return recv_sai_thrift_create_port(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_port(const std::string& port_name, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_port_pargs args;
  args.port_name = &port_name;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_port(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_port(const sai_thrift_object_id_t port_oid)
{
  int32_t seqid = send_sai_thrift_remove_port(port_oid);
  return recv_sai_thrift_remove_port(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_port(const sai_thrift_object_id_t port_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_port_pargs args;
  args.port_oid = &port_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_port(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_ptp_domain(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_ptp_domain(thrift_attr_list);
  return recv_sai_thrift_create_ptp_domain(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_ptp_domain(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_ptp_domain", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_ptp_domain_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_ptp_domain(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_ptp_domain") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_ptp_domain_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_ptp_domain failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_ptp_domain(const sai_thrift_object_id_t ptp_oid)
{
  int32_t seqid = send_sai_thrift_remove_ptp_domain(ptp_oid);
  return recv_sai_thrift_remove_ptp_domain(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_ptp_domain(const sai_thrift_object_id_t ptp_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_ptp_domain", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_ptp_domain_pargs args;
  args.ptp_oid = &ptp_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_ptp_domain(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_ptp_domain") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_ptp_domain_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_ptp_domain failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_ptp_domain_attribute(const sai_thrift_object_id_t ptp_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_ptp_domain_attribute(ptp_oid, thrift_attr);
  return recv_sai_thrift_set_ptp_domain_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_ptp_domain_attribute(const sai_thrift_object_id_t ptp_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_ptp_domain_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_pargs args;
  args.ptp_oid = &ptp_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_ptp_domain_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_ptp_domain_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_ptp_domain_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_ptp_domain_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_ptp_domain_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t ptp_oid)
{
  int32_t seqid = send_sai_thrift_get_ptp_domain_attribute(ptp_oid);
  recv_sai_thrift_get_ptp_domain_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_ptp_domain_attribute(const sai_thrift_object_id_t ptp_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_ptp_domain_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_pargs args;
  args.ptp_oid = &ptp_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_ptp_domain_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_ptp_domain_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_ptp_domain_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_ptp_domain_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_es(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_es(thrift_attr_list);
  return recv_sai_thrift_create_es(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_es(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_es", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_es_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_es(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_es") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_es_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_es failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_es(const sai_thrift_object_id_t es_oid)
{
  int32_t seqid = send_sai_thrift_remove_es(es_oid);
  return recv_sai_thrift_remove_es(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_es(const sai_thrift_object_id_t es_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_es", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_es_pargs args;
  args.es_oid = &es_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_es(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_es") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_es_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_es failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_es_attribute(const sai_thrift_object_id_t es_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_es_attribute(es_oid, thrift_attr);
  return recv_sai_thrift_set_es_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_es_attribute(const sai_thrift_object_id_t es_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_es_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_es_attribute_pargs args;
  args.es_oid = &es_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_es_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_es_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_es_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_es_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_es_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t es_oid)
{
  int32_t seqid = send_sai_thrift_get_es_attribute(es_oid);
  recv_sai_thrift_get_es_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_es_attribute(const sai_thrift_object_id_t es_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_es_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_es_attribute_pargs args;
  args.es_oid = &es_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_es_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_es_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_es_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_es_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

