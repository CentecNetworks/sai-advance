// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <ctime>
#include "switch_sai_rpc.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/transport/TNonblockingServerSocket.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/concurrency/ThreadFactory.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/protocol/TDebugProtocol.h>
#include <thrift/protocol/TJSONProtocol.h>
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <arpa/inet.h>
#include <inttypes.h>
#include <string>
#include <iomanip>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <sal.h>
#include <sys/queue.h>
#include <sys/types.h>
#include <sai.h>
#include <saifdb.h>
#include <saivlan.h>
#include <sairouterinterface.h>
#include <sairoute.h>
#include <saiswitch.h>
#include <saimirror.h>
#include <saistatus.h>

#ifdef __cplusplus
}
#endif

#include <errno.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/queue.h>
#include <sys/types.h>
#include <set>
#include <getopt.h>
#include <assert.h>
#include <signal.h>
#include <thread>
#include <algorithm>
#include <list>

extern "C" {
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "pktswitch.h"
#include "pktclnt.h"
#include "afx_evtlp.h"
#include "split.h"

#include "sai.h"
#include "saistatus.h"

}

using namespace std;

#define UNREFERENCED_PARAMETER(P)   (P)

#define SAI_THRIFT_LOG_DBG(msg, ...) sai_thrift_timestamp_print(); \
    printf("SAI THRIFT DEBUG: %s(): " msg "\n", __FUNCTION__, ##__VA_ARGS__);

#define SAI_THRIFT_LOG_ERR(msg, ...) sai_thrift_timestamp_print(); \
    printf("SAI THRIFT ERROR: %s(): " msg "\n", __FUNCTION__, ##__VA_ARGS__);

#define SAI_THRIFT_FUNC_LOG() SAI_THRIFT_LOG_DBG("Called.")

#define CNT_UNSUPPORT 10

#define DUMP_FILE_NAME_LEN 51

#define SAI_THRIFT_MAX_PACKET_LEN 1500


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace ::switch_sai;
#define SAI_CPU_PACKET_MAX_ATTR_COUNT 6
extern sai_attribute_t packet_rx_attr[SAI_CPU_PACKET_MAX_ATTR_COUNT];
extern int packet_rx_attr_count;
extern int packets_rx_count;
extern sai_object_id_t gSwitchId;

std::string gPortMapFile;


typedef std::vector<sai_thrift_attribute_t> std_sai_thrift_attr_vctr_t;

class switch_sai_rpcHandler : virtual public switch_sai_rpcIf {
public:
    switch_sai_rpcHandler() noexcept
    {
        // Your initialization goes here
    }

    inline void sai_thrift_timestamp_print() const noexcept
    {
        const auto ltime = std::time(nullptr);
        const auto tm = std::localtime(&ltime);

        std::printf("%02d:%02d:%02d ", tm->tm_hour, tm->tm_min, tm->tm_sec);
    }

    template<typename T>
    inline void sai_thrift_alloc_array(T* &arr, const std::size_t &size) const noexcept
    { arr = new (std::nothrow) T[size]; }

    template<typename T>
    inline void sai_thrift_free_array(T* &arr) const noexcept
    { delete[] arr; arr = nullptr; }

    unsigned int sai_thrift_string_to_mac(const std::string s, unsigned char *m)
    {
        unsigned int i, j=0;
        memset(m, 0, 6);
        for(i=0;i<s.size();i++)
        {
            char let = s.c_str()[i];
            if (let >= '0' && let <= '9')
            {
                m[j/2] = (m[j/2] << 4) + (let - '0'); j++;
            }
            else if (let >= 'a' && let <= 'f')
            {
                m[j/2] = (m[j/2] << 4) + (let - 'a'+10); j++;
            }
            else if (let >= 'A' && let <= 'F')
            {
                m[j/2] = (m[j/2] << 4) + (let - 'A'+10); j++;
            }
        }
        return (j == 12);
    }

    std::string sai_thrift_mac_to_string(const unsigned char *m)
    {
        unsigned int i=0;
        std::string mac_str;
        char mac[18]={'0','0',':',
                        '0','0',':',
                        '0','0',':',
                        '0','0',':',
                        '0','0',':',
                        '0','0','\0'};
    
        for (i = 0; i < 6; i++)
        {
            sprintf(&mac[i*3], "%02x", m[i]);
            mac[i*3 + 2] = ':';
        }
        mac[17] = '\0';
        mac_str = mac;
    
        return mac_str;
    }

    void sai_thrift_string_to_v4_ip(const std::string s, unsigned int *m)
    {
        unsigned char r=0;
        unsigned int i;
        *m = 0;
        for(i=0;i<s.size();i++)
        {
            char let = s.c_str()[i];
            if (let >= '0' && let <= '9')
            {
                r = (r * 10) + (let - '0');
            }
            else
            {
                *m = (*m << 8) | r;
                r=0;
            }
        }
        *m = (*m << 8) | (r & 0xFF);
        *m = htonl(*m);
    
        //const char *v4_str = s.c_str();
        //inet_pton(AF_INET, v4_str, m);
        return;
    }
    
    std::string sai_thrift_v4_ip_to_string(const unsigned int m)
    {
        std::string ip_str;
        char ipv4_str[44];
        inet_ntop(AF_INET, &m, ipv4_str, 44);
        ip_str = ipv4_str;
        return ip_str;
    }
    
    std::string sai_thrift_v6_ip_to_string(const unsigned char *v6_ip)
    {
        unsigned int ip6[4];
        std :: string ip_str;
        char ipv6_str[44];
        ip6[0] = htonl(*((unsigned int *)v6_ip));
        ip6[1] = htonl(*((unsigned int *)v6_ip + 1));
        ip6[2] = htonl(*((unsigned int *)v6_ip + 2));
        ip6[3] = htonl(*((unsigned int *)v6_ip + 3));
        //inet_ntop(AF_INET6, &ip6, ipv6_str, 44);
        inet_ntop(AF_INET6, v6_ip, ipv6_str, 44);
        ip_str = ipv6_str;
        return ip_str;
    }
    
    void sai_thrift_string_to_v6_ip(const std::string s, unsigned char *v6_ip)
    {
        const char *v6_str = s.c_str();
        inet_pton(AF_INET6, v6_str, v6_ip);
        return;
    }
    
    
    inline void sai_thrift_alloc_attr(sai_attribute_t* &attr, const sai_uint32_t &size) const noexcept
    { attr = new (std::nothrow) sai_attribute_t[size]; }
    
    inline void sai_thrift_free_attr(sai_attribute_t* &attr) const noexcept
    { delete[] attr; attr = nullptr; }
    
    void sai_thrift_parse_object_id_list(const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, 
                                         sai_object_id_t *object_id_list)
    {
        std::vector<sai_thrift_object_id_t>::const_iterator it = thrift_object_id_list.begin();
        for(uint32_t i = 0; i < thrift_object_id_list.size(); i++, it++)
        {
            object_id_list[i] = (sai_object_id_t)*it;
        }
    }
    
    void sai_thrift_parse_ip_address(const sai_thrift_ip_address_t &thrift_ip_address, sai_ip_address_t *ip_address)
    {
        ip_address->addr_family = (sai_ip_addr_family_t) thrift_ip_address.addr_family;
        if ((sai_ip_addr_family_t)thrift_ip_address.addr_family == SAI_IP_ADDR_FAMILY_IPV4)
        {
            sai_thrift_string_to_v4_ip(thrift_ip_address.addr.ip4, &ip_address->addr.ip4);
        }
        else
        {
            sai_thrift_string_to_v6_ip(thrift_ip_address.addr.ip6, ip_address->addr.ip6);
        }
    }
    
    void sai_thrift_parse_ip_prefix(const sai_thrift_ip_prefix_t &thrift_ip_prefix, sai_ip_prefix_t *ip_prefix)
    {
        ip_prefix->addr_family = (sai_ip_addr_family_t) thrift_ip_prefix.addr_family;
        if ((sai_ip_addr_family_t)thrift_ip_prefix.addr_family == SAI_IP_ADDR_FAMILY_IPV4)
        {
            sai_thrift_string_to_v4_ip(thrift_ip_prefix.addr.ip4, &ip_prefix->addr.ip4);
            sai_thrift_string_to_v4_ip(thrift_ip_prefix.mask.ip4, &ip_prefix->mask.ip4);
        }
        else
        {
            sai_thrift_string_to_v6_ip(thrift_ip_prefix.addr.ip6, ip_prefix->addr.ip6);
            sai_thrift_string_to_v6_ip(thrift_ip_prefix.mask.ip6, ip_prefix->mask.ip6);
        }
    }
    
    void sai_thrift_parse_attribute_ids(const std::vector<int32_t> &thrift_attr_id_list, sai_attribute_t *attr_list)
    {
        std::vector<int32_t>::const_iterator it = thrift_attr_id_list.begin();
        for(uint32_t i = 0; i < thrift_attr_id_list.size(); i++, it++)
        {
            attr_list[i].id = (int32_t) *it;
        }
    }
    
    sai_attribute_t *sai_thrift_attribute_list_to_sai(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_attribute_t *sai_attrs;
    
        sai_attrs = (sai_attribute_t *) calloc(thrift_attr_list.size(), sizeof(sai_attribute_t));
        if (!sai_attrs)
        {
            SAI_THRIFT_LOG_ERR("failed to allocate sai attibutes list");
            return NULL;
        }
    
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            sai_thrift_attribute_t & thrift_attr = (sai_thrift_attribute_t &) *it;
            sai_attrs[i].id = thrift_attr.id;
            sai_attrs[i].value.oid = thrift_attr.value.oid;
        }
    
        return sai_attrs;
    }
    
    void sai_attributes_to_sai_thrift_list(sai_attribute_t *sai_attrs, uint32_t count, std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
    
        for (uint32_t i = 0; i < count; i++)
        {
            sai_thrift_attribute_t thrift_attr;
    
            thrift_attr.id        = sai_attrs[i].id;
            thrift_attr.value.__set_oid(sai_attrs[i].value.oid);
    
            thrift_attr_list.push_back(thrift_attr);
        }
    }
    
    void sai_attributes_booldata_to_sai_thrift_list(sai_attribute_t *sai_attrs, uint32_t count, std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        for (uint32_t i = 0; i < count; i++)
        {
            sai_thrift_attribute_t thrift_attr;
    
            thrift_attr.id        = sai_attrs[i].id;
            thrift_attr.value.__set_booldata(sai_attrs[i].value.booldata);
    
            thrift_attr_list.push_back(thrift_attr);
        }
    }
    
    void sai_attributes_s32_to_sai_thrift_list(sai_attribute_t *sai_attrs, uint32_t count, std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        for (uint32_t i = 0; i < count; i++)
        {
            sai_thrift_attribute_t thrift_attr;
    
            thrift_attr.id        = sai_attrs[i].id;
            thrift_attr.value.__set_s32(sai_attrs[i].value.s32);
    
            thrift_attr_list.push_back(thrift_attr);
        }
    }
    
    void sai_attributes_u32_to_sai_thrift_list(sai_attribute_t *sai_attrs, 
                                               uint32_t count, 
                                               std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
    
        for (uint32_t i = 0; i < count; i++)
        {
            sai_thrift_attribute_t thrift_attr;
    
            thrift_attr.id        = sai_attrs[i].id;
            thrift_attr.value.__set_u32(sai_attrs[i].value.u32);
    
            thrift_attr_list.push_back(thrift_attr);
        }
    }
    
    void sai_attributes_u16_to_sai_thrift_list(sai_attribute_t *sai_attrs, 
                                               uint32_t count, 
                                               std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        for (uint32_t i = 0; i < count; i++)
        {
            sai_thrift_attribute_t thrift_attr;
    
            thrift_attr.id        = sai_attrs[i].id;
            thrift_attr.value.__set_u16(sai_attrs[i].value.u16);
    
            thrift_attr_list.push_back(thrift_attr);
        }
    }
    
    void sai_thrift_parse_fdb_entry(const sai_thrift_fdb_entry_t &thrift_fdb_entry, sai_fdb_entry_t *fdb_entry)
    {
        fdb_entry->bv_id = (sai_object_id_t) thrift_fdb_entry.bv_id;
        fdb_entry->switch_id = gSwitchId;
        sai_thrift_string_to_mac(thrift_fdb_entry.mac_address, fdb_entry->mac_address);
    }
    
    void sai_thrift_parse_route_entry(const sai_thrift_route_entry_t &thrift_route_entry, sai_route_entry_t *route_entry)
    {
        route_entry->switch_id = gSwitchId;
        route_entry->vr_id = (sai_object_id_t) thrift_route_entry.vr_id;
        sai_thrift_parse_ip_prefix(thrift_route_entry.destination, &route_entry->destination);
    }
    
    void sai_thrift_parse_neighbor_entry(const sai_thrift_neighbor_entry_t &thrift_neighbor_entry, sai_neighbor_entry_t *neighbor_entry)
    {
        neighbor_entry->switch_id = gSwitchId;
        neighbor_entry->rif_id = (sai_object_id_t) thrift_neighbor_entry.rif_id;
        sai_thrift_parse_ip_address(thrift_neighbor_entry.ip_address, &neighbor_entry->ip_address);
    }
    
    void sai_thrift_parse_ipmc_entry(const sai_thrift_ipmc_entry_t &thrift_ipmc_entry, sai_ipmc_entry_t *ipmc_entry)
    {
        ipmc_entry->switch_id = gSwitchId;
        ipmc_entry->vr_id = (sai_object_id_t) thrift_ipmc_entry.vr_id;
        ipmc_entry->type = (sai_ipmc_entry_type_t) thrift_ipmc_entry.type;
        sai_thrift_parse_ip_address(thrift_ipmc_entry.source, &ipmc_entry->source);
        sai_thrift_parse_ip_address(thrift_ipmc_entry.destination, &ipmc_entry->destination);
    }
    
    void sai_thrift_parse_l2mc_entry(const sai_thrift_l2mc_entry_t &thrift_l2mc_entry, sai_l2mc_entry_t *l2mc_entry)
    {
        l2mc_entry->switch_id = gSwitchId;
        l2mc_entry->bv_id = (sai_object_id_t) thrift_l2mc_entry.bv_id;
        l2mc_entry->type = (sai_l2mc_entry_type_t) thrift_l2mc_entry.type;
        sai_thrift_parse_ip_address(thrift_l2mc_entry.source, &l2mc_entry->source);
        sai_thrift_parse_ip_address(thrift_l2mc_entry.destination, &l2mc_entry->destination);
    }
    
    void sai_thrift_parse_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t &thrift_mcast_fdb_entry, 
                                          sai_mcast_fdb_entry_t *mcast_fdb_entry)
    {
        mcast_fdb_entry->switch_id = gSwitchId;
        mcast_fdb_entry->bv_id = (sai_object_id_t) thrift_mcast_fdb_entry.bv_id;
        sai_thrift_string_to_mac(thrift_mcast_fdb_entry.mac_address, mcast_fdb_entry->mac_address);
    }
    
    void sai_thrift_parser_inseg_entry(const sai_thrift_inseg_entry_t &thrift_mpls_entry, sai_inseg_entry_t *mpls_entry)
    {
        mpls_entry->switch_id = gSwitchId;
        mpls_entry->label = (sai_label_id_t)thrift_mpls_entry.label;
    }
    
    void sai_thrift_parse_nat_entry(const sai_thrift_nat_entry_t &thrift_nat_entry, sai_nat_entry_t *nat_entry)
    {
        nat_entry->switch_id = gSwitchId;
        nat_entry->vr_id = (sai_object_id_t) thrift_nat_entry.vr_id;
        sai_thrift_string_to_v4_ip(thrift_nat_entry.destination, &nat_entry->data.key.dst_ip);
        sai_thrift_string_to_v4_ip(thrift_nat_entry.source, &nat_entry->data.key.src_ip);
        nat_entry->data.key.proto = (sai_uint8_t) thrift_nat_entry.proto;
        nat_entry->data.key.l4_src_port = (sai_uint16_t) thrift_nat_entry.l4_src_port;
        nat_entry->data.key.l4_dst_port = (sai_uint16_t) thrift_nat_entry.l4_dst_port;
    
        sai_thrift_string_to_v4_ip(thrift_nat_entry.destination_mask, &nat_entry->data.mask.dst_ip);
        sai_thrift_string_to_v4_ip(thrift_nat_entry.source_mask, &nat_entry->data.mask.src_ip);
        nat_entry->data.mask.proto = (sai_uint8_t) thrift_nat_entry.proto_mask;
        nat_entry->data.mask.l4_src_port = (sai_uint16_t) thrift_nat_entry.l4_src_port_mask;
        nat_entry->data.mask.l4_dst_port = (sai_uint16_t) thrift_nat_entry.l4_dst_port_mask;
    }
    
    void sai_thrift_parse_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                          sai_attribute_t *attr_list, 
                                          sai_object_id_t **buffer_profile_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
    
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_PORT_ATTR_ADMIN_STATE:
                case SAI_PORT_ATTR_UPDATE_DSCP:
                case SAI_PORT_ATTR_PKT_TX_ENABLE:
                case SAI_PORT_ATTR_Y1731_ENABLE:
                case SAI_PORT_ATTR_Y1731_LM_ENABLE:
                case SAI_PORT_ATTR_AUTO_NEG_MODE:
                case SAI_PORT_ATTR_EEE_ENABLE:
                case SAI_PORT_ATTR_DROP_TAGGED:
                case SAI_PORT_ATTR_DROP_UNTAGGED:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_PORT_ATTR_PORT_VLAN_ID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_TX:
                case SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_RX:
                case SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL:
                case SAI_PORT_ATTR_DEFAULT_VLAN_PRIORITY:
                case SAI_PORT_ATTR_Y1731_MIP_ENABLE:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
/*              case SAI_PORT_ATTR_QOS_INGRESS_BUFFER_PROFILE_LIST:
                case SAI_PORT_ATTR_QOS_EGRESS_BUFFER_PROFILE_LIST:
                    {
                    *buffer_profile_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * attribute.value.objlist.count);
                    std::vector<sai_thrift_object_id_t>::const_iterator it2 = attribute.value.objlist.object_id_list.begin();
                    for (uint32_t j = 0; j < attribute.value.objlist.object_id_list.size(); j++, *it2++)
                    {
                        (*buffer_profile_list)[j] = (sai_object_id_t) *it2;
                    }
                    attr_list[i].value.objlist.count = attribute.value.objlist.count;
                    attr_list[i].value.objlist.list = *buffer_profile_list;
                    break;
                }
*/
                case SAI_PORT_ATTR_INGRESS_MIRROR_SESSION:
                case SAI_PORT_ATTR_EGRESS_MIRROR_SESSION:
                case SAI_PORT_ATTR_EGRESS_BLOCK_PORT_LIST:
                {
                    *buffer_profile_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * attribute.value.objlist.count);
                    std::vector<sai_thrift_object_id_t>::const_iterator it2 = attribute.value.objlist.object_id_list.begin();
                    for (uint32_t j = 0; j < attribute.value.objlist.object_id_list.size(); j++, *it2++)
                    {
                        (*buffer_profile_list)[j] = (sai_object_id_t) *it2;
                    }
                    attr_list[i].value.objlist.count = attribute.value.objlist.count;
                    attr_list[i].value.objlist.list=*buffer_profile_list;
                    break;
                }
                case SAI_PORT_ATTR_QOS_SCHEDULER_PROFILE_ID:
                case SAI_PORT_ATTR_QOS_DOT1P_TO_TC_MAP:
                case SAI_PORT_ATTR_QOS_DOT1P_TO_COLOR_MAP:
                case SAI_PORT_ATTR_QOS_DSCP_TO_TC_MAP:
                case SAI_PORT_ATTR_QOS_DSCP_TO_COLOR_MAP:
                case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP:
                case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP:
                case SAI_PORT_ATTR_INGRESS_ACL:
                case SAI_PORT_ATTR_EGRESS_ACL:    
                case SAI_PORT_ATTR_POLICER_ID:
                case SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID:
                case SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID:
                case SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID:
                case SAI_PORT_ATTR_INGRESS_SAMPLEPACKET_ENABLE:
                case SAI_PORT_ATTR_EGRESS_SAMPLEPACKET_ENABLE:
                case SAI_PORT_ATTR_ES:
                case SAI_PORT_ATTR_ISOLATION_GROUP:
                case SAI_PORT_ATTR_PTP_DOMAIN_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_PORT_ATTR_MTU:
                case SAI_PORT_ATTR_SPEED:
                case SAI_PORT_ATTR_META_DATA:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_MODE:
                case SAI_PORT_ATTR_GLOBAL_FLOW_CONTROL_MODE:
                case SAI_PORT_ATTR_FEC_MODE:
                case SAI_PORT_ATTR_INTERNAL_LOOPBACK_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_PORT_ATTR_MAC_ADDRESS:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
                case SAI_PORT_ATTR_PTP_PATH_DELAY:
                case SAI_PORT_ATTR_PTP_INGRESS_ASYMMETRY_DELAY:
                case SAI_PORT_ATTR_PTP_EGRESS_ASYMMETRY_DELAY:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                default:
                    break;
            }
        }
    }


    void sai_thrift_parse_fdb_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_FDB_ENTRY_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_FDB_ENTRY_ATTR_BRIDGE_PORT_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_FDB_ENTRY_ATTR_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_FDB_ENTRY_ATTR_ENDPOINT_IP:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                case SAI_FDB_ENTRY_ATTR_META_DATA:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                default:
                    break;
            }
        }
    }

    void sai_thrift_parse_fdb_flush_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_FDB_FLUSH_ATTR_BRIDGE_PORT_ID:
                    attr_list[i].value.oid = (sai_object_id_t) attribute.value.oid;
                    break;
                case SAI_FDB_FLUSH_ATTR_BV_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_FDB_FLUSH_ATTR_ENTRY_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
            }
        }
    }
    
    void sai_thrift_parse_vr_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V4_STATE:
                case SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V6_STATE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_VIRTUAL_ROUTER_ATTR_SRC_MAC_ADDRESS:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
            }
        }
    }
    
    void sai_thrift_parse_route_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID:
                case SAI_ROUTE_ENTRY_ATTR_COUNTER_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_ROUTE_ENTRY_ATTR_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_ROUTE_ENTRY_ATTR_META_DATA:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_ROUTE_ENTRY_ATTR_USER_TRAP_ID:
                    attr_list[i].value.u32 = attribute.value.u32;
                default:
                    break;
            }
        }
    }
    
    void sai_thrift_parse_router_interface_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                      sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_ROUTER_INTERFACE_ATTR_VIRTUAL_ROUTER_ID:
                case SAI_ROUTER_INTERFACE_ATTR_PORT_ID:
                case SAI_ROUTER_INTERFACE_ATTR_VLAN_ID:
                case SAI_ROUTER_INTERFACE_ATTR_BRIDGE_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_ROUTER_INTERFACE_ATTR_TYPE:
                case SAI_ROUTER_INTERFACE_ATTR_NEIGHBOR_MISS_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_ROUTER_INTERFACE_ATTR_MTU:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_ROUTER_INTERFACE_ATTR_SRC_MAC_ADDRESS:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
                case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V4_STATE:
                case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V6_STATE:
                case SAI_ROUTER_INTERFACE_ATTR_V4_MCAST_ENABLE:
                case SAI_ROUTER_INTERFACE_ATTR_V6_MCAST_ENABLE:
                case SAI_ROUTER_INTERFACE_ATTR_IS_VIRTUAL:
                case SAI_ROUTER_INTERFACE_ATTR_CUSTOM_STATS_STATE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_ROUTER_INTERFACE_ATTR_INGRESS_ACL:
                case SAI_ROUTER_INTERFACE_ATTR_EGRESS_ACL:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_ROUTER_INTERFACE_ATTR_NAT_ZONE_ID:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_ROUTER_INTERFACE_ATTR_OUTER_VLAN_ID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                default:
                    break;
            }
        }
    }
    
    void sai_thrift_parse_next_hop_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list, sai_uint32_t **buffer_profile_list1)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_NEXT_HOP_ATTR_TYPE:
                case SAI_NEXT_HOP_ATTR_OUTSEG_TTL_MODE:
                case SAI_NEXT_HOP_ATTR_OUTSEG_EXP_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_NEXT_HOP_ATTR_IP:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                case SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID:
                case SAI_NEXT_HOP_ATTR_TUNNEL_ID:
                case SAI_NEXT_HOP_ATTR_MPLS_ENCAP_TUNNEL_ID:
                case SAI_NEXT_HOP_ATTR_COUNTER_ID:
                case SAI_NEXT_HOP_ATTR_QOS_TC_AND_COLOR_TO_MPLS_EXP_MAP:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_NEXT_HOP_ATTR_LABELSTACK:
                    {
                        *buffer_profile_list1 = (uint32_t *) malloc(sizeof(uint32_t) * attribute.value.u32list.count);
                        std::vector<sai_int32_t>::const_iterator it2 = attribute.value.u32list.u32list.begin();
                        for (uint32_t j = 0; j < attribute.value.u32list.u32list.size(); j++, *it2++)
                        {
                            (*buffer_profile_list1)[j] = (sai_uint32_t) *it2;
                        }
                        attr_list[i].value.u32list.count = attribute.value.u32list.count;
                        attr_list[i].value.u32list.list = *buffer_profile_list1;
                        break;
                    }
                case SAI_NEXT_HOP_ATTR_TUNNEL_VNI:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_NEXT_HOP_ATTR_TUNNEL_MAC:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
                case SAI_NEXT_HOP_ATTR_NEXT_LEVEL_NEXT_HOP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_NEXT_HOP_ATTR_OUTSEG_TTL_VALUE:
                case SAI_NEXT_HOP_ATTR_OUTSEG_EXP_VALUE:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                default:
                    break;
            }
        }
    }
    
    void sai_thrift_parse_lag_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++)
        {
            attribute = (sai_thrift_attribute_t)*it1;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_LAG_ATTR_PORT_VLAN_ID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_LAG_ATTR_DEFAULT_VLAN_PRIORITY:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_LAG_ATTR_DROP_UNTAGGED:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_LAG_ATTR_DROP_TAGGED:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_LAG_ATTR_MODE:
                    attr_list[i].value.s32= attribute.value.s32;
                    break;
                case SAI_LAG_ATTR_CUSTOM_MAX_MEMBER_NUM:
                    attr_list[i].value.u16= attribute.value.u16;
                    break;
                case SAI_LAG_ATTR_INGRESS_ACL:
                    attr_list[i].value.oid= attribute.value.oid;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_lag_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++)
        {
            attribute = (sai_thrift_attribute_t)*it1;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_LAG_MEMBER_ATTR_LAG_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_LAG_MEMBER_ATTR_PORT_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_LAG_MEMBER_ATTR_EGRESS_DISABLE:
                  attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_LAG_MEMBER_ATTR_INGRESS_DISABLE:
                  attr_list[i].value.booldata = attribute.value.booldata;
                    break;
            }
        }
    }
    
    void sai_thrift_parse_stp_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list, sai_vlan_id_t **vlan_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++)
        {
            attribute = (sai_thrift_attribute_t)*it1;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_STP_ATTR_VLAN_LIST:
                    *vlan_list = (sai_vlan_id_t *) malloc(sizeof(sai_vlan_id_t) * attribute.value.vlanlist.vlan_count);
                    std::vector<sai_thrift_vlan_id_t>::const_iterator it2 = attribute.value.vlanlist.vlan_list.begin();
                    for (uint32_t j = 0; j < attribute.value.vlanlist.vlan_list.size(); j++, *it2++)
                    {
                        *vlan_list[j] = (sai_vlan_id_t) *it2;
                    }
                    attr_list[i].value.vlanlist.count = attribute.value.vlanlist.vlan_count;
                    attr_list[i].value.vlanlist.list = *vlan_list;
                    break;
            }
        }
    }
    
    void sai_thrift_parse_neighbor_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++)
        {
            attribute = (sai_thrift_attribute_t)*it1;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_NEIGHBOR_ENTRY_ATTR_DST_MAC_ADDRESS:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
                case SAI_NEIGHBOR_ENTRY_ATTR_USER_TRAP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_NEIGHBOR_ENTRY_ATTR_COUNTER_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_NEIGHBOR_ENTRY_ATTR_META_DATA:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_NEIGHBOR_ENTRY_ATTR_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_NEIGHBOR_ENTRY_ATTR_NO_HOST_ROUTE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
            }
        }
    }
    
    void sai_thrift_parse_hostif_attributes(sai_attribute_t *attr_list, const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_HOSTIF_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
    
                case SAI_HOSTIF_ATTR_OBJ_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
    
                case SAI_HOSTIF_ATTR_NAME:
                    std::memcpy(attr_list[i].value.chardata, attribute.value.chardata.c_str(), SAI_HOSTIF_NAME_SIZE);
                    break;
    
                case SAI_HOSTIF_ATTR_OPER_STATUS:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
    
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_hostif_table_entry_attributes(sai_attribute_t *attr_list, const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_HOSTIF_TABLE_ENTRY_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
    
                case SAI_HOSTIF_TABLE_ENTRY_ATTR_OBJ_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
    
                case SAI_HOSTIF_TABLE_ENTRY_ATTR_TRAP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
    
                case SAI_HOSTIF_TABLE_ENTRY_ATTR_CHANNEL_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
    
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_hostif_trap_group_attributes(sai_attribute_t *attr_list, const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_HOSTIF_TRAP_GROUP_ATTR_ADMIN_STATE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_HOSTIF_TRAP_GROUP_ATTR_QUEUE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_HOSTIF_TRAP_GROUP_ATTR_POLICER:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_hostif_trap_attributes(sai_attribute_t *attr_list, const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_HOSTIF_TRAP_ATTR_TRAP_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_HOSTIF_TRAP_ATTR_EXCLUDE_PORT_LIST:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_hostif_trap_attribute(const sai_thrift_attribute_t &thrift_attr, sai_attribute_t *attr)
    {
        attr->id = thrift_attr.id;
        switch (thrift_attr.id)
        {
            case SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION:
                attr->value.s32 = thrift_attr.value.s32;
                break;
            case SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY:
                attr->value.u32 = thrift_attr.value.u32;
                break;
            case SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP:
                attr->value.oid = thrift_attr.value.oid;
                break;
            default:
                break;
        }
    }
    
    void sai_thrift_parser_mpls_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_INSEG_ENTRY_ATTR_NUM_OF_POP:
                case SAI_INSEG_ENTRY_ATTR_FRR_CONFIGURED_ROLE:
                case SAI_INSEG_ENTRY_ATTR_POP_TTL_MODE:
                case SAI_INSEG_ENTRY_ATTR_POP_QOS_MODE:
                case SAI_INSEG_ENTRY_ATTR_QOS_TC:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_INSEG_ENTRY_ATTR_PACKET_ACTION:
                case SAI_INSEG_ENTRY_ATTR_PSC_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_INSEG_ENTRY_ATTR_TRAP_PRIORITY:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_INSEG_ENTRY_ATTR_NEXT_HOP_ID:
                case SAI_INSEG_ENTRY_ATTR_DECAP_TUNNEL_ID:
                case SAI_INSEG_ENTRY_ATTR_FRR_NHP_GRP:
                case SAI_INSEG_ENTRY_ATTR_MPLS_EXP_TO_TC_MAP:
                case SAI_INSEG_ENTRY_ATTR_MPLS_EXP_TO_COLOR_MAP:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_INSEG_ENTRY_ATTR_FRR_INACTIVE_RX_DISCARD:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                default:
                    break;
            }
        }
    }
    
    sai_thrift_status_t sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t &thrift_attr)
    {
        printf("sai_thrift_set_port\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_port_api_t *port_api;
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_object_id_t *buffer_profile_list = NULL;
        std::vector<sai_thrift_attribute_t> thrift_attr_list;
        thrift_attr_list.push_back(thrift_attr);
        sai_attribute_t attr;
        sai_thrift_parse_port_attributes(thrift_attr_list, &attr, &buffer_profile_list);
        status = port_api->set_port_attribute((sai_object_id_t)port_id, &attr);
    
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set port attributes, status:%d", status);
        }
    
        if (buffer_profile_list)
        {
          free(buffer_profile_list);
        }
    
        return status;
    }
    
    
    sai_thrift_object_id_t sai_thrift_create_port(const std::string& port_name, 
                                                  const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
    
        SAI_THRIFT_LOG_DBG("Called.");
    
        sai_status_t status = SAI_STATUS_SUCCESS;
    
        sai_port_api_t *port_api;
    
        extern std::map<std::set<int>, std::string> gPortMap;
    
        std::map<std::set<int>, std::string>::iterator gPortMapIt;
    
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("port sai_api_query failed!!!\n");
            return SAI_NULL_OBJECT_ID;
        }
    
        for (gPortMapIt = gPortMap.begin() ; gPortMapIt != gPortMap.end() ; gPortMapIt++)
        {
            if (gPortMapIt->second == port_name)
            {
                break;
            }
        }
    
        std::set<int> lane_set;
    
        if (gPortMapIt != gPortMap.end())
        {
            lane_set = gPortMapIt->first;
        }
        else
        {
            printf("Do not find matching port to received name!\n");
            return SAI_NULL_OBJECT_ID;
        }
    
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
    
        sai_thrift_parse_port_attributes_with_create_port(thrift_attr_list, attr_list);
    
        sai_object_id_t port_oid = 0;
        status = port_api->create_port(&port_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
    
        if (status == SAI_STATUS_SUCCESS)
        {
              return port_oid;
        }
    
        SAI_THRIFT_LOG_ERR("Failed to create PORT.");
    
        return SAI_NULL_OBJECT_ID;
    }
    
    void sai_thrift_parse_port_attributes_with_create_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_PORT_ATTR_SPEED:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_PORT_ATTR_HW_LANE_LIST:
                  {
                    int count = attribute.value.u32list.u32list.size();
                    sai_uint32_t *u32_list = NULL;
                    std::vector<sai_int32_t>::const_iterator it = attribute.value.u32list.u32list.begin();
                    u32_list = (sai_uint32_t *) malloc(sizeof(sai_uint32_t) * count);
                    for(int j = 0; j < count; j++, it++)
                        *(u32_list + j) = (sai_uint32_t) *it;
                    attr_list[i].value.u32list.list = u32_list;
                    attr_list[i].value.u32list.count = count;
                  }
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse PORT attributes.");
                    break;
            }
        }
    }
    
    
    sai_thrift_status_t sai_thrift_remove_port(const sai_thrift_object_id_t port_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        sai_port_api_t *port_api = nullptr;
    
        sai_status_t status = SAI_STATUS_SUCCESS;
    
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
    
        if (status != SAI_STATUS_SUCCESS)
        {
          SAI_THRIFT_LOG_ERR("Failed to get PORT API.");
          return SAI_NULL_OBJECT_ID;
        }
    
        status = port_api->remove_port(port_oid);
        return status;
    }
    
    
    sai_thrift_status_t sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, 
                                                    const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_fdb_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_fdb_api_t *fdb_api;
        sai_fdb_entry_t fdb_entry;
        status = sai_api_query(SAI_API_FDB, (void **) &fdb_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_fdb_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = fdb_api->create_fdb_entry(&fdb_entry, attr_count, attr_list);
        free(attr_list);
        return status;
    }
    
    sai_thrift_status_t sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
    {
        printf("sai_thrift_delete_fdb_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_fdb_api_t *fdb_api;
        sai_fdb_entry_t fdb_entry;
        status = sai_api_query(SAI_API_FDB, (void **) &fdb_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
        status = fdb_api->remove_fdb_entry(&fdb_entry);
        return status;
    }
    
    sai_thrift_status_t sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_flush_fdb_entries\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_fdb_api_t *fdb_api;
        status = sai_api_query(SAI_API_FDB, (void **) &fdb_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_fdb_flush_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = fdb_api->flush_fdb_entries(gSwitchId, attr_count, attr_list);
        free(attr_list);
        return status;
    }
    
    sai_thrift_status_t sai_thrift_set_fdb_entry_attribute(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        sai_fdb_api_t *fdb_api;
        sai_fdb_entry_t fdb_entry;
        sai_attribute_t *attr_list = nullptr;
    
        printf("sai_thrift_set_fdb_entry_attribute\n");
        status = sai_api_query(SAI_API_FDB, (void **) &fdb_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_thrift_alloc_attr(attr_list, 1);
        sai_thrift_parse_fdb_attributes(thrift_attr_list, attr_list);
        sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
    
        status = fdb_api->set_fdb_entry_attribute(&fdb_entry, attr_list);
        sai_thrift_free_attr(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set FDB attribute");
        }
    
        return status;
    }

    void sai_thrift_get_fdb_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_fdb_entry_t& thrift_fdb_entry)
    {
        printf("sai_thrift_get_fdb_entry_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_fdb_api_t *fdb_api;
        sai_fdb_entry_t fdb_entry;
        sai_attribute_t sai_attrs[4];
        sai_thrift_attribute_t thrift_attr;
    
        status = sai_api_query(SAI_API_FDB, (void **) &fdb_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain fdb_api, status:%d", status);
            return;
        }
    
        SAI_THRIFT_FUNC_LOG();
    
        sai_attrs[0].id = SAI_FDB_ENTRY_ATTR_TYPE;
        sai_attrs[1].id = SAI_FDB_ENTRY_ATTR_PACKET_ACTION;
        sai_attrs[2].id = SAI_FDB_ENTRY_ATTR_BRIDGE_PORT_ID;
        sai_attrs[3].id = SAI_FDB_ENTRY_ATTR_META_DATA;
        
        sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
        status = fdb_api->get_fdb_entry_attribute(&fdb_entry, 4, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain fdb attributes, status:%d", status);
            return;
        }
    
        //sai_attributes_to_sai_thrift_list(sai_attrs, 3, thrift_attr_list.attr_list);
    
    
        thrift_attr.id        = sai_attrs[0].id;
        thrift_attr.value.__set_s32(sai_attrs[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[1].id;
        thrift_attr.value.__set_s32(sai_attrs[1].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[2].id;
        thrift_attr.value.__set_oid(sai_attrs[2].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[3].id;
        thrift_attr.value.__set_u32(sai_attrs[3].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
    }

    void sai_thrift_parse_vlan_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_VLAN_ATTR_VLAN_ID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
    
                case SAI_VLAN_ATTR_MAX_LEARNED_ADDRESSES:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
    
                case SAI_VLAN_ATTR_STP_INSTANCE:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
    
                case SAI_VLAN_ATTR_LEARN_DISABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_VLAN_ATTR_UNKNOWN_UNICAST_FLOOD_CONTROL_TYPE:
                case SAI_VLAN_ATTR_UNKNOWN_MULTICAST_FLOOD_CONTROL_TYPE:
                case SAI_VLAN_ATTR_BROADCAST_FLOOD_CONTROL_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_VLAN_ATTR_CUSTOM_IGMP_SNOOPING_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
    
                case SAI_VLAN_ATTR_IPV4_MCAST_LOOKUP_KEY_TYPE:
                case SAI_VLAN_ATTR_IPV6_MCAST_LOOKUP_KEY_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
    
                case SAI_VLAN_ATTR_META_DATA:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
    
                case SAI_VLAN_ATTR_INGRESS_ACL:
                case SAI_VLAN_ATTR_EGRESS_ACL:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_VLAN_ATTR_CUSTOM_STATS_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
    
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse VLAN attributes.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_bridge_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_BRIDGE_PORT_ATTR_TYPE:
                case SAI_BRIDGE_PORT_ATTR_TAGGING_MODE:
                case SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE:
                case SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_LIMIT_VIOLATION_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
    
                case SAI_BRIDGE_PORT_ATTR_ADMIN_STATE:
                case SAI_BRIDGE_PORT_ATTR_INGRESS_FILTERING:
                case SAI_BRIDGE_PORT_ATTR_EGRESS_FILTERING:
                case SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_OAM_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_BRIDGE_PORT_ATTR_MAX_LEARNED_ADDRESSES:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_BRIDGE_PORT_ATTR_VLAN_ID:
                case SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_SERVICE_ID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_BRIDGE_PORT_ATTR_FRR_NHP_GRP:
                case SAI_BRIDGE_PORT_ATTR_PORT_ID:
                case SAI_BRIDGE_PORT_ATTR_RIF_ID:
                case SAI_BRIDGE_PORT_ATTR_TUNNEL_ID:
                case SAI_BRIDGE_PORT_ATTR_BRIDGE_ID:
                case SAI_BRIDGE_PORT_ATTR_ISOLATION_GROUP:
                case SAI_BRIDGE_PORT_ATTR_CROSS_CONNECT_BRIDGE_PORT:
                case SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_POLICER_ID:
                    attr_list[i].value.oid = attribute.value.oid;
    
                    break;
    
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse Bridge Port attributes");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_bridge_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_BRIDGE_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
    
                case SAI_BRIDGE_ATTR_MAX_LEARNED_ADDRESSES:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
    
                case SAI_BRIDGE_ATTR_LEARN_DISABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
    
                case SAI_BRIDGE_ATTR_UNKNOWN_UNICAST_FLOOD_CONTROL_TYPE:
                case SAI_BRIDGE_ATTR_UNKNOWN_MULTICAST_FLOOD_CONTROL_TYPE:
                case SAI_BRIDGE_ATTR_BROADCAST_FLOOD_CONTROL_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
    
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse Bridge attributes.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_samplepacket_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                  sai_attribute_t *attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_SAMPLEPACKET_ATTR_SAMPLE_RATE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_SAMPLEPACKET_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_SAMPLEPACKET_ATTR_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_tunnel_map_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_TUNNEL_MAP_ENTRY_ATTR_TUNNEL_MAP_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_TUNNEL_MAP_ENTRY_ATTR_TUNNEL_MAP:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_BRIDGE_ID_KEY:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_BRIDGE_ID_VALUE:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_VIRTUAL_ROUTER_ID_KEY:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_VIRTUAL_ROUTER_ID_VALUE:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_TUNNEL_MAP_ENTRY_ATTR_OECN_KEY:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_OECN_VALUE:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_UECN_KEY:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_UECN_VALUE:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_TUNNEL_MAP_ENTRY_ATTR_VLAN_ID_KEY:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_VLAN_ID_VALUE:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_TUNNEL_MAP_ENTRY_ATTR_VNI_ID_KEY:
                case SAI_TUNNEL_MAP_ENTRY_ATTR_VNI_ID_VALUE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_tunnel_map_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_TUNNEL_MAP_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_tunnel_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list, sai_object_id_t **tunnel_attr_list)
    {
        sai_thrift_attribute_t attribute;
    
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            attribute = (sai_thrift_attribute_t)*cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_TUNNEL_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_TUNNEL_ATTR_UNDERLAY_INTERFACE:
                case SAI_TUNNEL_ATTR_OVERLAY_INTERFACE:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_TUNNEL_ATTR_ENCAP_SRC_IP:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                case SAI_TUNNEL_ATTR_ENCAP_TTL_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_DSCP_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_ECN_MODE:
                case SAI_TUNNEL_ATTR_DECAP_ECN_MODE:
                case SAI_TUNNEL_ATTR_DECAP_TTL_MODE:
                case SAI_TUNNEL_ATTR_DECAP_DSCP_MODE:
                case SAI_TUNNEL_ATTR_DECAP_MPLS_PW_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_TTL_VAL:
                case SAI_TUNNEL_ATTR_ENCAP_DSCP_VAL:
                case SAI_TUNNEL_ATTR_ENCAP_EXP_VAL:
                case SAI_TUNNEL_ATTR_DECAP_EXP_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_EXP_MODE:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_TUNNEL_ATTR_ENCAP_GRE_KEY_VALID:
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_WITH_CW:
                case SAI_TUNNEL_ATTR_DECAP_MPLS_PW_WITH_CW:
                case SAI_TUNNEL_ATTR_ENCAP_ESI_LABEL_VALID:
                case SAI_TUNNEL_ATTR_DECAP_ESI_LABEL_VALID:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_TUNNEL_ATTR_ENCAP_GRE_KEY:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_TUNNEL_ATTR_ENCAP_MAPPERS:
                case SAI_TUNNEL_ATTR_DECAP_MAPPERS:
                case SAI_TUNNEL_ATTR_TERM_TABLE_ENTRY_LIST:
                    {
                    *tunnel_attr_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * attribute.value.objlist.count);
                    std::vector<sai_thrift_object_id_t>::const_iterator it2 = attribute.value.objlist.object_id_list.begin();
                    for (uint32_t j = 0; j < attribute.value.objlist.object_id_list.size(); j++, *it2++)
                    {
                        (*tunnel_attr_list)[j] = (sai_object_id_t) *it2;
                    }
                    attr_list[i].value.objlist.count = attribute.value.objlist.count;
                    attr_list[i].value.objlist.list = *tunnel_attr_list;
                    }
                    break;
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_TAGGED_VLAN:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_tunnel_term_table_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
    
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TYPE:
                case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TUNNEL_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_VR_ID:
                case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_ACTION_TUNNEL_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_DST_IP:
                case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_SRC_IP:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_isolation_group_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_ISOLATION_GROUP_ATTR_TYPE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
    
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse isolation group attributes");
                    break;
            }
        }
    }
    void sai_thrift_parse_isolation_group_member_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_ISOLATION_GROUP_MEMBER_ATTR_ISOLATION_GROUP_ID:
                    attr_list[i].value.oid= attribute.value.oid;
                    break;
                case SAI_ISOLATION_GROUP_MEMBER_ATTR_ISOLATION_OBJECT:
                    attr_list[i].value.oid= attribute.value.oid;
                    break;
    
                default:
                      SAI_THRIFT_LOG_ERR("Failed to parse isolation group attributes");
                      break;
            }
        }
    }

    void sai_thrift_parse_counter_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_COUNTER_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse counter attributes");
                    break;
            }
        }
    }
    
    void sai_thrift_parse_debug_counter_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
    
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
    
            switch (attribute.id)
            {
                case SAI_DEBUG_COUNTER_ATTR_BIND_METHOD:
                case SAI_DEBUG_COUNTER_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_DEBUG_COUNTER_ATTR_IN_DROP_REASON_LIST:
                case SAI_DEBUG_COUNTER_ATTR_OUT_DROP_REASON_LIST:
                {
                    int count = attribute.value.s32list.s32list.size();
                    sai_int32_t *s32_list = NULL;
                    std::vector<sai_int32_t>::const_iterator it = attribute.value.s32list.s32list.begin();
                    s32_list = (sai_int32_t *) malloc(sizeof(sai_int32_t) * count);
                    for(int j = 0; j < count; j++, it++)
                        *(s32_list + j) = (sai_int32_t) *it;
                    attr_list[i].value.s32list.list = s32_list;
                    attr_list[i].value.s32list.count = count;
                }
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse debug counter attributes");
                    break;
            }
        }
    }

    void sai_thrift_parse_nat_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_NAT_ENTRY_ATTR_NAT_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_NAT_ENTRY_ATTR_SRC_IP:
                case SAI_NAT_ENTRY_ATTR_SRC_IP_MASK:
                case SAI_NAT_ENTRY_ATTR_DST_IP:
                case SAI_NAT_ENTRY_ATTR_DST_IP_MASK:
                    sai_thrift_string_to_v4_ip(attribute.value.ip4, &attr_list[i].value.ip4);
                    break;
                case SAI_NAT_ENTRY_ATTR_VR_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_NAT_ENTRY_ATTR_L4_SRC_PORT:
                case SAI_NAT_ENTRY_ATTR_L4_DST_PORT:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_NAT_ENTRY_ATTR_ENABLE_BYTE_COUNT:
                case SAI_NAT_ENTRY_ATTR_ENABLE_PACKET_COUNT:
                case SAI_NAT_ENTRY_ATTR_HIT_BIT_COR:
                case SAI_NAT_ENTRY_ATTR_HIT_BIT:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                default:
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_vlan(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        sai_vlan_api_t *vlan_api = nullptr;
        sai_status_t status = SAI_STATUS_SUCCESS;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
    
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get VLAN API."); return SAI_NULL_OBJECT_ID; }
    
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_vlan_attributes(thrift_attr_list, attr_list);
    
        sai_object_id_t vlanObjId = 0;
        status = vlan_api->create_vlan(&vlanObjId, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
    
        if (status == SAI_STATUS_SUCCESS) { return vlanObjId; }
    
        SAI_THRIFT_LOG_ERR("Failed to create VLAN.");
    
        return SAI_NULL_OBJECT_ID;
    }
    
    sai_thrift_status_t sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
    {
    
        SAI_THRIFT_LOG_DBG("Called.");
        sai_vlan_api_t *vlan_api = nullptr;
        sai_status_t status = SAI_STATUS_SUCCESS;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
    
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get VLAN API."); return SAI_NULL_OBJECT_ID; }
    
        status = vlan_api->remove_vlan(vlan_oid);
        return status;
    }
    
    void sai_thrift_get_vlan_stats(std::vector<int64_t> &thrift_counters,
                                   const sai_thrift_object_id_t vlan_id,
                                   const std::vector<sai_thrift_vlan_stat_counter_t> &thrift_counter_ids,
                                   const int32_t number_of_counters)
    {
        printf("sai_thrift_get_vlan_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);

        if (status != SAI_STATUS_SUCCESS) { return; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_vlan_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        { counter_ids[i] = (sai_vlan_stat_t) *it; }

        status = vlan_api->get_vlan_stats(vlan_id,
                                          number_of_counters,
                                          counter_ids,
                                          counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) { thrift_counters.push_back(counters[i]); }

        free(counter_ids);
        free(counters);

        return;
    }


    void sai_thrift_get_vlan_stats_ext(std::vector<int64_t> &thrift_counters,
                                       const sai_thrift_object_id_t vlan_id,
                                       const std::vector<sai_thrift_vlan_stat_counter_t> &thrift_counter_ids,
                                       int8_t mode,
                                       int32_t number_of_counters)
    {
        printf("sai_thrift_get_vlan_stats_ext\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);

        if (status != SAI_STATUS_SUCCESS) { return; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_vlan_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        memset(counter_ids, 0, sizeof(sai_vlan_stat_t) * thrift_counter_ids.size());
        memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_vlan_stat_t) *it;
        }

        status = vlan_api->get_vlan_stats_ext(vlan_id,
                                              number_of_counters,
                                              counter_ids,
                                              (sai_stats_mode_t)mode,
                                              counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) { thrift_counters.push_back(counters[i]); }

        free(counter_ids);
        free(counters);

        return;
    }

    sai_thrift_status_t sai_thrift_clear_vlan_stats(const sai_thrift_object_id_t vlan_id,
                                                    const std::vector<sai_thrift_vlan_stat_counter_t> &thrift_counter_ids,
                                                    int32_t number_of_counters)
    {
        printf("sai_thrift_clear_vlan_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);

        if (status != SAI_STATUS_SUCCESS) { return status; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_vlan_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        memset(counter_ids, 0, sizeof(sai_vlan_stat_t) * thrift_counter_ids.size());
        memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_vlan_stat_t) *it;
        }

        status = vlan_api->clear_vlan_stats(vlan_id,
                                          number_of_counters,
                                          counter_ids);

        free(counter_ids);
        free(counters);

        return status;
    }


    sai_thrift_status_t sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_id, const sai_thrift_attribute_t &thrift_attr)
    {

        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api = nullptr;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get VLAN API."); return SAI_NULL_OBJECT_ID; }
        
        
        std::vector<sai_thrift_attribute_t> thrift_attr_list;
        thrift_attr_list.push_back(thrift_attr);
        
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = 1;
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_vlan_attributes(thrift_attr_list, attr_list);
        status = vlan_api->set_vlan_attribute((sai_object_id_t)vlan_id, attr_list);
	    if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set vlan attributes.");
        }
        sai_thrift_free_attr(attr_list);
        return status;
    }


    void sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t vlan_id)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api = 	nullptr;
    	sai_attribute_t sai_attrs[22];
    	sai_thrift_attribute_t thrift_vlan_member_list_attribute;
    	sai_thrift_attribute_t thrift_attr;
        sai_object_list_t *vlan_member_list_object;
    	int i = 0;
    
    	status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (status != SAI_STATUS_SUCCESS)
        {
    	SAI_THRIFT_LOG_ERR("Failed to get VLAN API.");
    	return SAI_NULL_OBJECT_ID;
    	}
    
    
        sai_attrs[i].id = SAI_VLAN_ATTR_VLAN_ID;
    	i++;
    
    	sai_attrs[i].id = SAI_VLAN_ATTR_MEMBER_LIST;
        sai_attrs[i].value.objlist.count = 256;
        sai_attrs[i].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 256);
        i++;
    
        sai_attrs[i].id = SAI_VLAN_ATTR_MAX_LEARNED_ADDRESSES;
    	i++;
    
        sai_attrs[i].id = SAI_VLAN_ATTR_STP_INSTANCE;
    	i++;
    
        sai_attrs[i].id = SAI_VLAN_ATTR_LEARN_DISABLE;
    	i++;
    
        sai_attrs[i].id = SAI_VLAN_ATTR_IPV4_MCAST_LOOKUP_KEY_TYPE;
    	i++;
    
        sai_attrs[i].id = SAI_VLAN_ATTR_IPV6_MCAST_LOOKUP_KEY_TYPE;
    	i++;
    
        //sai_attrs[].id = SAI_VLAN_ATTR_UNKNOWN_NON_IP_MCAST_OUTPUT_GROUP_ID;
        //sai_attrs[].id = SAI_VLAN_ATTR_UNKNOWN_IPV4_MCAST_OUTPUT_GROUP_ID;
        //sai_attrs[].id = SAI_VLAN_ATTR_UNKNOWN_IPV6_MCAST_OUTPUT_GROUP_ID;
        //sai_attrs[].id = SAI_VLAN_ATTR_UNKNOWN_LINKLOCAL_MCAST_OUTPUT_GROUP_ID;
        //sai_attrs[].id = SAI_VLAN_ATTR_INGRESS_ACL;
    	//sai_attrs[].id = SAI_VLAN_ATTR_EGRESS_ACL;
    
        sai_attrs[i].id = SAI_VLAN_ATTR_META_DATA;
        i++;
    
    	sai_attrs[i].id = SAI_VLAN_ATTR_UNKNOWN_UNICAST_FLOOD_CONTROL_TYPE;
        i++;
    
    	//sai_attrs[].id = SAI_VLAN_ATTR_UNKNOWN_UNICAST_FLOOD_GROUP;
    
    	sai_attrs[i].id = SAI_VLAN_ATTR_UNKNOWN_MULTICAST_FLOOD_CONTROL_TYPE;
        i++;
    
    	//sai_attrs[].id = SAI_VLAN_ATTR_UNKNOWN_MULTICAST_FLOOD_GROUP;
    
    	sai_attrs[i].id = SAI_VLAN_ATTR_BROADCAST_FLOOD_CONTROL_TYPE;
    	i++;
    
        //sai_attrs[].id = SAI_VLAN_ATTR_BROADCAST_FLOOD_GROUP;
    
    	sai_attrs[i].id = SAI_VLAN_ATTR_CUSTOM_IGMP_SNOOPING_ENABLE;
        i++;
    
        sai_attrs[i].id = SAI_VLAN_ATTR_CUSTOM_STATS_ENABLE;
        i++;
    	//sai_attrs[].id = SAI_VLAN_ATTR_TAM_OBJECT;
    
    
        vlan_api->get_vlan_attribute(vlan_id,i,sai_attrs);
    
        int j = 0 ;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_u16(sai_attrs[j].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        j++;
    
    	thrift_attr_list.attr_count = 1;
        std::vector < sai_thrift_attribute_t > & attr_list = thrift_attr_list.attr_list;
        thrift_vlan_member_list_attribute.id = SAI_VLAN_ATTR_MEMBER_LIST;
        thrift_vlan_member_list_attribute.value.objlist.count = sai_attrs[j].value.objlist.count;
        std::vector < sai_thrift_object_id_t > & vlan_member_list = thrift_vlan_member_list_attribute.value.objlist.object_id_list;
        vlan_member_list_object = &sai_attrs[j].value.objlist;
        for (int index = 0; index < sai_attrs[j].value.objlist.count; index++)
        {
            vlan_member_list.push_back((sai_thrift_object_id_t) vlan_member_list_object->list[index]);
        }
        thrift_vlan_member_list_attribute.value.__isset.objlist = true;
        attr_list.push_back(thrift_vlan_member_list_attribute);
        j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_u32(sai_attrs[j].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_oid(sai_attrs[j].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_booldata(sai_attrs[j].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_s32(sai_attrs[j].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_s32(sai_attrs[j].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_u32(sai_attrs[j].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_s32(sai_attrs[j].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_s32(sai_attrs[j].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_s32(sai_attrs[j].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_booldata(sai_attrs[j].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        j++;
    
        thrift_attr.id        = sai_attrs[j].id;
        thrift_attr.value.__set_booldata(sai_attrs[j].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        free(sai_attrs[1].value.objlist.list);
    
    }

    sai_thrift_object_id_t sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_vlan_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api;
        sai_object_id_t vlan_member_id = 0;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_vlan_member_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        vlan_api->create_vlan_member(&vlan_member_id, gSwitchId, attr_count, attr_list);
        return vlan_member_id;
    }

    void sai_thrift_create_vlan_members(sai_thrift_results_t& ret,
                                        const std::vector<sai_thrift_attribute_t> & thrift_attr_lists,
                                        const std::vector<int32_t> & thrift_attr_count_lists,
                                        int8_t mode)
    {
        printf("sai_thrift_create_vlan_members\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_status_t *status_list = NULL;
        sai_vlan_api_t *vlan_api;
        sai_object_id_t vlan_member_id = 0;
        sai_object_id_t *vlan_member_ids = NULL;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        uint32_t attr_num = 0;
        uint32 obj_count = thrift_attr_count_lists.size();
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_lists.begin();
        std::vector<int32_t>::const_iterator it_count = thrift_attr_count_lists.begin();

        std::vector<sai_thrift_attribute_t> thrift_attr_list;

        uint32_t *attr_count_list = malloc(sizeof(uint32_t) * thrift_attr_count_lists.size());
        memset(attr_count_list, 0, sizeof(uint32_t) * thrift_attr_count_lists.size());
        sai_attribute_t **p_attr_list = malloc(sizeof(sai_attribute_t*) * thrift_attr_count_lists.size());

        for(uint32_t i = 0; i < thrift_attr_count_lists.size(); i++, it_count++)
        {
            attr_num = (uint32_t)*it_count;

            for(uint32_t j = 0; j < attr_num; j++, it++)
            {
                thrift_attr_list.push_back((sai_thrift_attribute_t)*it);
            }

            p_attr_list[i] = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * attr_num);
            memset(p_attr_list[i], 0, sizeof(sai_attribute_t*) * attr_num);

            sai_thrift_parse_vlan_member_attributes(thrift_attr_list, p_attr_list[i]);

            thrift_attr_list.clear();

            attr_count_list[i] = attr_num;

        }

        status_list = malloc(sizeof(sai_status_t) * obj_count);
        vlan_member_ids = malloc(sizeof(sai_object_id_t) * obj_count);
        memset(status_list, 0, sizeof(sai_status_t) * obj_count);
        memset(vlan_member_ids, 0, sizeof(sai_object_id_t) * obj_count);

        vlan_api->create_vlan_members(gSwitchId, obj_count, attr_count_list, p_attr_list, mode, vlan_member_ids, status_list);


        for(uint32_t m = 0; m < obj_count; m ++)
        {
            ret.objlist.object_id_list.push_back(vlan_member_ids[m]);
            ret.statuslist.status_list.push_back(status_list[m]);
        }

        ret.__isset.objlist = true;
        ret.__isset.statuslist = true;

        free(status_list);
        free(vlan_member_ids);

        free(attr_count_list);

        for(uint32_t i = 0; i < thrift_attr_count_lists.size(); i++, it_count++)
        {
            free(p_attr_list[i]);
        }

        free(p_attr_list);
    }

    void sai_thrift_parse_vlan_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_VLAN_MEMBER_ATTR_VLAN_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_VLAN_MEMBER_ATTR_BRIDGE_PORT_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_VLAN_MEMBER_ATTR_VLAN_TAGGING_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
            }
        }
    }

    sai_thrift_status_t sai_thrift_set_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id, 
                                                             const sai_thrift_attribute_t &thrift_attr)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api = nullptr;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get VLAN API."); return SAI_NULL_OBJECT_ID; }
        
        std::vector<sai_thrift_attribute_t> thrift_attr_list;
        thrift_attr_list.push_back(thrift_attr);
        
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = 1;
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_vlan_member_attributes(thrift_attr_list, attr_list);
        status = vlan_api->set_vlan_member_attribute((sai_object_id_t)vlan_member_id, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set vlan attributes.");
        }
        sai_thrift_free_attr(attr_list);
        return status;
    }

    void sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t vlan_member_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api;
        sai_attribute_t attr[3];
    
        SAI_THRIFT_FUNC_LOG();
    
        thrift_attr_list.attr_count = 0;
    
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain vlan_api, status:%d", status);
            return;
        }
    
        attr[0].id = SAI_VLAN_MEMBER_ATTR_VLAN_ID;
        attr[1].id = SAI_VLAN_MEMBER_ATTR_BRIDGE_PORT_ID;
        attr[2].id = SAI_VLAN_MEMBER_ATTR_VLAN_TAGGING_MODE;
    
        status = vlan_api->get_vlan_member_attribute(vlan_member_id, 3, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain vlan member attributes, status:%d", status);
            return;
        }
    
        sai_thrift_attribute_t thrift_attr;
        int j = 0;
    
    	thrift_attr.id        = attr[j].id;
        thrift_attr.value.__set_oid(attr[j].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = attr[j].id;
        thrift_attr.value.__set_oid(attr[j].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    	j++;
    
        thrift_attr.id        = attr[j].id;
        thrift_attr.value.__set_s32(attr[j].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
    {
        printf("sai_thrift_remove_vlan_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = vlan_api->remove_vlan_member((sai_object_id_t) vlan_member_id);
        return status;
    }
    
    void sai_thrift_remove_vlan_members(sai_thrift_status_list_t & ret, 
                                        const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, 
                                        int8_t mode)
    {
        printf("sai_thrift_remove_vlan_members\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_vlan_api_t *vlan_api;
        sai_status_t *statuslist;
        sai_object_id_t *obj_id;
        status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        uint32 obj_count = thrift_object_id_list.size();
        statuslist = malloc(sizeof(sai_status_t) * obj_count);
        memset(statuslist, 0, sizeof(sai_status_t) * obj_count);
        obj_id = malloc(sizeof(sai_object_id_t) * obj_count);
        std::vector<sai_thrift_object_id_t>::const_iterator it = thrift_object_id_list.begin();
    
        for(uint32_t i = 0; i < obj_count; i++, it++)
        {
            obj_id[i] = (sai_thrift_object_id_t)*it;
        }
    
        vlan_api->remove_vlan_members(obj_count,obj_id,mode,statuslist);
    
        for(uint32_t j = 0; j < obj_count; j++)
        {
            ret.status_list.push_back(statuslist[j]);
        }
    
        ret.__isset.status_list = true;
        free(obj_id);
        free(statuslist);
    }

    void sai_thrift_get_vlan_id(sai_thrift_result_t &ret, sai_thrift_object_id_t vlan_id)
    {
        sai_attribute_t vlan_attr;
        sai_vlan_api_t *vlan_api;
    
        SAI_THRIFT_FUNC_LOG();
    
        ret.__isset.status = true;
    
        ret.status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain vlan_api, status:%d", ret.status);
            return;
        }
    
        vlan_attr.id = SAI_VLAN_ATTR_VLAN_ID;
        ret.status = vlan_api->get_vlan_attribute((sai_object_id_t)vlan_id, 1, &vlan_attr);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get vlan ID, status:%d", ret.status);
            return;
        }
    
        ret.data.u16 = vlan_attr.value.u16;
    
        ret.__isset.data = true;
        ret.data.__isset.u16 = true;
    }

    sai_thrift_object_id_t sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_virtual_router\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_virtual_router_api_t *vr_api;
        sai_object_id_t vr_id = 0;
        status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **) &vr_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_vr_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        vr_api->create_virtual_router(&vr_id, gSwitchId, attr_count, attr_list);
        free(attr_list);
        return vr_id;
    }

    sai_thrift_status_t sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
    {
        printf("sai_thrift_remove_virtual_router\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_virtual_router_api_t *vr_api;
        status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **) &vr_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = vr_api->remove_virtual_router((sai_object_id_t)vr_id);
        return status;
    }
    sai_thrift_status_t sai_thrift_set_virtual_router_attribute(const sai_thrift_object_id_t vr_id,
                                                                const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_virtual_router_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_virtual_router_api_t *vr_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **) &vr_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to set virtual router attributes, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_vr_attributes(thrift_attr_list, &attr);
        
        return vr_api->set_virtual_router_attribute(vr_id, &attr);
    }

    void sai_thrift_get_virtual_router_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t vr_id)
    {
        printf("sai_thrift_get_virtual_router_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_virtual_router_api_t *vr_api;
        sai_attribute_t attr[3];
        sai_thrift_attribute_t thrift_attr;
    
        thrift_attr_list.attr_count = 0;
    
        status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **) &vr_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
    
        attr[0].id = SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V4_STATE;
        attr[1].id = SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V6_STATE;
        attr[2].id = SAI_VIRTUAL_ROUTER_ATTR_SRC_MAC_ADDRESS;
    
        status = vr_api->get_virtual_router_attribute(vr_id, 3, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get virtual router attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        sai_attributes_booldata_to_sai_thrift_list(attr, 2, thrift_attr_list.attr_list);
    
        thrift_attr.id        = attr[2].id;
        thrift_attr.value.mac = sai_thrift_mac_to_string(attr[2].value.mac);
        thrift_attr.value.__isset.mac = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_create_route(const sai_thrift_route_entry_t &thrift_route_entry, 
                                                const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_route\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_route_api_t *route_api;
        sai_route_entry_t route_entry;
        status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_route_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = route_api->create_route_entry(&route_entry, attr_count, attr_list);
        free(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set create attributes, status:%d", status);
        }
        return status;
    }
    sai_thrift_status_t sai_thrift_create_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list,
                                                 const std::vector<sai_thrift_attribute_t> & thrift_attr_list,
                                                 const std::vector<int32_t> & thrift_attr_count_lists,
                                                 const int8_t mode)
    {
        printf("sai_thrift_create_routes\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_route_api_t *route_api;
        sai_route_entry_t route_entry;
        sai_route_entry_t *route_entrys;
        sai_status_t *obj_statuses = NULL;
        status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        uint32_t attr_num = 0;
        uint32 obj_count = thrift_attr_count_lists.size();
        std::vector<sai_thrift_route_entry_t>::const_iterator entry = thrift_route_entry_list.begin();
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        std::vector<int32_t>::const_iterator it_count = thrift_attr_count_lists.begin();
        sai_thrift_route_entry_t thrift_route_entry;
        std::vector<sai_thrift_attribute_t> thrift_attr_list1;
        
        route_entrys = malloc(sizeof(sai_route_entry_t) * thrift_route_entry_list.size());
        uint32_t *attr_count_list = malloc(sizeof(uint32_t) * thrift_attr_count_lists.size());
        memset(attr_count_list, 0, sizeof(uint32_t) * thrift_attr_count_lists.size());
        sai_attribute_t **p_attr_list = malloc(sizeof(sai_attribute_t*) * thrift_attr_count_lists.size());
        for(uint32_t i = 0; i < thrift_attr_count_lists.size(); i++, it_count++, entry++)
        {
            thrift_route_entry =  (sai_thrift_route_entry_t)* entry;
            sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
            attr_num = (uint32_t)*it_count;
        
            for(uint32_t j = 0; j < attr_num; j++, it++)
            {
                thrift_attr_list1.push_back((sai_thrift_attribute_t)*it);
            }
        
            p_attr_list[i] = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * attr_num);
            memset(p_attr_list[i], 0, sizeof(sai_attribute_t*) * attr_num);
        
            sai_thrift_parse_route_attributes(thrift_attr_list1, p_attr_list[i]);
        
            thrift_attr_list1.clear();
        
            route_entrys[i] = route_entry;
            attr_count_list[i] = attr_num;
        }
        obj_statuses = malloc(sizeof(sai_status_t) * obj_count);
        status = route_api->create_route_entries(obj_count, route_entrys, attr_count_list, p_attr_list, mode, obj_statuses);
        for(uint32_t i = 0; i < obj_count; i++)
        {
            if(obj_statuses[i] != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("Number %d is failed to create, status:%d", i, obj_statuses[i]);
            }
        }
        
        for(uint32_t i = 0; i < obj_count; i++)
        {
            free(p_attr_list[i]);
        }
        free(route_entrys);
        free(attr_count_list);
        free(p_attr_list);
        free(obj_statuses);
        return status;
    }

    sai_thrift_status_t sai_thrift_remove_route(const sai_thrift_route_entry_t &thrift_route_entry)
    {
        printf("sai_thrift_remove_route\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_route_api_t *route_api;
        sai_route_entry_t route_entry;
        status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
        status = route_api->remove_route_entry(&route_entry);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set remove attributes, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_remove_routes(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, const int8_t mode)
    {
        printf("sai_thrift_remove_routes\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_route_api_t *route_api;
        sai_route_entry_t route_entry;
        sai_route_entry_t *route_entrys;
        sai_status_t *obj_statuses = NULL;
        status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        uint32 obj_count = thrift_route_entry_list.size();
        std::vector<sai_thrift_route_entry_t>::const_iterator entry = thrift_route_entry_list.begin();
        sai_thrift_route_entry_t thrift_route_entry;
        std::vector<sai_thrift_attribute_t> thrift_attr_list1;
    
        route_entrys = malloc(sizeof(sai_route_entry_t) * thrift_route_entry_list.size());
        for(uint32_t i = 0; i < obj_count; i++, entry++)
        {
            thrift_route_entry =  (sai_thrift_route_entry_t)* entry;
            sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
    
            route_entrys[i] = route_entry;
        }
        obj_statuses = malloc(sizeof(sai_status_t) * obj_count);
        status = route_api->remove_route_entries(obj_count, route_entrys, mode, obj_statuses);
        for(uint32_t i = 0; i < obj_count; i++)
        {
            if(obj_statuses[i] != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("Number %d is failed to remove, status:%d", i, obj_statuses[i]);
            }
        }
    
        free(route_entrys);
        free(obj_statuses);
        return status;
    
    }


    sai_thrift_status_t sai_thrift_set_route_attribute(const sai_thrift_route_entry_t& thrift_route_entry, 
                                                       const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_route_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        sai_route_api_t *route_api;
        sai_route_entry_t route_entry;
        sai_attribute_t *attr_list = nullptr;
        status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_alloc_attr(attr_list, 1);
        sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
        sai_thrift_parse_route_attributes(thrift_attr_list, attr_list);
        status = route_api->set_route_entry_attribute(&route_entry, attr_list);
        sai_thrift_free_attr(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set route attributes, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_set_routes_attribute(const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, 
                                                        const std::vector<sai_thrift_attribute_t> & thrift_attr_list, 
                                                        const int8_t mode)
    {
        printf("sai_thrift_set_routes_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_route_api_t *route_api;
        sai_route_entry_t route_entry;
        sai_route_entry_t *route_entrys;
        sai_status_t *obj_statuses = NULL;
        status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        uint32 obj_count = thrift_route_entry_list.size();
        std::vector<sai_thrift_route_entry_t>::const_iterator entry = thrift_route_entry_list.begin();
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        
        sai_thrift_route_entry_t thrift_route_entry;
        std::vector<sai_thrift_attribute_t> thrift_attr_list1;
        
        route_entrys = malloc(sizeof(sai_route_entry_t) * thrift_route_entry_list.size());
        
        sai_attribute_t *p_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * obj_count);
        memset(p_attr_list, 0, sizeof(sai_attribute_t) * obj_count);
        for(uint32_t i = 0; i < obj_count; i++, entry++, it++)
        {
            thrift_route_entry =  (sai_thrift_route_entry_t)* entry;
            sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
        
            thrift_attr_list1.push_back((sai_thrift_attribute_t)*it);
        
            //p_attr_list[i] = (sai_attribute_t) malloc(sizeof(sai_attribute_t));
            //memset(p_attr_list[i], 0, sizeof(sai_attribute_t));
        
            sai_thrift_parse_route_attributes(thrift_attr_list1, &(p_attr_list[i]));
        
            thrift_attr_list1.clear();
        
            route_entrys[i] = route_entry;
        }
        obj_statuses = malloc(sizeof(sai_status_t) * obj_count);
        status = route_api->set_route_entries_attribute(obj_count, route_entrys, p_attr_list, mode, obj_statuses);
        for(uint32_t i = 0; i < obj_count; i++)
        {
            if(obj_statuses[i] != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("Number %d is failed to set attribute, status:%d", i, obj_statuses[i]);
            }
        }
        
        free(route_entrys);
        free(p_attr_list);
        free(obj_statuses);
        return status;
    }


    void sai_thrift_get_route_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_route_entry_t& thrift_route_entry)
    {
        printf("sai_thrift_get_route_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_route_api_t *route_api;
        sai_route_entry_t route_entry;
        sai_attribute_t attr[SAI_ROUTE_ENTRY_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint32_t attr_cnt = 0;
    
        status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            thrift_attr_list.status = status;
            return;
        }
    
        sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
    
        attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_PACKET_ACTION;
        attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID;
        attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_META_DATA;
        attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_IP_ADDR_FAMILY;
        attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_COUNTER_ID;
    
        status = route_api->get_route_entry_attribute(&route_entry, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get route attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        thrift_attr.id        = attr[0].id;
        thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[1].id;
        thrift_attr.value.__set_oid(attr[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[2].id;
        thrift_attr.value.__set_u32(attr[2].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[3].id;
        thrift_attr.value.__set_u32(attr[3].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[4].id;
        thrift_attr.value.__set_oid(attr[4].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
    }
    
    void sai_thrift_get_routes_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                         const std::vector<sai_thrift_route_entry_t> & thrift_route_entry_list, 
                                         const int8_t mode)
    {
        printf("sai_thrift_get_routes_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_route_api_t *route_api;
        sai_route_entry_t route_entry;
        sai_route_entry_t *route_entrys;
        sai_attribute_t attr[SAI_ROUTE_ENTRY_ATTR_END];
        uint32_t attr_cnt = 0;
        uint32_t count = 0;
        sai_thrift_attribute_t thrift_attr;
        sai_status_t *obj_statuses = NULL;
        status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            thrift_attr_list.status = status;
            return;
        }
        uint32 obj_count = thrift_route_entry_list.size();
        
        std::vector<sai_thrift_route_entry_t>::const_iterator entry = thrift_route_entry_list.begin();
        sai_thrift_route_entry_t thrift_route_entry;
        std::vector<sai_thrift_attribute_t> thrift_attr_list1;
        
        uint32_t *attr_count_list = malloc(sizeof(uint32_t) * obj_count);
        memset(attr_count_list, 0, sizeof(uint32_t) * obj_count);
        sai_attribute_t **p_attr_list = malloc(sizeof(sai_attribute_t*) * obj_count);
        
        route_entrys = malloc(sizeof(sai_route_entry_t) * thrift_route_entry_list.size());
        for(uint32_t i = 0; i < obj_count; i++, entry++)
        {
            thrift_route_entry =  (sai_thrift_route_entry_t)* entry;
            sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
        
            attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_PACKET_ACTION;
            attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID;
            attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_META_DATA;
            attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_IP_ADDR_FAMILY;
            attr[attr_cnt++].id = SAI_ROUTE_ENTRY_ATTR_COUNTER_ID;
            p_attr_list[i] = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * 5);
            memcpy(p_attr_list[i], attr, sizeof(sai_attribute_t) * 5);
            route_entrys[i] = route_entry;
            attr_count_list[i] = 5;
            attr_cnt = 0;
         }
        
        obj_statuses = malloc(sizeof(sai_status_t) * obj_count);
        status = route_api->get_route_entries_attribute(obj_count, route_entrys, attr_count_list, p_attr_list, mode, obj_statuses);
        
        for(uint32_t i = 0; i < obj_count; i++)
        {
            if(obj_statuses[i] != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("Number %d is failed to get attribute, status:%d", i, obj_statuses[i]);
            }
        }
        
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get route attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        count = obj_count * 5;
        for(uint32_t i = 0; i < count; i++)
        {
            switch(i%5)
            {
                case 0:
                    thrift_attr.id        = p_attr_list[i/5][i%5].id;
                    thrift_attr.value.__set_s32(p_attr_list[i/5][i%5].value.s32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
                case 1:
                case 4:
                    thrift_attr.id        = p_attr_list[i/5][i%5].id;
                    thrift_attr.value.__set_oid(p_attr_list[i/5][i%5].value.oid);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
                case 2:
                case 3:
                    thrift_attr.id        = p_attr_list[i/5][i%5].id;
                    thrift_attr.value.__set_u32(p_attr_list[i/5][i%5].value.u32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
            }
        }
        for(uint32_t i = 0; i < obj_count; i++)
        {
            free(p_attr_list[i]);
        }
        free(route_entrys);
        free(attr_count_list);
        free(p_attr_list);
        free(obj_statuses);
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_router_interface\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_router_interface_api_t *rif_api;
        sai_object_id_t rif_id = 0;
        status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_router_interface_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = rif_api->create_router_interface(&rif_id, gSwitchId, attr_count, attr_list);
        free(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to create router interface, status:%d", status);
        }
        return rif_id;
    }
    
    sai_thrift_status_t sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
    {
        printf("sai_thrift_remove_router_interface\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_router_interface_api_t *rif_api;
        status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = rif_api->remove_router_interface((sai_object_id_t)rif_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove router interface, status:%d", status);
        }
        return status;
    }
    
    sai_thrift_status_t sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, 
                                                                  const sai_thrift_attribute_t &thrift_attr)
    {
        printf("sai_thrift_set_router_interface\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_router_interface_api_t *rif_api;
        status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        std::vector<sai_thrift_attribute_t> thrift_attr_list;
        thrift_attr_list.push_back(thrift_attr);
        sai_attribute_t attr;
        sai_thrift_parse_router_interface_attributes(thrift_attr_list, &attr);
        status = rif_api->set_router_interface_attribute((sai_object_id_t)rif_id, &attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set router interface attributes, status:%d", status);
        }
        return status;
    }

    void sai_thrift_get_router_interface_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t rif_id)
    {
        printf("sai_thrift_get_router_interface_attribute\n");
        
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_router_interface_api_t *rif_api;
        sai_attribute_t attr[SAI_VIRTUAL_ROUTER_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint32_t attr_cnt = 0;
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        attr_cnt = 0;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_ADMIN_V4_STATE;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_ADMIN_V6_STATE;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_V4_MCAST_ENABLE;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_V6_MCAST_ENABLE;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_CUSTOM_STATS_STATE;
        status = rif_api->get_router_interface_attribute(rif_id, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get router interface attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        sai_attributes_booldata_to_sai_thrift_list(attr, attr_cnt, thrift_attr_list.attr_list);
        
        attr_cnt = 0;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_VIRTUAL_ROUTER_ID;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_PORT_ID;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_VLAN_ID;
        
        status = rif_api->get_router_interface_attribute(rif_id, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get router interface attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        sai_attributes_to_sai_thrift_list(attr, attr_cnt, thrift_attr_list.attr_list);
        
        attr_cnt = 0;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_TYPE;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_NEIGHBOR_MISS_PACKET_ACTION;
        status = rif_api->get_router_interface_attribute(rif_id, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get router interface attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        sai_attributes_s32_to_sai_thrift_list(attr, attr_cnt, thrift_attr_list.attr_list);
        
        attr_cnt = 0;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_MTU;
        status = rif_api->get_router_interface_attribute(rif_id, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get router interface attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        sai_attributes_u32_to_sai_thrift_list(attr, attr_cnt, thrift_attr_list.attr_list);
        
        attr_cnt = 0;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_OUTER_VLAN_ID;
        status = rif_api->get_router_interface_attribute(rif_id, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get router interface attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        sai_attributes_u16_to_sai_thrift_list(attr, attr_cnt, thrift_attr_list.attr_list);
        
        attr_cnt = 0;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_SRC_MAC_ADDRESS;
        status = rif_api->get_router_interface_attribute(rif_id, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get router interface attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        thrift_attr.id        = attr[0].id;
        thrift_attr.value.mac = sai_thrift_mac_to_string(attr[0].value.mac);
        thrift_attr.value.__isset.mac = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        
        attr_cnt = 0;
        attr[attr_cnt++].id = SAI_ROUTER_INTERFACE_ATTR_NAT_ZONE_ID;
        status = rif_api->get_router_interface_attribute(rif_id, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            //SAI_THRIFT_LOG_ERR("Failed to get router interface attributes, status:%d", status);
            //thrift_attr_list.status = status;
            //return;
        }
        thrift_attr.id        = attr[0].id;
        thrift_attr.value.__set_u8(attr[0].value.u8);
    }

    void sai_thrift_router_interface_get_stats(std::vector<int64_t> &thrift_counters,
                                               const sai_thrift_object_id_t rif_id,
                                               const std::vector<sai_thrift_router_interface_stat_counter_t> &thrift_counter_ids,
                                               int32_t number_of_counters)
  	{
		printf("sai_thrift_get_router_interface_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_router_interface_api_t *rif_api;
        status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);

        if (status != SAI_STATUS_SUCCESS) { return; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_router_interface_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
		memset(counter_ids, 0, sizeof(sai_router_interface_stat_t) * thrift_counter_ids.size());
		memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
        	counter_ids[i] = (sai_router_interface_stat_t) *it;
		}

        status = rif_api->get_router_interface_stats(rif_id,
                                          number_of_counters,
                                          counter_ids,
                                          counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) { thrift_counters.push_back(counters[i]); }

        free(counter_ids);
        free(counters);

        return;
  	}

    void sai_thrift_router_interface_get_stats_ext(std::vector<int64_t> &thrift_counters,
                                                   const sai_thrift_object_id_t rif_id,
                                                   const std::vector<sai_thrift_router_interface_stat_counter_t> &thrift_counter_ids,
                                                   int8_t mode,
                                                   int32_t number_of_counters)
  	{
		printf("sai_thrift_router_interface_get_stats_ext\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_router_interface_api_t *rif_api;
        status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);

        if (status != SAI_STATUS_SUCCESS) { return; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_router_interface_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
		memset(counter_ids, 0, sizeof(sai_router_interface_stat_t) * thrift_counter_ids.size());
		memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
        	counter_ids[i] = (sai_router_interface_stat_t) *it;
		}

        status = rif_api->get_router_interface_stats_ext(rif_id,
                                          number_of_counters,
                                          counter_ids,
                                          (sai_stats_mode_t)mode,
                                          counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) { thrift_counters.push_back(counters[i]); }

        free(counter_ids);
        free(counters);

        return;
  	}

    sai_thrift_status_t sai_thrift_router_interface_clear_stats(const sai_thrift_object_id_t rif_id,
        const std::vector<sai_thrift_router_interface_stat_counter_t> &thrift_counter_ids,
        int32_t number_of_counters)
  	{
  		printf("sai_thrift_router_interface_clear_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_router_interface_api_t *rif_api;
        status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);

        if (status != SAI_STATUS_SUCCESS) { return status; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_router_interface_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
		memset(counter_ids, 0, sizeof(sai_router_interface_stat_t) * thrift_counter_ids.size());
		memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
        	counter_ids[i] = (sai_router_interface_stat_t) *it;
		}

        status = rif_api->clear_router_interface_stats(rif_id,
                                          number_of_counters,
                                          counter_ids);

        free(counter_ids);
        free(counters);

        return status;
  	}

    sai_thrift_object_id_t sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_next_hop\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_next_hop_api_t *nhop_api;
        sai_object_id_t nhop_id = 0;
        status = sai_api_query(SAI_API_NEXT_HOP, (void **) &nhop_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
	    sai_uint32_t     *buffer_profile_list1 = NULL;
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_next_hop_attributes(thrift_attr_list, attr_list, &buffer_profile_list1);
        uint32_t attr_count = thrift_attr_list.size();
        status = nhop_api->create_next_hop(&nhop_id, gSwitchId, attr_count, attr_list);
        free(attr_list);
        if (buffer_profile_list1)
        {
            free(buffer_profile_list1);
        }
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to create next hop, status:%d", status);
        }
        return nhop_id;
    }

    sai_thrift_status_t sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
    {
        printf("sai_thrift_remove_next_hop\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_next_hop_api_t *nhop_api;
        status = sai_api_query(SAI_API_NEXT_HOP, (void **) &nhop_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = nhop_api->remove_next_hop((sai_object_id_t)next_hop_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove next hop, status:%d", status);
        }
        return status;
    }


    void sai_thrift_get_next_hop_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t next_hop_id)
    {
        printf("sai_thrift_get_next_hop_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_next_hop_api_t *nhop_api;
        sai_attribute_t attr[SAI_NEXT_HOP_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_NEXT_HOP, (void **) &nhop_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        attr[0].id = SAI_NEXT_HOP_ATTR_TYPE;
        status = nhop_api->get_next_hop_attribute(next_hop_id, 1, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get next hop attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        if(SAI_NEXT_HOP_TYPE_IP == attr[0].value.s32)
        {
            attr[0].id = SAI_NEXT_HOP_ATTR_TYPE;
            attr[1].id = SAI_NEXT_HOP_ATTR_IP;
            attr[2].id = SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID;
            
        
            status = nhop_api->get_next_hop_attribute(next_hop_id, 3, attr);
            if (status != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("Failed to get next hop attributes, status:%d", status);
                thrift_attr_list.status = status;
                return;
            }
        
            thrift_attr.id        = attr[0].id;
            thrift_attr.value.__set_s32(attr[0].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
        
            thrift_attr.id        = attr[1].id;
            thrift_attr.value.ipaddr.addr_family = attr[1].value.ipaddr.addr_family;
            if (SAI_IP_ADDR_FAMILY_IPV4 == attr[1].value.ipaddr.addr_family)
            {
                thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(attr[1].value.ipaddr.addr.ip4);
            }
            else
            {
        
            }
            thrift_attr.value.__isset.ipaddr = true;
            thrift_attr.value.ipaddr.__isset.addr_family = true;
            thrift_attr.value.ipaddr.__isset.addr = true;
            thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
        
            thrift_attr.id        = attr[2].id;
            thrift_attr.value.__set_oid(attr[2].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
        }
          
        if(SAI_NEXT_HOP_TYPE_MPLS == attr[0].value.s32)
        {
            attr[0].id = SAI_NEXT_HOP_ATTR_TYPE;
            attr[1].id = SAI_NEXT_HOP_ATTR_IP;
            attr[2].id = SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID;
            attr[3].id = SAI_NEXT_HOP_ATTR_LABELSTACK;
            attr[3].value.u32list.list = (uint32_t *) malloc(sizeof(uint32_t) * 10);
            attr[3].value.u32list.count = 10;
            attr[4].id = SAI_NEXT_HOP_ATTR_COUNTER_ID;
            attr[5].id = SAI_NEXT_HOP_ATTR_NEXT_LEVEL_NEXT_HOP_ID;
            attr[6].id = SAI_NEXT_HOP_ATTR_TUNNEL_ID;
            attr[7].id = SAI_NEXT_HOP_ATTR_OUTSEG_TYPE;
            attr[8].id = SAI_NEXT_HOP_ATTR_OUTSEG_TTL_MODE;
            attr[9].id = SAI_NEXT_HOP_ATTR_OUTSEG_TTL_VALUE;
            attr[10].id = SAI_NEXT_HOP_ATTR_OUTSEG_EXP_MODE;
            attr[11].id = SAI_NEXT_HOP_ATTR_OUTSEG_EXP_VALUE;
            attr[12].id = SAI_NEXT_HOP_ATTR_QOS_TC_AND_COLOR_TO_MPLS_EXP_MAP;
             
            
            status = nhop_api->get_next_hop_attribute(next_hop_id, 13, attr);
            if (status != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("Failed to get next hop attributes, status:%d", status);
                thrift_attr_list.status = status;
                return;
            }
            
            thrift_attr.id        = attr[0].id;
            thrift_attr.value.__set_s32(attr[0].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = attr[1].id;
            thrift_attr.value.ipaddr.addr_family = attr[1].value.ipaddr.addr_family;
            if (SAI_IP_ADDR_FAMILY_IPV4 == attr[1].value.ipaddr.addr_family)
            {
                thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(attr[1].value.ipaddr.addr.ip4);
            }
            else
            {
            
            }
            thrift_attr.value.__isset.ipaddr = true;
            thrift_attr.value.ipaddr.__isset.addr_family = true;
            thrift_attr.value.ipaddr.__isset.addr = true;
            thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = attr[2].id;
            thrift_attr.value.__set_oid(attr[2].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
        
            thrift_attr.id = attr[3].id;
            thrift_attr.value.u32list.count = attr[3].value.u32list.count;
            std :: vector < sai_int32_t >& member_list = thrift_attr.value.u32list.u32list;
            //member_list_object = &attr[3].value.objlist;
            for (int index = 0; index < attr[3].value.u32list.count; index++)
            {
                member_list.push_back((sai_int32_t) attr[3].value.u32list.list[index]);
            }
            //thrift_attr.value.__isset.objlist = true;
            thrift_attr.value.__isset.u32list = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            free(attr[3].value.u32list.list);
            
            thrift_attr.id        = attr[4].id;
            thrift_attr.value.__set_oid(attr[4].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = attr[5].id;
            thrift_attr.value.__set_oid(attr[5].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = attr[6].id;
            thrift_attr.value.__set_oid(attr[6].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);

            thrift_attr.id        = attr[7].id;
            thrift_attr.value.__set_s32(attr[7].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);

            thrift_attr.id        = attr[8].id;
            thrift_attr.value.__set_s32(attr[8].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);

            thrift_attr.id        = attr[9].id;
            thrift_attr.value.__set_u8(attr[9].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);

            thrift_attr.id        = attr[10].id;
            thrift_attr.value.__set_s32(attr[10].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);

            thrift_attr.id        = attr[11].id;
            thrift_attr.value.__set_u8(attr[11].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);

            thrift_attr.id        = attr[12].id;
            thrift_attr.value.__set_oid(attr[12].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
        }

        if(SAI_NEXT_HOP_TYPE_TUNNEL_ENCAP == attr[0].value.s32)
        {
            attr[0].id = SAI_NEXT_HOP_ATTR_TYPE;
            attr[1].id = SAI_NEXT_HOP_ATTR_LABELSTACK;
            attr[1].value.u32list.list = (uint32_t *) malloc(sizeof(uint32_t) * 10);
            attr[1].value.u32list.count = 10;
            attr[2].id = SAI_NEXT_HOP_ATTR_NEXT_LEVEL_NEXT_HOP_ID;
            attr[3].id = SAI_NEXT_HOP_ATTR_MPLS_ENCAP_TUNNEL_ID;
            attr[4].id = SAI_NEXT_HOP_ATTR_COUNTER_ID;
            attr[5].id = SAI_NEXT_HOP_ATTR_QOS_TC_AND_COLOR_TO_MPLS_EXP_MAP;
             
            
            status = nhop_api->get_next_hop_attribute(next_hop_id, 6, attr);
            if (status != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("Failed to get next hop attributes, status:%d", status);
                thrift_attr_list.status = status;
                return;
            }
            
            thrift_attr.id        = attr[0].id;
            thrift_attr.value.__set_s32(attr[0].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            
            thrift_attr.id = attr[1].id;
    	    thrift_attr.value.u32list.count = attr[1].value.u32list.count;
    	    std :: vector < sai_int32_t >& member_list = thrift_attr.value.u32list.u32list;
            //member_list_object = &attr[1].value.objlist;
            for (int index = 0; index < attr[1].value.u32list.count; index++)
            {
                member_list.push_back((sai_int32_t) attr[1].value.u32list.list[index]);
            }
            //thrift_attr.value.__isset.objlist = true;
            thrift_attr.value.__isset.u32list = true;
            
            thrift_attr_list.attr_list.push_back(thrift_attr);
    	    free(attr[1].value.u32list.list);
            
            thrift_attr.id        = attr[2].id;
            thrift_attr.value.__set_oid(attr[2].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = attr[3].id;
            thrift_attr.value.__set_oid(attr[3].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = attr[4].id;
            thrift_attr.value.__set_oid(attr[4].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);

            thrift_attr.id        = attr[5].id;
            thrift_attr.value.__set_oid(attr[5].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
        }
    }

    sai_thrift_object_id_t sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_lag\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_lag_api_t *lag_api;
        sai_object_id_t lag_id = 0;
        
        status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_lag_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = lag_api->create_lag(&lag_id, gSwitchId, attr_count, attr_list);
        return lag_id;
    }

    sai_thrift_status_t sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
    {
        printf("sai_thrift_remove_lag\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_lag_api_t *lag_api;
        status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = lag_api->remove_lag((sai_object_id_t)lag_id);
        return status;
    }
    
    sai_thrift_status_t sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        sai_lag_api_t *lag_api;
        sai_attribute_t *attr_list = nullptr;
        printf("sai_thrift_set_lag_attribute\n");
    
        status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_thrift_alloc_attr(attr_list, 1);
        sai_thrift_parse_lag_attributes(thrift_attr_list, attr_list);
    
        status = lag_api->set_lag_attribute(lag_id, attr_list);
        sai_thrift_free_attr(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set LAG attribute");
            return status;
        }
    
        return status;
    }

    void sai_thrift_get_lag_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t lag_id)
    {
        printf("sai_thrift_get_lag_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_lag_api_t *lag_api;
        sai_attribute_t sai_attrs[10];
        sai_thrift_attribute_t thrift_port_list_attribute;
        sai_thrift_attribute_t thrift_attr;
        sai_object_list_t *port_list_object;
        int i = 0;
        status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
    
    
        sai_attrs[i].id = SAI_LAG_ATTR_PORT_LIST;
        sai_attrs[i].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 128);
        sai_attrs[i].value.objlist.count = 128;
        i++;
    
        sai_attrs[i].id = SAI_LAG_ATTR_PORT_VLAN_ID;
        i++;
        sai_attrs[i].id = SAI_LAG_ATTR_DEFAULT_VLAN_PRIORITY;
        i++;
        sai_attrs[i].id = SAI_LAG_ATTR_DROP_UNTAGGED;
        i++;
        sai_attrs[i].id = SAI_LAG_ATTR_DROP_TAGGED;
        i++;
        sai_attrs[i].id = SAI_LAG_ATTR_INGRESS_ACL;
        i++;
        sai_attrs[i].id = SAI_LAG_ATTR_MODE;
        i++;
        sai_attrs[i].id = SAI_LAG_ATTR_CUSTOM_MAX_MEMBER_NUM;
        i++;

        status = lag_api->get_lag_attribute(lag_id, i, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get lag attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        thrift_attr_list.attr_count = 1;
        std::vector < sai_thrift_attribute_t > & attr_list = thrift_attr_list.attr_list;
        thrift_port_list_attribute.id = SAI_LAG_ATTR_PORT_LIST;
        thrift_port_list_attribute.value.objlist.count = sai_attrs[0].value.objlist.count;
        std::vector < sai_thrift_object_id_t > & port_list = thrift_port_list_attribute.value.objlist.object_id_list;
        port_list_object = &sai_attrs[0].value.objlist;
        for (int index = 0; index < sai_attrs[0].value.objlist.count; index++)
        {
            port_list.push_back((sai_thrift_object_id_t) port_list_object->list[index]);
        }
        thrift_port_list_attribute.value.__isset.objlist = true;
        attr_list.push_back(thrift_port_list_attribute);
    
        thrift_attr.id        = sai_attrs[1].id;
        thrift_attr.value.__set_u16(sai_attrs[1].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[2].id;
        thrift_attr.value.__set_u8(sai_attrs[2].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[3].id;
        thrift_attr.value.__set_booldata(sai_attrs[3].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[4].id;
        thrift_attr.value.__set_booldata(sai_attrs[4].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = sai_attrs[5].id;
        thrift_attr.value.__set_oid(sai_attrs[5].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = sai_attrs[6].id;
        thrift_attr.value.__set_s32(sai_attrs[6].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = sai_attrs[7].id;
        thrift_attr.value.__set_u16(sai_attrs[7].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        free(sai_attrs[0].value.objlist.list);
    }

    sai_thrift_object_id_t sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_lag_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_lag_api_t *lag_api;
        sai_object_id_t lag_member_id = 0;
        status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_lag_member_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = lag_api->create_lag_member(&lag_member_id, gSwitchId, attr_count, attr_list);
        return lag_member_id;
    }

    sai_thrift_status_t sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
    {
        printf("sai_thrift_remove_lag_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_lag_api_t *lag_api;
        status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = lag_api->remove_lag_member(lag_member_id);
        return status;
    }

    sai_thrift_status_t sai_thrift_set_lag_member_attribute(const sai_thrift_object_id_t lag_member_id, 
                                                            const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        sai_lag_api_t *lag_api;
        sai_attribute_t *attr_list = nullptr;
        printf("sai_thrift_set_lag_member_attribute\n");
    
        status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_thrift_alloc_attr(attr_list, 1);
        sai_thrift_parse_lag_member_attributes(thrift_attr_list, attr_list);
    
        status = lag_api->set_lag_member_attribute(lag_member_id, attr_list);
        sai_thrift_free_attr(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set LAG member attribute");
            return status;
        }
    
        return status;
    }

    void sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t lag_member_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_attribute_t sai_attrs[4];
        sai_lag_api_t *lag_api;
    
        status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain lag_api, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        SAI_THRIFT_FUNC_LOG();
    
        sai_attrs[0].id = SAI_LAG_MEMBER_ATTR_LAG_ID;
        sai_attrs[1].id = SAI_LAG_MEMBER_ATTR_PORT_ID;
        sai_attrs[2].id = SAI_LAG_MEMBER_ATTR_EGRESS_DISABLE;
        sai_attrs[3].id = SAI_LAG_MEMBER_ATTR_INGRESS_DISABLE;
    
        status = lag_api->get_lag_member_attribute(lag_member_id, 4, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain lag member attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }

        sai_thrift_attribute_t thrift_attr;
        
        thrift_attr.id      = sai_attrs[0].id;
        thrift_attr.value.__set_oid(sai_attrs[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id      = sai_attrs[1].id;
        thrift_attr.value.__set_oid(sai_attrs[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id      = sai_attrs[2].id;
        thrift_attr.value.__set_booldata(sai_attrs[2].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id      = sai_attrs[3].id;
        thrift_attr.value.__set_booldata(sai_attrs[3].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_object_id_t sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_stp\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api;
        sai_vlan_id_t *vlan_list;
        sai_object_id_t stp_id = SAI_NULL_OBJECT_ID;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_stp_attributes(thrift_attr_list, attr_list, &vlan_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = (sai_thrift_status_t) stp_api->create_stp(&stp_id, gSwitchId, attr_count, attr_list);
        if (vlan_list)
        {
           free(attr_list);
        }
        return stp_id;
    }
    
    sai_thrift_status_t sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
    {
        printf("sai_thrift_remove_stp\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = (sai_thrift_status_t) stp_api->remove_stp(stp_id);
        return status;
    }

    void sai_thrift_create_stp_ports(sai_thrift_results_t& ret,
                                     const std::vector<sai_thrift_attribute_t> & thrift_attr_lists,
                                     const std::vector<int32_t> & thrift_attr_count_lists,
                                     int8_t mode)
    {
        printf("sai_thrift_create_stp_ports\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_status_t *status_list = NULL;
        sai_stp_api_t *stp_api;
        sai_object_id_t *stp_port_ids = NULL;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        uint32_t attr_num = 0;
        uint32 obj_count = thrift_attr_count_lists.size();
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_lists.begin();
        std::vector<int32_t>::const_iterator it_count = thrift_attr_count_lists.begin();

        std::vector<sai_thrift_attribute_t> thrift_attr_list;

        uint32_t *attr_count_list = malloc(sizeof(uint32_t) * thrift_attr_count_lists.size());
        memset(attr_count_list, 0, sizeof(uint32_t) * thrift_attr_count_lists.size());

        sai_attribute_t **p_attr_list = malloc(sizeof(sai_attribute_t*) * thrift_attr_count_lists.size());


        for(uint32_t i = 0; i < thrift_attr_count_lists.size(); i++, it_count++)
        {
            attr_num = (uint32_t)*it_count;

            for(uint32_t j = 0; j < attr_num; j++, it++)
            {
                thrift_attr_list.push_back((sai_thrift_attribute_t)*it);
            }

            p_attr_list[i] = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * attr_num);
            memset(p_attr_list[i], 0, sizeof(sai_attribute_t*) * attr_num);

            sai_thrift_parse_stp_port_attributes(thrift_attr_list, p_attr_list[i]);

            thrift_attr_list.clear();

            attr_count_list[i] = attr_num;
        }

        status_list = malloc(sizeof(sai_status_t) * obj_count);
        stp_port_ids = malloc(sizeof(sai_object_id_t) * obj_count);
        memset(status_list, 0, sizeof(sai_status_t) * obj_count);
        memset(stp_port_ids, 0, sizeof(sai_object_id_t) * obj_count);

        stp_api->create_stp_ports(gSwitchId, obj_count, attr_count_list, p_attr_list, mode, stp_port_ids, status_list);

        for(uint32_t m = 0; m < obj_count; m ++)
        {
            ret.objlist.object_id_list.push_back(stp_port_ids[m]);
            ret.statuslist.status_list.push_back(status_list[m]);
        }

        ret.__isset.objlist = true;
        ret.__isset.statuslist = true;

        free(status_list);
        free(stp_port_ids);

        free(attr_count_list);

        for(uint32_t i = 0; i < thrift_attr_count_lists.size(); i++, it_count++)
        {
            free(p_attr_list[i]);
        }

        free(p_attr_list);
    }

    void sai_thrift_remove_stp_ports(sai_thrift_status_list_t & ret, 
                                     const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, 
                                     int8_t mode)
    {
        printf("sai_thrift_remove_stp_ports\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api;
        sai_status_t *statuslist;
        sai_object_id_t *obj_id;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        uint32 obj_count = thrift_object_id_list.size();
        statuslist = malloc(sizeof(sai_status_t) * obj_count);
        memset(statuslist, 0, sizeof(sai_status_t) * obj_count);
    
        obj_id = malloc(sizeof(sai_object_id_t) * obj_count);
        std::vector<sai_thrift_object_id_t>::const_iterator it = thrift_object_id_list.begin();
    
        for(uint32_t i = 0; i < obj_count; i++, it++)
        {
          obj_id[i] = (sai_thrift_object_id_t)*it;
        }
    
        stp_api->remove_stp_ports(obj_count,obj_id,mode,statuslist);
    
        for(uint32_t j = 0; j < obj_count; j++)
        {
          ret.status_list.push_back(statuslist[j]);
        }
    
        ret.__isset.status_list = true;
        free(obj_id);
        free(statuslist);
    }

    void sai_thrift_get_stp_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t stp_id)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api = 	nullptr;
        sai_attribute_t sai_attrs[3];
        sai_thrift_attribute_t thrift_stp_port_list_attribute;
        sai_thrift_attribute_t thrift_stp_vlan_list_attribute;
        sai_thrift_attribute_t thrift_attr;
        sai_object_list_t *stp_port_list_object;
        sai_vlan_list_t   *stp_vlan_list_object;
    
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
        SAI_THRIFT_LOG_ERR("Failed to get STP API.");
        return SAI_NULL_OBJECT_ID;
        }
    
        sai_attrs[0].id = SAI_STP_ATTR_VLAN_LIST;
        sai_attrs[0].value.vlanlist.count = 4096;
        sai_attrs[0].value.vlanlist.list = (sai_vlan_id_t *) malloc(sizeof(sai_vlan_id_t) * 4096);
    
        sai_attrs[1].id = SAI_STP_ATTR_BRIDGE_ID;
    
        sai_attrs[2].id = SAI_STP_ATTR_PORT_LIST;
        sai_attrs[2].value.objlist.count = 256;
        sai_attrs[2].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 256);
    
        stp_api->get_stp_attribute(stp_id,3,sai_attrs);
    
        thrift_attr_list.attr_count = 2;
        std::vector < sai_thrift_attribute_t > & attr_list = thrift_attr_list.attr_list;
    
        thrift_stp_vlan_list_attribute.id = SAI_STP_ATTR_VLAN_LIST;
        thrift_stp_vlan_list_attribute.value.vlanlist.vlan_count = sai_attrs[0].value.vlanlist.count;
        std::vector < sai_thrift_vlan_id_t > & stp_vlan_list = thrift_stp_vlan_list_attribute.value.vlanlist.vlan_list;
    
        stp_vlan_list_object = &sai_attrs[0].value.vlanlist;
        for (int index = 0; index < sai_attrs[0].value.vlanlist.count; index++)
        {
            stp_vlan_list.push_back((sai_vlan_id_t) stp_vlan_list_object->list[index]);
        }
        thrift_stp_vlan_list_attribute.value.__isset.vlanlist = true;
        attr_list.push_back(thrift_stp_vlan_list_attribute);
    
        thrift_attr.id        = sai_attrs[1].id;
        thrift_attr.value.__set_oid(sai_attrs[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
    
        thrift_stp_port_list_attribute.id = SAI_STP_ATTR_PORT_LIST;
        thrift_stp_port_list_attribute.value.objlist.count = sai_attrs[2].value.objlist.count;
        std::vector < sai_thrift_object_id_t > & stp_port_list = thrift_stp_port_list_attribute.value.objlist.object_id_list;
    
        stp_port_list_object = &sai_attrs[2].value.objlist;
        for (int index = 0; index < sai_attrs[2].value.objlist.count; index++)
        {
            stp_port_list.push_back((sai_thrift_object_id_t) stp_port_list_object->list[index]);
        }
    
        thrift_stp_port_list_attribute.value.__isset.objlist = true;
        attr_list.push_back(thrift_stp_port_list_attribute);
    
        free(sai_attrs[0].value.vlanlist.list);
        free(sai_attrs[2].value.objlist.list);
    }


    void sai_thrift_parse_stp_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                              sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_STP_PORT_ATTR_STP:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_STP_PORT_ATTR_BRIDGE_PORT:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_STP_PORT_ATTR_STATE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_stp_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_stp_port\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api = nullptr;
        sai_object_id_t stp_port_id = 0;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
    
        sai_thrift_parse_stp_port_attributes(thrift_attr_list, attr_list);
    
        uint32_t attr_count = thrift_attr_list.size();
    
        stp_api->create_stp_port(&stp_port_id, gSwitchId, attr_count, attr_list);
    
        return stp_port_id;
    }
    
    sai_thrift_status_t sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_id)
    {
        printf("sai_thrift_remove_stp_port\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = (sai_thrift_status_t) stp_api->remove_stp_port(stp_port_id);
        return status;
    }

    sai_thrift_status_t sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, 
                                                      const sai_thrift_object_id_t port_id, 
                                                      const sai_thrift_port_stp_port_state_t stp_port_state)
    {
        printf("sai_thrift_set_stp_port_state\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t attr[1];
        std::memset(attr, '\0', sizeof(attr));
        attr[0].id = SAI_STP_PORT_ATTR_STATE;
        attr[0].value.s32 = stp_port_state;
        status = stp_api->set_stp_port_attribute(stp_id, attr);
        return status;
    }

    sai_thrift_port_stp_port_state_t sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, 
                                                                   const sai_thrift_object_id_t port_id)
    {
        printf("sai_thrift_get_stp_port_state\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t attr[1];
        std::memset(attr, '\0', sizeof(attr));
        attr[0].id = SAI_STP_PORT_ATTR_STATE;
        status = stp_api->get_stp_port_attribute(port_id, 1, attr);
        return (sai_thrift_port_stp_port_state_t) attr[0].value.s32;
    }

    void sai_thrift_get_stp_port_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t stp_port_id)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_stp_api_t *stp_api =	  nullptr;
        sai_attribute_t sai_attrs[3];
        sai_thrift_attribute_t thrift_attr;
        status = sai_api_query(SAI_API_STP, (void **) &stp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get STP API.");
            return SAI_NULL_OBJECT_ID;
        }
        
        sai_attrs[0].id = SAI_STP_PORT_ATTR_STP;
        sai_attrs[1].id = SAI_STP_PORT_ATTR_BRIDGE_PORT;
        sai_attrs[2].id = SAI_STP_PORT_ATTR_STATE;
        
        stp_api->get_stp_port_attribute(stp_port_id,3,sai_attrs);
        
        thrift_attr.id		= sai_attrs[0].id;
        thrift_attr.value.__set_oid(sai_attrs[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id		= sai_attrs[1].id;
        thrift_attr.value.__set_oid(sai_attrs[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id		= sai_attrs[2].id;
        thrift_attr.value.__set_s32(sai_attrs[2].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, 
                                                         const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_neighbor_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_neighbor_api_t *neighbor_api;
        status = sai_api_query(SAI_API_NEIGHBOR, (void **) &neighbor_api);
        sai_neighbor_entry_t neighbor_entry;
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_neighbor_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = neighbor_api->create_neighbor_entry(&neighbor_entry, attr_count, attr_list);
        free(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to create neighbor entry, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
    {
        printf("sai_thrift_remove_neighbor_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_neighbor_api_t *neighbor_api;
        sai_neighbor_entry_t neighbor_entry;
        status = sai_api_query(SAI_API_NEIGHBOR, (void **) &neighbor_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
        status = neighbor_api->remove_neighbor_entry(&neighbor_entry);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove neighbor entry, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_remove_all_neighbor_entry(void)
    {
        printf("sai_thrift_remove_all_neighbor_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_neighbor_api_t *neighbor_api;
        sai_neighbor_entry_t neighbor_entry;
        status = sai_api_query(SAI_API_NEIGHBOR, (void **) &neighbor_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = neighbor_api->remove_all_neighbor_entries(gSwitchId);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove all neighbor entry, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, 
                                                                const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_neighbor_entry_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        sai_neighbor_api_t *neighbor_api;
        sai_neighbor_entry_t neighbor_entry;
        sai_attribute_t *attr_list = nullptr;
        
        status = sai_api_query(SAI_API_NEIGHBOR, (void **) &neighbor_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_alloc_attr(attr_list, 1);
        sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
        sai_thrift_parse_neighbor_attributes(thrift_attr_list, attr_list);
        status = neighbor_api->set_neighbor_entry_attribute(&neighbor_entry, attr_list);
        sai_thrift_free_attr(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set neighbor attributes, status:%d", status);
        }
        return status;
    }

    void sai_thrift_get_neighbor_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                 const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
    {
        printf("sai_thrift_get_neighbor_entry_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_neighbor_api_t *neighbor_api;
        sai_neighbor_entry_t neighbor_entry;
        sai_attribute_t attr[SAI_NEIGHBOR_ENTRY_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint32_t attr_cnt = 0;
    
        status = sai_api_query(SAI_API_NEIGHBOR, (void **) &neighbor_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            thrift_attr_list.status = status;
            return;
        }
    
        sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
    
        attr[attr_cnt++].id = SAI_NEIGHBOR_ENTRY_ATTR_DST_MAC_ADDRESS;
        attr[attr_cnt++].id = SAI_NEIGHBOR_ENTRY_ATTR_PACKET_ACTION;
        attr[attr_cnt++].id = SAI_NEIGHBOR_ENTRY_ATTR_NO_HOST_ROUTE;
    
        status = neighbor_api->get_neighbor_entry_attribute(&neighbor_entry, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get neighbor attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        thrift_attr.id        = attr[0].id;
        thrift_attr.value.mac = sai_thrift_mac_to_string(attr[0].value.mac);
        thrift_attr.value.__isset.mac = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[1].id;
        thrift_attr.value.__set_s32(attr[1].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[2].id;
        thrift_attr.value.__set_booldata(attr[2].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
    }

    sai_thrift_object_id_t sai_thrift_get_cpu_port_id()
    {
        sai_status_t status;
        sai_attribute_t attr;
        sai_switch_api_t *switch_api;
        sai_thrift_object_id_t cpu_port_id;
        const char* f_name = __FUNCTION__;
        printf("%s\n", f_name);
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("%s failed to obtain switch_api, status:%d\n", f_name, status);
            return SAI_NULL_OBJECT_ID;
        }
        attr.id = SAI_SWITCH_ATTR_CPU_PORT;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("%s failed, status:%d\n", f_name, status);
            return SAI_NULL_OBJECT_ID;
        }
        cpu_port_id = (sai_thrift_object_id_t) attr.value.oid;
        return cpu_port_id;
    }

    sai_thrift_object_id_t sai_thrift_get_default_router_id()
    {
        sai_status_t status;
        sai_attribute_t attr;
        sai_switch_api_t *switch_api;
        sai_thrift_object_id_t default_router_id;
        const char* f_name = __FUNCTION__;
        printf("%s\n", f_name);
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("%s failed to obtain switch_api, status:%d\n", f_name, status);
            return SAI_NULL_OBJECT_ID;
        }
        attr.id = SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("%s. Failed to get switch virtual router ID, status %d", f_name, status);
            return SAI_NULL_OBJECT_ID;
        }
        default_router_id = (sai_thrift_object_id_t)attr.value.oid;
        return default_router_id;
    }
    
    sai_thrift_object_id_t sai_thrift_get_default_1q_bridge_id()
    {
        sai_switch_api_t *switch_api;
        sai_attribute_t attr;
        sai_status_t status;
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain switch_api, status:%d\n", status);
            return SAI_NULL_OBJECT_ID;
        }
    
        attr.id = SAI_SWITCH_ATTR_DEFAULT_1Q_BRIDGE_ID;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get switch virtual router ID, status %d", status);
            return SAI_NULL_OBJECT_ID;
        }
    
        return (sai_thrift_object_id_t)attr.value.oid;
    }
    
    void sai_thrift_get_default_vlan_id(sai_thrift_result_t &ret)
    {
        sai_switch_api_t *switch_api;
        sai_attribute_t attr;
    
        SAI_THRIFT_FUNC_LOG();
    
        ret.__isset.status = true;
        ret.status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain switch_api, status:%d", ret.status);
            return;
        }
    
        attr.id = SAI_SWITCH_ATTR_DEFAULT_VLAN_ID;
        ret.status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get switch default vlan ID, status:%d", ret.status);
            return;
        }
    
        ret.data.__set_oid((sai_thrift_object_id_t)attr.value.oid);
    }
    
    sai_thrift_object_id_t sai_thrift_get_default_trap_group()
    {
        sai_status_t status;
        sai_attribute_t attr;
        sai_switch_api_t *switch_api;
        sai_thrift_object_id_t default_trap_group;
        const char* f_name = __FUNCTION__;
        printf("%s\n", f_name);
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("%s failed to obtain switch_api, status:%d\n", f_name, status);
            return SAI_NULL_OBJECT_ID;
        }
        attr.id = SAI_SWITCH_ATTR_DEFAULT_TRAP_GROUP;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("%s. Failed to get switch default trap group, status %d", f_name, status);
            return SAI_NULL_OBJECT_ID;
        }
        default_trap_group = (sai_thrift_object_id_t)attr.value.oid;
        return default_trap_group;
    }
    
    sai_thrift_object_id_t sai_thrift_create_switch(void)
    {
        printf("sai_thrift_create_switch\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *sai_switch_api;
        constexpr std::uint32_t attrSz = 1;
        sai_attribute_t attr[attrSz];
    
        extern void handleProfileMap(const std::string& profileMapFile);
        //handleProfileMap("profile.ini");
    
        handleProfileMap(gPortMapFile);
    
        status = sai_api_query(SAI_API_SWITCH, (void **) &sai_switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return SAI_NULL_OBJECT_ID;
        }
    
        std :: memset(attr, '\0', sizeof(attr));
        attr[0].id = SAI_SWITCH_ATTR_INIT_SWITCH;
        attr[0].value.booldata = true;
    
        sai_switch_api->create_switch(&gSwitchId, attrSz, attr);
    
        return gSwitchId;
    }
    
    sai_thrift_status_t sai_thrift_remove_switch(void)
    {
        printf("sai_thrift_remove_switch\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *sai_switch_api;
    
        status = sai_api_query(SAI_API_SWITCH, (void **) &sai_switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        status = sai_switch_api->remove_switch((sai_object_id_t)gSwitchId);
        return status;
    }

    void sai_thrift_get_switch_stats(std::vector<int64_t> & thrift_counters,
                                     const std::vector<sai_thrift_port_stat_counter_t> & thrift_counter_ids,
                                     const int32_t number_of_counters)
    {
        printf("sai_thrift_get_switch_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *switch_api;
    
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
    
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_switch_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_switch_stat_t) *it;
        }
    
        status = switch_api->get_switch_stats((sai_object_id_t) gSwitchId,
                                          number_of_counters,
                                          counter_ids,
                                          counters);
    
        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }
    
        free(counter_ids);
        free(counters);
    
        return;
    }

    void sai_thrift_get_switch_stats_ext(std::vector<int64_t> & thrift_counters,
                                         const std::vector<sai_thrift_port_stat_counter_t> & thrift_counter_ids,
                                         const int8_t mode,
                                         const int32_t number_of_counters)
    {
        printf("sai_thrift_get_switch_stats_ext\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *switch_api;

        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_switch_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_port_stat_t) *it;
        }

        status = switch_api->get_switch_stats_ext((sai_object_id_t) gSwitchId,
                                          number_of_counters,
                                          counter_ids,
                                          (sai_stats_mode_t)mode,
                                          counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }

        free(counter_ids);
        free(counters);

        return;
    }

    sai_thrift_status_t sai_thrift_clear_switch_stats(const std::vector<sai_thrift_stat_id_t> &thrift_counter_ids,
                                                      int32_t number_of_counters)
    {
        printf("sai_thrift_clear_switch_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *switch_api;
        
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_switch_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
	    memset(counter_ids, 0, sizeof(sai_switch_stat_t) * thrift_counter_ids.size());
	    memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());
        
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
        	counter_ids[i] = (sai_counter_stat_t) *it;
	    }
        
        status = switch_api->clear_switch_stats((sai_object_id_t)gSwitchId,
                                          number_of_counters,
                                          counter_ids);
        
        free(counter_ids);
        free(counters);
        
        return status;
    }

    void sai_thrift_convert_to_port_thrift_attributes(sai_attribute_t *attr_list,
                                                      uint32_t attr_count,
                                                      sai_thrift_attribute_list_t& thrift_attr_list)
    {
    
        sai_attribute_t attribute;
        sai_thrift_attribute_t thrift_attr;
        thrift_attr_list.attr_count= thrift_attr_list.attr_count+attr_count;
    
        for (uint32_t i = 0; i < attr_count; i++)
        {
            attribute = attr_list[i];
            switch (attribute.id)
            {
                /*sai_bridge_port_type_t*/
                case SAI_BRIDGE_PORT_ATTR_TYPE:
                case SAI_BRIDGE_PORT_ATTR_TAGGING_MODE:
                case SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE:
                case SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_LIMIT_VIOLATION_PACKET_ACTION:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_s32 (attribute.value.s32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
    
                /*sai_object_id_t*/
                case SAI_BRIDGE_PORT_ATTR_PORT_ID:
                case SAI_BRIDGE_PORT_ATTR_RIF_ID:
                case SAI_BRIDGE_PORT_ATTR_TUNNEL_ID:
                case SAI_BRIDGE_PORT_ATTR_BRIDGE_ID:
                case SAI_BRIDGE_PORT_ATTR_ISOLATION_GROUP:
                case SAI_BRIDGE_PORT_ATTR_CROSS_CONNECT_BRIDGE_PORT:
                case SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_POLICER_ID:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_oid (attribute.value.oid);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /*sai_uint32_t*/
                case SAI_BRIDGE_PORT_ATTR_MAX_LEARNED_ADDRESSES:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_u32 (attribute.value.u32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /* sai_uint16_t*/
                case SAI_BRIDGE_PORT_ATTR_VLAN_ID:
                case SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_SERVICE_ID:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_u16(attribute.value.u16);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
                /* bool */
                case SAI_BRIDGE_PORT_ATTR_ADMIN_STATE:
                case SAI_BRIDGE_PORT_ATTR_INGRESS_FILTERING:
                case SAI_BRIDGE_PORT_ATTR_EGRESS_FILTERING:
                case SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_OAM_ENABLE:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_booldata(attribute.value.booldata);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
            }
       }
    
    }

    void sai_thrift_convert_to_switch_thrift_attributes(sai_attribute_t *attr_list,
                                                        uint32_t attr_count,
                                                        sai_thrift_attribute_list_t& thrift_attr_list)
    {
        sai_attribute_t attribute;
        sai_thrift_attribute_t thrift_attr;
        thrift_attr_list.attr_count=attr_count;
    
        for (uint32_t i = 0; i < attr_count; i++)
        {
            attribute = attr_list[i];
            switch (attribute.id)
            {
                /* sai_uint32_t */
                case SAI_SWITCH_ATTR_NUMBER_OF_ACTIVE_PORTS:
                case SAI_SWITCH_ATTR_MAX_NUMBER_OF_SUPPORTED_PORTS:
                case SAI_SWITCH_ATTR_PORT_MAX_MTU:
                case SAI_SWITCH_ATTR_MAX_VIRTUAL_ROUTERS:
                case SAI_SWITCH_ATTR_FDB_TABLE_SIZE:
                case SAI_SWITCH_ATTR_L3_NEIGHBOR_TABLE_SIZE:
                case SAI_SWITCH_ATTR_L3_ROUTE_TABLE_SIZE:
                case SAI_SWITCH_ATTR_LAG_MEMBERS:
                case SAI_SWITCH_ATTR_NUMBER_OF_LAGS:
                case SAI_SWITCH_ATTR_ECMP_MEMBERS:
                case SAI_SWITCH_ATTR_NUMBER_OF_ECMP_GROUPS:
                case SAI_SWITCH_ATTR_NUMBER_OF_UNICAST_QUEUES:
                case SAI_SWITCH_ATTR_NUMBER_OF_MULTICAST_QUEUES:
                case SAI_SWITCH_ATTR_NUMBER_OF_QUEUES:
                case SAI_SWITCH_ATTR_NUMBER_OF_CPU_QUEUES:
                case SAI_SWITCH_ATTR_ACL_TABLE_MINIMUM_PRIORITY:
                case SAI_SWITCH_ATTR_ACL_TABLE_MAXIMUM_PRIORITY:
                case SAI_SWITCH_ATTR_ACL_ENTRY_MINIMUM_PRIORITY:
                case SAI_SWITCH_ATTR_ACL_ENTRY_MAXIMUM_PRIORITY:
                case SAI_SWITCH_ATTR_ACL_TABLE_GROUP_MINIMUM_PRIORITY:
                case SAI_SWITCH_ATTR_ACL_TABLE_GROUP_MAXIMUM_PRIORITY:
                case SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_SCHEDULER_GROUP_HIERARCHY_LEVELS:
                case SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_CHILDS_PER_SCHEDULER_GROUP:
                case SAI_SWITCH_ATTR_INGRESS_BUFFER_POOL_NUM:
                case SAI_SWITCH_ATTR_EGRESS_BUFFER_POOL_NUM:
                case SAI_SWITCH_ATTR_AVAILABLE_IPV4_ROUTE_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_IPV6_ROUTE_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_IPV4_NEXTHOP_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_IPV6_NEXTHOP_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_IPV4_NEIGHBOR_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_IPV6_NEIGHBOR_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_NEXT_HOP_GROUP_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_NEXT_HOP_GROUP_MEMBER_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_FDB_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_L2MC_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_IPMC_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_SNAT_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_DNAT_ENTRY:
                case SAI_SWITCH_ATTR_AVAILABLE_DOUBLE_NAT_ENTRY:
                case SAI_SWITCH_ATTR_MIN_PLANNED_RESTART_INTERVAL:
                case SAI_SWITCH_ATTR_MAX_ACL_ACTION_COUNT:
                case SAI_SWITCH_ATTR_MAX_ACL_RANGE_COUNT:
                case SAI_SWITCH_ATTR_MAX_LEARNED_ADDRESSES:
                case SAI_SWITCH_ATTR_FDB_AGING_TIME:
                case SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_SEED:
                case SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_SEED:
                case SAI_SWITCH_ATTR_COUNTER_REFRESH_INTERVAL:
                case SAI_SWITCH_ATTR_SWITCH_PROFILE_ID:
                case SAI_SWITCH_ATTR_SEGMENTROUTE_MAX_SID_DEPTH:
                case SAI_SWITCH_ATTR_QOS_NUM_LOSSLESS_QUEUES:
                case SAI_SWITCH_ATTR_MAX_STP_INSTANCE:
                case SAI_SWITCH_ATTR_MAX_TWAMP_SESSION:
                case SAI_SWITCH_ATTR_NUMBER_OF_BFD_SESSION:
                case SAI_SWITCH_ATTR_MAX_BFD_SESSION:
                case SAI_SWITCH_ATTR_MIN_BFD_TX:
                case SAI_SWITCH_ATTR_MIN_BFD_RX:
                case SAI_SWITCH_ATTR_NUMBER_OF_Y1731_SESSION:
                case SAI_SWITCH_ATTR_MAX_Y1731_SESSION:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_u32 (attribute.value.u32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
               /* sai_int32_t */
                case SAI_SWITCH_ATTR_MAX_TEMP:
                case SAI_SWITCH_ATTR_OPER_STATUS:
                case SAI_SWITCH_ATTR_RESTART_TYPE:
                case SAI_SWITCH_ATTR_MCAST_SNOOPING_CAPABILITY:
                case SAI_SWITCH_ATTR_SWITCHING_MODE:
                case SAI_SWITCH_ATTR_FDB_UNICAST_MISS_PACKET_ACTION:
                case SAI_SWITCH_ATTR_FDB_BROADCAST_MISS_PACKET_ACTION:
                case SAI_SWITCH_ATTR_FDB_MULTICAST_MISS_PACKET_ACTION:
                case SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_ALGORITHM:
                case SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_ALGORITHM:
                case SAI_SWITCH_ATTR_PFC_DLR_PACKET_ACTION:
                case SAI_SWITCH_ATTR_AVERAGE_TEMP:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_s32 (attribute.value.s32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /* sai_uint16_t */
                case SAI_SWITCH_ATTR_TPID_OUTER_VLAN:
                case SAI_SWITCH_ATTR_TPID_INNER_VLAN:
                case SAI_SWITCH_ATTR_VXLAN_DEFAULT_PORT:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_u16(attribute.value.u16);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                 /* sai_mac_t */
                case SAI_SWITCH_ATTR_SRC_MAC_ADDRESS:
                case SAI_SWITCH_ATTR_VXLAN_DEFAULT_ROUTER_MAC:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.mac = sai_thrift_mac_to_string(attribute.value.mac);
                    thrift_attr.value.__isset.mac = true;
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /* sai_uint8_t */
                case SAI_SWITCH_ATTR_MAX_NUMBER_OF_TEMP_SENSORS:
                case SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_TRAFFIC_CLASSES:
                case SAI_SWITCH_ATTR_QOS_DEFAULT_TC:
                case SAI_SWITCH_ATTR_MIRROR_TC:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_u8 (attribute.value.u8);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /* sai_object_id_t */
                case SAI_SWITCH_ATTR_CPU_PORT:
                case SAI_SWITCH_ATTR_DEFAULT_VLAN_ID:
                case SAI_SWITCH_ATTR_DEFAULT_STP_INST_ID:
                case SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID:
                case SAI_SWITCH_ATTR_DEFAULT_1Q_BRIDGE_ID:
                case SAI_SWITCH_ATTR_INGRESS_ACL:
                case SAI_SWITCH_ATTR_EGRESS_ACL:
                case SAI_SWITCH_ATTR_DEFAULT_TRAP_GROUP:
                case SAI_SWITCH_ATTR_ECMP_HASH:
                case SAI_SWITCH_ATTR_LAG_HASH:
                case SAI_SWITCH_ATTR_ECMP_HASH_IPV4:
                case SAI_SWITCH_ATTR_ECMP_HASH_IPV4_IN_IPV4:
                case SAI_SWITCH_ATTR_ECMP_HASH_IPV6:
                case SAI_SWITCH_ATTR_LAG_HASH_IPV4:
                case SAI_SWITCH_ATTR_LAG_HASH_IPV4_IN_IPV4:
                case SAI_SWITCH_ATTR_LAG_HASH_IPV6:
                case SAI_SWITCH_ATTR_QOS_DOT1P_TO_TC_MAP:
                case SAI_SWITCH_ATTR_QOS_DOT1P_TO_COLOR_MAP:
                case SAI_SWITCH_ATTR_QOS_DSCP_TO_TC_MAP:
                case SAI_SWITCH_ATTR_QOS_DSCP_TO_COLOR_MAP:
                case SAI_SWITCH_ATTR_QOS_TC_TO_QUEUE_MAP:
                case SAI_SWITCH_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP:
                case SAI_SWITCH_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP:
                case SAI_SWITCH_ATTR_NAT_ZONE_COUNTER_OBJECT_ID:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_oid (attribute.value.oid);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /* sai_uint64_t */
                case SAI_SWITCH_ATTR_TOTAL_BUFFER_SIZE:
                case SAI_SWITCH_ATTR_NV_STORAGE_SIZE:
                    thrift_attr.id        = attribute.id;
    
                    thrift_attr.value.__set_u64 (attribute.value.u64);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /* bool */
                case SAI_SWITCH_ATTR_ON_LINK_ROUTE_SUPPORTED:
                case SAI_SWITCH_ATTR_RESTART_WARM:
                case SAI_SWITCH_ATTR_WARM_RECOVER:
                case SAI_SWITCH_ATTR_BCAST_CPU_FLOOD_ENABLE:
                case SAI_SWITCH_ATTR_MCAST_CPU_FLOOD_ENABLE:
                case SAI_SWITCH_ATTR_ECMP_DEFAULT_SYMMETRIC_HASH:
                case SAI_SWITCH_ATTR_LAG_DEFAULT_SYMMETRIC_HASH:
                case SAI_SWITCH_ATTR_SWITCH_SHELL_ENABLE:
                case SAI_SWITCH_ATTR_INIT_SWITCH:
                case SAI_SWITCH_ATTR_FAST_API_ENABLE:
                case SAI_SWITCH_ATTR_UNINIT_DATA_PLANE_ON_REMOVAL:
                case SAI_SWITCH_ATTR_PRE_SHUTDOWN:
                case SAI_SWITCH_ATTR_NAT_ENABLE:
                case SAI_SWITCH_ATTR_CRC_CHECK_ENABLE:
                case SAI_SWITCH_ATTR_CRC_RECALCULATION_ENABLE:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.__set_booldata (attribute.value.booldata);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /* sai_u32_range_t */
                case SAI_SWITCH_ATTR_FDB_DST_USER_META_DATA_RANGE:
                case SAI_SWITCH_ATTR_ROUTE_DST_USER_META_DATA_RANGE:
                case SAI_SWITCH_ATTR_NEIGHBOR_DST_USER_META_DATA_RANGE:
                case SAI_SWITCH_ATTR_PORT_USER_META_DATA_RANGE:
                case SAI_SWITCH_ATTR_VLAN_USER_META_DATA_RANGE:
                case SAI_SWITCH_ATTR_ACL_USER_META_DATA_RANGE:
                case SAI_SWITCH_ATTR_ACL_USER_TRAP_ID_RANGE:
                case SAI_SWITCH_ATTR_PFC_TC_DLD_INTERVAL_RANGE:
                case SAI_SWITCH_ATTR_PFC_TC_DLR_INTERVAL_RANGE:
                    thrift_attr.id        = attribute.id;
                    thrift_attr.value.u32range.min = attribute.value.u32range.min;
                    thrift_attr.value.u32range.max = attribute.value.u32range.max;
                    thrift_attr.value.__isset.u32range=true;
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
    
                /* sai_object_list_t */
                case SAI_SWITCH_ATTR_PORT_LIST:
                    {
                        thrift_attr.id        = attribute.id;
                        thrift_attr.value.objlist.count = attribute.value.objlist.count;
                        std::vector < sai_thrift_object_id_t > & port_list = thrift_attr.value.objlist.object_id_list;
                        for (int index = 0; index < attribute.value.objlist.count; index++)
                        {
                            port_list.push_back((sai_thrift_object_id_t)attribute.value.objlist.list[index]);
                        }
                        thrift_attr.value.__isset.objlist=true;
                        thrift_attr_list.attr_list.push_back(thrift_attr);
                        break;
                    }
    
                /* sai_u32_list_t */
                case SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_SCHEDULER_GROUPS_PER_HIERARCHY_LEVEL:
                    {
                        thrift_attr.id        = attribute.id;
                        thrift_attr.value.u32list.count = attribute.value.u32list.count;
    
                        std :: vector < sai_int32_t > & qos_member_list = thrift_attr.value.u32list.u32list;
                        for (int index = 0; index < attribute.value.u32list.count; index++)
                        {
                            qos_member_list.push_back((sai_int32_t)attribute.value.u32list.list[index]);
                        }
                        thrift_attr.value.__isset.u32list=true;
                        thrift_attr_list.attr_list.push_back(thrift_attr);
                        break;
                    }
    
                /* sai_s32_list_t */
                case SAI_SWITCH_ATTR_TEMP_LIST:
                case SAI_SWITCH_ATTR_SEGMENTROUTE_TLV_TYPE:
                case SAI_SWITCH_ATTR_SUPPORTED_PROTECTED_OBJECT_TYPE:
                case SAI_SWITCH_ATTR_SUPPORTED_IPV4_BFD_SESSION_OFFLOAD_TYPE:
                case SAI_SWITCH_ATTR_SUPPORTED_IPV6_BFD_SESSION_OFFLOAD_TYPE:
                case SAI_SWITCH_ATTR_SUPPORTED_Y1731_SESSION_PERFORMANCE_MONITOR_OFFLOAD_TYPE:
                case SAI_SWITCH_ATTR_SUPPORTED_EXTENDED_STATS_MODE:
                    {
                        thrift_attr.id        = attribute.id;
                        thrift_attr.value.s32list.count = attribute.value.s32list.count;
                        thrift_attr.value.__isset.s32list=true;
                        std::vector < sai_int32_t > & s32_data_list = thrift_attr.value.s32list.s32list;
                        for (int index = 0; index < attribute.value.s32list.count; index++)
                        {
                            s32_data_list.push_back((sai_int32_t)attribute.value.s32list.list[index]);
                        }
                        thrift_attr_list.attr_list.push_back(thrift_attr);
                        break;
                    }
    
                /* sai_s8_list_t */
                case SAI_SWITCH_ATTR_SWITCH_HARDWARE_INFO:
                case SAI_SWITCH_ATTR_FIRMWARE_PATH_NAME:
                    {
                        thrift_attr.id        = attribute.id;
                        thrift_attr.value.s8list.count = attribute.value.s8list.count;
                        thrift_attr.value.__isset.s8list=true;
                        std::vector < sai_int8_t > & s8_data_list = thrift_attr.value.s8list.s8list;
                        for (int index = 0; index < attribute.value.s8list.count; index++)
                        {
                            s8_data_list.push_back((sai_int8_t)attribute.value.s8list.list[index]);
                        }
                        thrift_attr_list.attr_list.push_back(thrift_attr);
                        break;
                    }
    
                /* sai_map_list_t (TBD)*/
                case SAI_SWITCH_ATTR_PFC_TC_DLD_INTERVAL:
                case SAI_SWITCH_ATTR_PFC_TC_DLR_INTERVAL:
                    break;
    
                /* sai_acl_resource_list_t (TBD)*/
                case SAI_SWITCH_ATTR_AVAILABLE_ACL_TABLE:
                case SAI_SWITCH_ATTR_AVAILABLE_ACL_TABLE_GROUP:
                    break;
    
                /* sai_acl_capability_t (TBD)*/
                case SAI_SWITCH_ATTR_ACL_CAPABILITY:
                case SAI_SWITCH_ATTR_ACL_STAGE_INGRESS:
                case SAI_SWITCH_ATTR_ACL_STAGE_EGRESS:
                    break;
    
                /* sai_pointer_t  (no need to process)  */
                case SAI_SWITCH_ATTR_SWITCH_STATE_CHANGE_NOTIFY:
                case SAI_SWITCH_ATTR_SWITCH_SHUTDOWN_REQUEST_NOTIFY:
                case SAI_SWITCH_ATTR_FDB_EVENT_NOTIFY:
                case SAI_SWITCH_ATTR_PORT_STATE_CHANGE_NOTIFY:
                case SAI_SWITCH_ATTR_PACKET_EVENT_NOTIFY:
                case SAI_SWITCH_ATTR_TAM_EVENT_NOTIFY:
                case SAI_SWITCH_ATTR_QUEUE_PFC_DEADLOCK_NOTIFY:
                case SAI_SWITCH_ATTR_BFD_SESSION_STATE_CHANGE_NOTIFY:
                case SAI_SWITCH_ATTR_Y1731_SESSION_EVENT_NOTIFY:
                    break;
            }
        }
        return;
    }


    void sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const std::vector < int32_t > & thrift_attr_ids)
	{
        printf("sai_thrift_get_switch_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *switch_api;
		sai_attribute_t sai_attribute;
		memset(&sai_attribute, 0, sizeof(sai_attribute_t));

        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("sai_api_query failed!!!\n");
            return;
        }

        uint32_t attr_count = thrift_attr_ids.size();
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_ids.size());
        memset(attr_list, 0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));

        sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);

        for (uint32_t i = 0; i < attr_count; i++)
        {
            switch(attr_list[i].id)
            {
            case SAI_SWITCH_ATTR_PORT_LIST:
                attr_list[i].value.objlist.count = 256;
                attr_list[i].value.objlist.list = (uint64_t *) malloc(sizeof(uint64_t) * 256);
                break;
            case SAI_SWITCH_ATTR_TEMP_LIST:
                attr_list[i].value.s32list.count = 10;
                attr_list[i].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * 10);
                break;
            case SAI_SWITCH_ATTR_SUPPORTED_EXTENDED_STATS_MODE:
                attr_list[i].value.s32list.count = 2;
                attr_list[i].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * 2);
                break;
            case SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_SCHEDULER_GROUPS_PER_HIERARCHY_LEVEL:
                attr_list[i].value.u32list.count = 10;
                attr_list[i].value.u32list.list = (uint32_t *) malloc(sizeof(uint32_t) * 10);
                break;
            case SAI_SWITCH_ATTR_SWITCH_HARDWARE_INFO:
                attr_list[i].value.s8list.count = 10;
                attr_list[i].value.s8list.list = (int8_t *) malloc(sizeof(int8_t) * 10);
                break;
            case SAI_SWITCH_ATTR_FIRMWARE_PATH_NAME:
                attr_list[i].value.s8list.count = 10;
                attr_list[i].value.s8list.list = (int8_t *) malloc(sizeof(int8_t) * 10);
                break;
            case SAI_SWITCH_ATTR_SEGMENTROUTE_TLV_TYPE:
                attr_list[i].value.s32list.count = 10;
                attr_list[i].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * 10);
                break;
            case SAI_SWITCH_ATTR_SUPPORTED_PROTECTED_OBJECT_TYPE:
                attr_list[i].value.s32list.count = 10;
                attr_list[i].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * 10);
                break;
            case SAI_SWITCH_ATTR_SUPPORTED_IPV4_BFD_SESSION_OFFLOAD_TYPE:
                attr_list[i].value.s32list.count = 10;
                attr_list[i].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * 10);
                memset(attr_list[i].value.s32list.list, 0, sizeof(sizeof(int32_t) * 10));
                break;
            case SAI_SWITCH_ATTR_SUPPORTED_IPV6_BFD_SESSION_OFFLOAD_TYPE:
                attr_list[i].value.s32list.count = 10;
                attr_list[i].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * 10);
                memset(attr_list[i].value.s32list.list, 0, sizeof(sizeof(int32_t) * 10));
                break;
             case SAI_SWITCH_ATTR_SUPPORTED_Y1731_SESSION_PERFORMANCE_MONITOR_OFFLOAD_TYPE:
                attr_list[i].value.s32list.count = 10;
                attr_list[i].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * 10);
                break;
            default:
                break;
            }
        }

	    status = switch_api->get_switch_attribute(gSwitchId, attr_count, attr_list);
	    if (status != SAI_STATUS_SUCCESS)
	    {
            SAI_THRIFT_LOG_ERR("Failed to get switch attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
	    sai_thrift_convert_to_switch_thrift_attributes(attr_list, attr_count, thrift_attr_list);
        
	    for (uint32_t i = 0; i < attr_count; i++)
        {
            if ((SAI_SWITCH_ATTR_PORT_LIST == attr_list[i].id) && (attr_list[i].value.objlist.list))
            {
                free(attr_list[i].value.objlist.list);
            }
            if ((SAI_SWITCH_ATTR_TEMP_LIST == attr_list[i].id) && (attr_list[i].value.s32list.list))
            {
                free(attr_list[i].value.s32list.list);
            }
            if ((SAI_SWITCH_ATTR_SUPPORTED_EXTENDED_STATS_MODE == attr_list[i].id) && (attr_list[i].value.s32list.list))
            {
                free(attr_list[i].value.s32list.list);
            }
            if ((SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_SCHEDULER_GROUPS_PER_HIERARCHY_LEVEL == attr_list[i].id) && (attr_list[i].value.u32list.list))
            {
                free(attr_list[i].value.u32list.list);
            }
            if ((SAI_SWITCH_ATTR_SWITCH_HARDWARE_INFO == attr_list[i].id) && (attr_list[i].value.s8list.list))
            {
                free(attr_list[i].value.s8list.list);
            }
            if ((SAI_SWITCH_ATTR_FIRMWARE_PATH_NAME == attr_list[i].id) && (attr_list[i].value.s8list.list))
            {
                free(attr_list[i].value.s8list.list);
            }
            if ((SAI_SWITCH_ATTR_SEGMENTROUTE_TLV_TYPE == attr_list[i].id) && (attr_list[i].value.s32list.list))
            {
                free(attr_list[i].value.s32list.list);
            }
            if ((SAI_SWITCH_ATTR_SUPPORTED_PROTECTED_OBJECT_TYPE == attr_list[i].id) && (attr_list[i].value.s32list.list))
            {
                free(attr_list[i].value.s32list.list);
            }
            if ((SAI_SWITCH_ATTR_SUPPORTED_IPV4_BFD_SESSION_OFFLOAD_TYPE == attr_list[i].id) && (attr_list[i].value.s32list.list))
            {
                free(attr_list[i].value.s32list.list);
            }
            if ((SAI_SWITCH_ATTR_SUPPORTED_IPV6_BFD_SESSION_OFFLOAD_TYPE == attr_list[i].id) && (attr_list[i].value.s32list.list))
            {
                free(attr_list[i].value.s32list.list);
            }
            if ((SAI_SWITCH_ATTR_SUPPORTED_Y1731_SESSION_PERFORMANCE_MONITOR_OFFLOAD_TYPE == attr_list[i].id) && (attr_list[i].value.s32list.list))
            {
                free(attr_list[i].value.s32list.list);
            }
        }
        
 	    if(attr_list)
 	    {
 	        free(attr_list);
 	    }
        
	    return;
	}

    sai_thrift_status_t sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_switch_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *switch_api;
        sai_attribute_t attr;
        memset(&attr, 0, sizeof(sai_attribute_t));
    
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("sai_api_query failed!!!\n");
            return status;
        }
    
        sai_thrift_parse_switch_attribute(thrift_attr, &attr);
    
        status = switch_api->set_switch_attribute(gSwitchId, &attr);
    
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set switch attributes, status:%d", status);
        }
        return status;
    }

    void sai_thrift_parse_switch_attribute(const sai_thrift_attribute_t &thrift_attr, sai_attribute_t *attr)
    {
        attr->id = thrift_attr.id;
    
        switch(thrift_attr.id)
        {
            case SAI_SWITCH_ATTR_SRC_MAC_ADDRESS:
            case SAI_SWITCH_ATTR_VXLAN_DEFAULT_ROUTER_MAC:
                sai_thrift_string_to_mac(thrift_attr.value.mac, attr->value.mac);
                break;
    
            case SAI_SWITCH_ATTR_FDB_UNICAST_MISS_PACKET_ACTION:
            case SAI_SWITCH_ATTR_FDB_BROADCAST_MISS_PACKET_ACTION:
            case SAI_SWITCH_ATTR_FDB_MULTICAST_MISS_PACKET_ACTION:
            case SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_ALGORITHM:
            case SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_ALGORITHM:
                attr->value.s32 = thrift_attr.value.s32;
                break;
            case SAI_SWITCH_ATTR_FDB_AGING_TIME:
            case SAI_SWITCH_ATTR_MAX_LEARNED_ADDRESSES:
            case SAI_SWITCH_ATTR_MAX_TWAMP_SESSION:
                attr->value.u32 = thrift_attr.value.u32;
                break;
            case SAI_SWITCH_ATTR_QOS_DEFAULT_TC:
                attr->value.u8 = thrift_attr.value.u8;
                break;
            case SAI_SWITCH_ATTR_QOS_TC_TO_QUEUE_MAP:
            case SAI_SWITCH_ATTR_QOS_DOT1P_TO_TC_MAP:
            case SAI_SWITCH_ATTR_QOS_DOT1P_TO_COLOR_MAP:
            case SAI_SWITCH_ATTR_QOS_DSCP_TO_TC_MAP:
            case SAI_SWITCH_ATTR_QOS_DSCP_TO_COLOR_MAP:
            case SAI_SWITCH_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP:
            case SAI_SWITCH_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP:
            case SAI_SWITCH_ATTR_INGRESS_ACL:
                attr->value.oid = thrift_attr.value.oid;
                break;
            case SAI_SWITCH_ATTR_RESTART_WARM:
            case SAI_SWITCH_ATTR_UNINIT_DATA_PLANE_ON_REMOVAL:
            case SAI_SWITCH_ATTR_ECMP_DEFAULT_SYMMETRIC_HASH:
            case SAI_SWITCH_ATTR_LAG_DEFAULT_SYMMETRIC_HASH:
            case SAI_SWITCH_ATTR_SWITCH_SHELL_ENABLE:
            case SAI_SWITCH_ATTR_PRE_SHUTDOWN:
            case SAI_SWITCH_ATTR_CRC_CHECK_ENABLE:
            case SAI_SWITCH_ATTR_CRC_RECALCULATION_ENABLE:
                attr->value.booldata = thrift_attr.value.booldata;
                break;
            case SAI_SWITCH_ATTR_VXLAN_DEFAULT_PORT:
            case SAI_SWITCH_ATTR_TPID_OUTER_VLAN:
            case SAI_SWITCH_ATTR_TPID_INNER_VLAN:
                attr->value.u16 = thrift_attr.value.u16;
                break;
        }
    }

    void sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_get_port_list_by_front_port\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *switch_api;
        sai_port_api_t *port_api;
        sai_attribute_t max_port_attribute;
        sai_attribute_t port_list_object_attribute;
        sai_attribute_t port_lane_list_attribute;
        sai_thrift_attribute_t thrift_port_list_attribute;
        sai_object_list_t *port_list_object;
        int max_ports = 0;
        extern std::map<std::set<int>, std::string> gPortMap;
        std::map<std::set<int>, std::string>::iterator gPortMapIt;
    
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("sai_api_query failed!!!\n");
            return;
        }
    
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("sai_api_query failed!!!\n");
            return;
        }
    
        max_port_attribute.id = SAI_SWITCH_ATTR_PORT_NUMBER;
        switch_api->get_switch_attribute(gSwitchId, 1, &max_port_attribute);
        max_ports = max_port_attribute.value.u32;
        port_list_object_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
        port_list_object_attribute.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * max_ports);
        port_list_object_attribute.value.objlist.count = max_ports;
        switch_api->get_switch_attribute(gSwitchId, 1, &port_list_object_attribute);
        std::map<int, sai_object_id_t> front_to_sai_map;
    
        for (int i=0 ; i<max_ports ; i++)
        {
            port_lane_list_attribute.id = SAI_PORT_ATTR_HW_LANE_LIST;
            port_lane_list_attribute.value.u32list.list = (uint32_t *) malloc(sizeof(uint32_t) * 4);
            port_lane_list_attribute.value.u32list.count = 4;
            port_api->get_port_attribute(port_list_object_attribute.value.objlist.list[i], 1, &port_lane_list_attribute);
    
            std::set<int> port_lanes;
            uint32_t laneCnt = port_lane_list_attribute.value.u32list.count;
            for (int j=0 ; j<laneCnt; j++)
            {
                port_lanes.insert(port_lane_list_attribute.value.u32list.list[j]);
            }
    
            gPortMapIt = gPortMap.find(port_lanes);
            if (gPortMapIt != gPortMap.end())
            {
                std::string front_port_alias = gPortMapIt->second.c_str();
                std::string front_port_number;
                int front_num_to_sort=0;
                for (int k=0 ; k<front_port_alias.length() ; k++)
                {
                    if (front_port_alias[k] >= '0' && front_port_alias[k] <= '9')
                    {
                        front_port_number.push_back(front_port_alias[k]);
                    }
                }
                front_num_to_sort = std::stoi(front_port_number);
                front_to_sai_map.insert(std::pair<int,sai_object_id_t>(front_num_to_sort,port_list_object_attribute.value.objlist.list[i]));
            }
            else
            {
                printf("DIDN'T FOUND FRONT PORT FOR LANE SET\n");
            }
            free(port_lane_list_attribute.value.u32list.list);
        }
    
        sai_thrift_attribute_t& attr = thrift_attr;
        thrift_port_list_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
        thrift_port_list_attribute.value.objlist.count = max_ports;
        std::vector<sai_thrift_object_id_t>& port_list = thrift_port_list_attribute.value.objlist.object_id_list;
        for (std::map<int, sai_object_id_t>::iterator it = front_to_sai_map.begin() ; it != front_to_sai_map.end(); it++)
        {
            port_list.push_back((sai_thrift_object_id_t) it->second);
        }
        attr = thrift_port_list_attribute;
        free(port_list_object_attribute.value.objlist.list);
    }

    sai_thrift_object_id_t sai_thrift_get_port_id_by_front_port(const std::string& port_name)
    {
        printf("sai_thrift_get_port_id_by_front_port\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_switch_api_t *switch_api;
        sai_port_api_t *port_api;
        sai_attribute_t max_port_attribute;
        sai_attribute_t port_list_object_attribute;
        sai_attribute_t port_lane_list_attribute;
        sai_object_list_t *port_list_object;
        int max_ports = 0;
        sai_thrift_object_id_t port_id;
        extern std::map<std::set<int>, std::string> gPortMap;
        std::map<std::set<int>, std::string>::iterator gPortMapIt;
    
        status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("sai_api_query failed!!!\n");
            return SAI_NULL_OBJECT_ID;
        }
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("sai_api_query failed!!!\n");
            return SAI_NULL_OBJECT_ID;
        }
        for (gPortMapIt = gPortMap.begin() ; gPortMapIt != gPortMap.end() ; gPortMapIt++)
        {
            if (gPortMapIt->second == port_name)
            {
                break;
            }
        }
    
        std::set<int> lane_set;
        if (gPortMapIt != gPortMap.end())
        {
            lane_set = gPortMapIt->first;
        }
        else {
            printf("Didn't find matching port to received name!\n");
            return SAI_NULL_OBJECT_ID;
        }
    
        max_port_attribute.id = SAI_SWITCH_ATTR_PORT_NUMBER;
        switch_api->get_switch_attribute(gSwitchId, 1, &max_port_attribute);
        max_ports = max_port_attribute.value.u32;
        port_list_object_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
        port_list_object_attribute.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * max_ports);
        port_list_object_attribute.value.objlist.count = max_ports;
        switch_api->get_switch_attribute(gSwitchId, 1, &port_list_object_attribute);
    
        for (int i=0 ; i<max_ports ; i++)
        {
            port_lane_list_attribute.id = SAI_PORT_ATTR_HW_LANE_LIST;
            port_lane_list_attribute.value.u32list.list = (uint32_t *) malloc(sizeof(uint32_t) * 4);
            port_lane_list_attribute.value.u32list.count = 4;
            port_api->get_port_attribute(port_list_object_attribute.value.objlist.list[i], 1, &port_lane_list_attribute);
    
            std::set<int> port_lanes;
            uint32_t laneCnt = port_lane_list_attribute.value.u32list.count;
            for (int j=0 ; j<laneCnt; j++)
            {
                port_lanes.insert(port_lane_list_attribute.value.u32list.list[j]);
            }
    
            if (port_lanes == lane_set)
            {
                port_id = (sai_thrift_object_id_t) port_list_object_attribute.value.objlist.list[i];
                free(port_list_object_attribute.value.objlist.list);
                free(port_lane_list_attribute.value.u32list.list);
                return port_id;
            }
            free(port_lane_list_attribute.value.u32list.list);
        }
        printf("Didn't find port\n");
        free(port_list_object_attribute.value.objlist.list);
        return SAI_NULL_OBJECT_ID;
    }

    void sai_thrift_create_bridge_port(sai_thrift_result_t &ret, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        sai_bridge_api_t *bridge_api;
        sai_attribute_t *sai_attrs = nullptr;
    
        SAI_THRIFT_FUNC_LOG();
    
        ret.__isset.status = true;
    
        ret.status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", ret.status);
            return;
        }
    
        sai_uint32_t attr_size = thrift_attr_list.size();
    
        sai_thrift_alloc_attr(sai_attrs, attr_size);
    
        sai_thrift_parse_bridge_port_attributes(thrift_attr_list, sai_attrs);
    
        ret.status = bridge_api->create_bridge_port((sai_object_id_t *) &ret.data.oid, gSwitchId, attr_size, sai_attrs);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to create bridge port, status:%d", ret.status);
        }
        ret.__isset.data = true;
        ret.data.__isset.oid = true;
    
        sai_thrift_free_attr(sai_attrs);
    }
    
    sai_thrift_status_t sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
    {
        sai_bridge_api_t *bridge_api;
        sai_status_t status;
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
            return status;
        }
    
        return bridge_api->remove_bridge_port((sai_object_id_t) bridge_port_id);
    }
    
    void sai_thrift_get_bridge_port_list(sai_thrift_result_t &ret, sai_thrift_object_id_t bridge_id)
    {
        std::vector<sai_thrift_object_id_t>& port_list = ret.data.objlist.object_id_list;
        sai_bridge_api_t *bridge_api;
        uint32_t max_ports = 128;
        sai_attribute_t attr;
    
        SAI_THRIFT_FUNC_LOG();
    
        ret.__isset.status = true;
    
        ret.status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", ret.status);
            return;
        }
    
        attr.id = SAI_BRIDGE_ATTR_PORT_LIST;
        attr.value.objlist.list = (sai_object_id_t *) calloc(max_ports, sizeof(sai_object_id_t));
        attr.value.objlist.count = max_ports;
    
        ret.status = bridge_api->get_bridge_attribute(bridge_id, 1, &attr);
        if (ret.status != SAI_STATUS_SUCCESS && attr.value.objlist.count > max_ports)
        {
            /* retry one more time with a bigger list */
            max_ports = attr.value.objlist.count;
            attr.value.objlist.list = (sai_object_id_t *) realloc(attr.value.objlist.list, max_ports * sizeof(sai_object_id_t));
    
            ret.status = bridge_api->get_bridge_attribute(bridge_id, 1, &attr);
        }
    
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to obtain bridge ports list, status:%d", ret.status);
            free(attr.value.objlist.list);
            return;
        }
    
        for (int index = 0; index < attr.value.objlist.count; index++)
        {
            port_list.push_back((sai_thrift_object_id_t) attr.value.objlist.list[index]);
        }
    
        ret.data.objlist.count = attr.value.objlist.count;
    
        ret.__isset.data = true;
        ret.data.__isset.objlist=true;
    
        free(attr.value.objlist.list);
    }
    
    sai_thrift_status_t sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id,
                                                             const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bridge_api_t *bridge_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
            return status;
        }
    
        sai_thrift_parse_bridge_port_attributes(thrift_attr_list, &attr);
    
        return bridge_api->set_bridge_port_attribute(bridge_port_id, &attr);
    }

    void sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t bridge_port_id) 
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bridge_api_t *bridge_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[13];
        sai_thrift_attribute_t thrift_attr;
    
        SAI_THRIFT_FUNC_LOG();
    
        thrift_attr_list.attr_count = 0;
    
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
            return;
        }
    
        attr[0].id = SAI_BRIDGE_PORT_ATTR_TYPE;
        attr[1].id = SAI_BRIDGE_PORT_ATTR_ADMIN_STATE;
        attr_count = 2;
    
        status = bridge_api->get_bridge_port_attribute(bridge_port_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get bridge port attribute: type,bridge-id,admin-state, status:%d", status);
            return;
        }
    
        sai_thrift_convert_to_port_thrift_attributes(attr,attr_count,thrift_attr_list);
    
        switch (attr[0].value.s32)
        {
            case SAI_BRIDGE_PORT_TYPE_PORT:
                attr[0].id = SAI_BRIDGE_PORT_ATTR_PORT_ID;
                attr[1].id = SAI_BRIDGE_PORT_ATTR_INGRESS_FILTERING;
                attr[2].id = SAI_BRIDGE_PORT_ATTR_EGRESS_FILTERING;
                attr[3].id = SAI_BRIDGE_PORT_ATTR_ISOLATION_GROUP;
                attr[4].id = SAI_BRIDGE_PORT_ATTR_MAX_LEARNED_ADDRESSES;
                attr[5].id = SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_LIMIT_VIOLATION_PACKET_ACTION;
                attr_count = 6;
                break;
            
            case SAI_BRIDGE_PORT_TYPE_1D_ROUTER:
                attr[0].id = SAI_BRIDGE_PORT_ATTR_RIF_ID;
                attr[1].id = SAI_BRIDGE_PORT_ATTR_BRIDGE_ID;
                attr_count = 2;
                break;
            
            case SAI_BRIDGE_PORT_TYPE_TUNNEL:
                attr[0].id = SAI_BRIDGE_PORT_ATTR_TUNNEL_ID;
                attr[1].id = SAI_BRIDGE_PORT_ATTR_BRIDGE_ID;
                attr[2].id = SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_OAM_ENABLE;
                attr[3].id = SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_POLICER_ID;
                attr[4].id = SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_SERVICE_ID;
                attr_count = 5;
                break;
            
            case SAI_BRIDGE_PORT_TYPE_SUB_PORT:
                attr[0].id = SAI_BRIDGE_PORT_ATTR_PORT_ID;
                attr[1].id = SAI_BRIDGE_PORT_ATTR_VLAN_ID;
                attr[2].id = SAI_BRIDGE_PORT_ATTR_TAGGING_MODE;
                attr[3].id = SAI_BRIDGE_PORT_ATTR_BRIDGE_ID;
                attr[4].id = SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_OAM_ENABLE;
                attr[5].id = SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_POLICER_ID;
                attr[6].id = SAI_BRIDGE_PORT_ATTR_SUB_TUNNEL_PORT_SERVICE_ID;
                attr_count = 7;
                break;
            
            default:
                return;
        }
    
        status = bridge_api->get_bridge_port_attribute(bridge_port_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get bridge port attribute for specified bridge port type, status:%d", status);
            return;
        }
    
        sai_thrift_convert_to_port_thrift_attributes(attr,attr_count,thrift_attr_list);
    }

    void sai_thrift_create_bridge(sai_thrift_result_t &ret, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        sai_bridge_api_t *bridge_api;
        sai_attribute_t  *sai_attrs = nullptr;
    
        SAI_THRIFT_FUNC_LOG();
    
        ret.status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", ret.status);
            return;
        }
    
        sai_uint32_t attr_size = thrift_attr_list.size();
    
        sai_thrift_alloc_attr(sai_attrs, attr_size);
    
        sai_thrift_parse_bridge_attributes(thrift_attr_list, sai_attrs);
    
        ret.status = bridge_api->create_bridge((sai_object_id_t *) &ret.data.oid, gSwitchId, attr_size, sai_attrs);
        if (ret.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to create bridge, status:%d", ret.status);
        }
    
        ret.__isset.status = true;
        ret.__isset.data = true;
        ret.data.__isset.oid = true;
    
        sai_thrift_free_attr(sai_attrs);
    }
    
    sai_thrift_status_t sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_port_id)
    {
        sai_bridge_api_t *bridge_api;
        sai_status_t status;
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
            return status;
        }
    
        return bridge_api->remove_bridge((sai_object_id_t) bridge_port_id);
    }
    
    sai_thrift_status_t sai_thrift_set_bridge_attribute(const sai_thrift_object_id_t bridge_id,
                                                        const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bridge_api_t *bridge_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
            return status;
        }
    
        sai_thrift_parse_bridge_attributes(thrift_attr_list, &attr);
    
        return bridge_api->set_bridge_attribute(bridge_id, &attr);
    }

    void sai_thrift_get_bridge_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t bridge_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bridge_api_t *bridge_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[6];
        sai_thrift_attribute_t thrift_attr;
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
            return;
        }
    
        attr[0].id = SAI_BRIDGE_ATTR_TYPE;
        //attr[1].id = SAI_BRIDGE_ATTR_PORT_LIST;
        attr[1].id = SAI_BRIDGE_ATTR_MAX_LEARNED_ADDRESSES;
        attr[2].id = SAI_BRIDGE_ATTR_LEARN_DISABLE;
        attr[3].id = SAI_BRIDGE_ATTR_UNKNOWN_UNICAST_FLOOD_CONTROL_TYPE;
        attr[4].id = SAI_BRIDGE_ATTR_UNKNOWN_MULTICAST_FLOOD_CONTROL_TYPE;
        attr[5].id = SAI_BRIDGE_ATTR_BROADCAST_FLOOD_CONTROL_TYPE;
    
        attr_count = 6;
    
        status = bridge_api->get_bridge_attribute(bridge_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get bridge attribute, status:%d", status);
            return;
        }
    
        thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id = attr[1].id;
        thrift_attr.value.__set_u32(attr[1].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id = attr[2].id;
        thrift_attr.value.__set_booldata(attr[2].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id = attr[3].id;
        thrift_attr.value.__set_s32(attr[3].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id = attr[4].id;
        thrift_attr.value.__set_s32(attr[4].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id = attr[5].id;
        thrift_attr.value.__set_s32(attr[5].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }




    void sai_thrift_get_bridge_port_stats(std::vector<int64_t> &thrift_counters,
                                          const sai_thrift_object_id_t bridge_port_id,
                                          const std::vector<sai_thrift_bridge_port_stat_counter_t> &thrift_counter_ids,
                                          const int32_t number_of_counters)
   {
        printf("sai_thrift_get_bridge_port_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bridge_api_t *bridge_api;
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);
        
        if (status != SAI_STATUS_SUCCESS) { return; }
        
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_bridge_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        { counter_ids[i] = (sai_bridge_stat_t) *it; }
        
        status = bridge_api->get_bridge_port_stats(bridge_port_id,
                                                   number_of_counters,
                                                   counter_ids,
                                                   counters);
        
        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) { thrift_counters.push_back(counters[i]); }
        
        free(counter_ids);
        free(counters);
        
        return;
    }

    void sai_thrift_get_bridge_port_stats_ext(std::vector<int64_t> &thrift_counters,
                                              const sai_thrift_object_id_t bridge_port_id,
                                              const std::vector<sai_thrift_bridge_port_stat_counter_t> &thrift_counter_ids,
                                              int8_t mode,
                                              int32_t number_of_counters)
    {
        printf("sai_thrift_get_bridge_port_stats_ext\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bridge_api_t *bridge_api;
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);

        if (status != SAI_STATUS_SUCCESS) { return; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_bridge_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        memset(counter_ids, 0, sizeof(sai_bridge_stat_t) * thrift_counter_ids.size());
        memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_bridge_stat_t) *it;
        }

        status = bridge_api->get_bridge_port_stats_ext(bridge_port_id,
                                          number_of_counters,
                                          counter_ids,
                                          (sai_stats_mode_t)mode,
                                          counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) { thrift_counters.push_back(counters[i]); }

        free(counter_ids);
        free(counters);

        return;
    }


    sai_thrift_status_t sai_thrift_clear_bridge_port_stats(const sai_thrift_object_id_t bridge_port_id,
                                                           const std::vector<sai_thrift_bridge_port_stat_counter_t> &thrift_counter_ids,
                                                           int32_t number_of_counters)
    {
        printf("sai_thrift_clear_bridge_port_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bridge_api_t *bridge_api;
        status = sai_api_query(SAI_API_BRIDGE, (void **) &bridge_api);

        if (status != SAI_STATUS_SUCCESS) { return status; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_bridge_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        memset(counter_ids, 0, sizeof(sai_bridge_stat_t) * thrift_counter_ids.size());
        memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_bridge_stat_t) *it;
        }

        status = bridge_api->clear_bridge_port_stats(bridge_port_id,
                                          number_of_counters,
                                          counter_ids);

        free(counter_ids);
        free(counters);

        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
    
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
    
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_hostif_attributes(attr_list, thrift_attr_list);
    
        sai_object_id_t hif_oid = 0;
        status = hostif_api->create_hostif(&hif_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
    
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return hif_oid; }
    
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
    
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
    
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
    
        status = hostif_api->remove_hostif(thrift_hif_id);
    
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
    
        SAI_THRIFT_LOG_ERR("Failed to remove OID.");
    }

    void sai_thrift_get_hostif_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t thrift_hif_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hostif_api_t *hostif_api = nullptr;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain hostif api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_HOSTIF_ATTR_TYPE;
        attr[1].id = SAI_HOSTIF_ATTR_OBJ_ID;
	    attr[2].id = SAI_HOSTIF_ATTR_NAME;
	    attr[3].id = SAI_HOSTIF_ATTR_OPER_STATUS;
        attr_count = 4;
        
        status = hostif_api->get_hostif_attribute(thrift_hif_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain hostif attribute, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_oid(attr[1].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    memcpy((void*)thrift_attr.value.chardata.c_str(), (const void*)attr[2].value.chardata, SAI_HOSTIF_NAME_SIZE);
        thrift_attr.value.__isset.chardata = true;
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_booldata(attr[3].value.booldata);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, 
                                                        const sai_thrift_attribute_t &thrift_attr) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_hostif_attributes(attr_list, thrift_attr_list);
        
        status = hostif_api->set_hostif_attribute(thrift_hif_id, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_hostif_table_entry_attributes(attr_list, thrift_attr_list);
        
        sai_object_id_t hif_tbl_entry_oid = 0;
        status = hostif_api->create_hostif_table_entry(&hif_tbl_entry_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return hif_tbl_entry_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t hif_tbl_entry_oid) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
    
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
    
        status = hostif_api->remove_hostif_table_entry(hif_tbl_entry_oid);
    
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
    
        SAI_THRIFT_LOG_ERR("Failed to remove OID.");
    }

    void sai_thrift_get_hostif_table_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                     const sai_thrift_object_id_t hif_tbl_entry_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hostif_api_t *hostif_api = nullptr;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain hostif api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_HOSTIF_TABLE_ENTRY_ATTR_TYPE;
        attr[1].id = SAI_HOSTIF_TABLE_ENTRY_ATTR_OBJ_ID;
	    attr[2].id = SAI_HOSTIF_TABLE_ENTRY_ATTR_TRAP_ID;
	    attr[3].id = SAI_HOSTIF_TABLE_ENTRY_ATTR_CHANNEL_TYPE;
        attr_count = 4;
        
        status = hostif_api->get_hostif_table_entry_attribute(hif_tbl_entry_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain hostif attribute, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_oid(attr[1].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_oid(attr[2].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_s32(attr[3].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t hif_tbl_entry_oid, 
                                                                    const sai_thrift_attribute_t &thrift_attr) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_hostif_table_entry_attributes(attr_list, thrift_attr_list);
        
        status = hostif_api->set_hostif_table_entry_attribute(hif_tbl_entry_oid, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_hostif_trap_group_attributes(attr_list, thrift_attr_list);
        
        sai_object_id_t hostif_trap_group_oid = 0;
        status = hostif_api->create_hostif_trap_group(&hostif_trap_group_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return hostif_trap_group_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
    
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
    
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
    
        status = hostif_api->remove_hostif_trap_group(thrift_hostif_trap_group_id);
    
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
    
        SAI_THRIFT_LOG_ERR("Failed to remove OID.");
    
        return status;
    }

    void sai_thrift_get_hostif_trap_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                    const sai_thrift_object_id_t thrift_hostif_trap_group_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hostif_api_t *hostif_api = nullptr;
        uint32_t attr_count = 0;
        sai_attribute_t attr[3];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain trap group api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_HOSTIF_TRAP_GROUP_ATTR_ADMIN_STATE;
        attr[1].id = SAI_HOSTIF_TRAP_GROUP_ATTR_QUEUE;
	    attr[2].id = SAI_HOSTIF_TRAP_GROUP_ATTR_POLICER;
        attr_count = 3;
        
        status = hostif_api->get_hostif_trap_group_attribute(thrift_hostif_trap_group_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain trap group attribute, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_booldata(attr[0].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_u32(attr[1].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_oid(attr[2].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id,
                                                                   const sai_thrift_attribute_t &thrift_attr) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_hostif_trap_group_attributes(attr_list, thrift_attr_list);
        
        status = hostif_api->set_hostif_trap_group_attribute(thrift_hostif_trap_group_id, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_hostif_trap_attributes(attr_list, thrift_attr_list);
        
        sai_object_id_t hostif_trap_oid = 0;
        status = hostif_api->create_hostif_trap(&hostif_trap_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return hostif_trap_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        status = hostif_api->remove_hostif_trap(thrift_hostif_trap_id);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to remove OID.");
        
        return status;
    }

    void sai_thrift_get_hostif_trap_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                              const sai_thrift_object_id_t thrift_hostif_trap_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hostif_api_t *hostif_api = nullptr;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain hostif_trap_api, status:%d", status);
            return;
        }
        
	    attr[0].id = SAI_HOSTIF_TRAP_ATTR_TRAP_TYPE;
        attr[1].id = SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION;
        attr[2].id = SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY;
	    attr[3].id = SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP;
        attr_count = 4;
        
        status = hostif_api->get_hostif_trap_attribute(thrift_hostif_trap_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain hostif_trap type, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_s32(attr[1].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_u32(attr[2].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_oid(attr[3].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, 
                                                             const sai_thrift_attribute_t &thrift_attr)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_hostif_api_t *hostif_api = nullptr;
        auto status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void**>(&hostif_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_hostif_trap_attributes(attr_list, thrift_attr_list);
        
        status = hostif_api->set_hostif_trap_attribute(thrift_hostif_trap_id, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    void sai_thrift_parse_acl_table_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;

        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;

            switch (attribute.id)
            {
                case SAI_ACL_TABLE_ATTR_ACL_STAGE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_ACL_TABLE_ATTR_FIELD_ACL_RANGE_TYPE:
                case SAI_ACL_TABLE_ATTR_ACL_BIND_POINT_TYPE_LIST:
                case SAI_ACL_TABLE_ATTR_ACL_ACTION_TYPE_LIST:    
                    {
                        int count = attribute.value.s32list.s32list.size();
                        sai_int32_t *aclbp_list = NULL;
                        std::vector<sai_int32_t>::const_iterator it = attribute.value.s32list.s32list.begin();
                        aclbp_list = (sai_int32_t*)malloc(sizeof(sai_int32_t) * count);

                        for (int j = 0; j < count; j++, it++)
                        {
                            *(aclbp_list + j) = (sai_int32_t)*it;
                        }
                        attr_list[i].value.s32list.list = aclbp_list;
                        attr_list[i].value.s32list.count = count;
                    }
                    break;

                case SAI_ACL_TABLE_ATTR_SIZE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;

                case SAI_ACL_TABLE_ATTR_FIELD_SRC_IPV6:
                case SAI_ACL_TABLE_ATTR_FIELD_DST_IPV6:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_SRC_IPV6:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_DST_IPV6:
                case SAI_ACL_TABLE_ATTR_FIELD_SRC_MAC:
                case SAI_ACL_TABLE_ATTR_FIELD_DST_MAC:
                case SAI_ACL_TABLE_ATTR_FIELD_SRC_IP:
                case SAI_ACL_TABLE_ATTR_FIELD_DST_IP:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_SRC_IP:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_DST_IP:
                case SAI_ACL_TABLE_ATTR_FIELD_IN_PORTS:
                case SAI_ACL_TABLE_ATTR_FIELD_OUT_PORTS:
                case SAI_ACL_TABLE_ATTR_FIELD_IN_PORT:
                case SAI_ACL_TABLE_ATTR_FIELD_OUT_PORT:
                case SAI_ACL_TABLE_ATTR_FIELD_SRC_PORT:
                case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_ID:
                case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_PRI:
                case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_CFI:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_ID:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_PRI:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_CFI:
                case SAI_ACL_TABLE_ATTR_FIELD_L4_SRC_PORT:
                case SAI_ACL_TABLE_ATTR_FIELD_L4_DST_PORT:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_L4_SRC_PORT:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_L4_DST_PORT:
                case SAI_ACL_TABLE_ATTR_FIELD_ETHER_TYPE:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_ETHER_TYPE:
                case SAI_ACL_TABLE_ATTR_FIELD_IP_PROTOCOL:
                case SAI_ACL_TABLE_ATTR_FIELD_INNER_IP_PROTOCOL:
                case SAI_ACL_TABLE_ATTR_FIELD_IP_IDENTIFICATION:
                case SAI_ACL_TABLE_ATTR_FIELD_DSCP:
                case SAI_ACL_TABLE_ATTR_FIELD_ECN:
                case SAI_ACL_TABLE_ATTR_FIELD_TTL:
                case SAI_ACL_TABLE_ATTR_FIELD_TOS:
                case SAI_ACL_TABLE_ATTR_FIELD_IP_FLAGS:
                case SAI_ACL_TABLE_ATTR_FIELD_TCP_FLAGS:
                case SAI_ACL_TABLE_ATTR_FIELD_ACL_IP_TYPE:
                case SAI_ACL_TABLE_ATTR_FIELD_ACL_IP_FRAG:
                case SAI_ACL_TABLE_ATTR_FIELD_IPV6_FLOW_LABEL:
                case SAI_ACL_TABLE_ATTR_FIELD_TC:
                case SAI_ACL_TABLE_ATTR_FIELD_ICMP_TYPE:
                case SAI_ACL_TABLE_ATTR_FIELD_ICMP_CODE:
                case SAI_ACL_TABLE_ATTR_FIELD_ICMPV6_TYPE:
                case SAI_ACL_TABLE_ATTR_FIELD_ICMPV6_CODE:
                case SAI_ACL_TABLE_ATTR_FIELD_PACKET_VLAN:
                case SAI_ACL_TABLE_ATTR_FIELD_TUNNEL_VNI:
                case SAI_ACL_TABLE_ATTR_FIELD_HAS_VLAN_TAG:
                case SAI_ACL_TABLE_ATTR_FIELD_MACSEC_SCI:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL0_LABEL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL0_TTL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL0_EXP:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL0_BOS:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL1_LABEL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL1_TTL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL1_EXP:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL1_BOS:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL2_LABEL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL2_TTL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL2_EXP:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL2_BOS:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL3_LABEL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL3_TTL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL3_EXP:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL3_BOS:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL4_LABEL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL4_TTL:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL4_EXP:
                case SAI_ACL_TABLE_ATTR_FIELD_MPLS_LABEL4_BOS:
                case SAI_ACL_TABLE_ATTR_FIELD_FDB_DST_USER_META:
                case SAI_ACL_TABLE_ATTR_FIELD_ROUTE_DST_USER_META:
                case SAI_ACL_TABLE_ATTR_FIELD_NEIGHBOR_DST_USER_META:
                case SAI_ACL_TABLE_ATTR_FIELD_PORT_USER_META:
                case SAI_ACL_TABLE_ATTR_FIELD_VLAN_USER_META:
                case SAI_ACL_TABLE_ATTR_FIELD_ACL_USER_META:
                case SAI_ACL_TABLE_ATTR_FIELD_FDB_NPU_META_DST_HIT:
                case SAI_ACL_TABLE_ATTR_FIELD_NEIGHBOR_NPU_META_DST_HIT:
                case SAI_ACL_TABLE_ATTR_FIELD_ROUTE_NPU_META_DST_HIT:
                case SAI_ACL_TABLE_ATTR_FIELD_BTH_OPCODE:
                case SAI_ACL_TABLE_ATTR_FIELD_AETH_SYNDROME:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+0:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+1:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+2:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+3:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+4:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+5:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+6:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+7:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+8:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+9:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+10:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+11:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+12:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+13:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+14:
                case SAI_ACL_TABLE_ATTR_USER_DEFINED_FIELD_GROUP_MIN+15:
                case SAI_ACL_TABLE_ATTR_FIELD_IPV6_NEXT_HEADER:
                case SAI_ACL_TABLE_ATTR_FIELD_TAM_INT_TYPE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                default:
                    break;
            }
        }
    }

    void sai_thrift_parse_acl_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_ACL_ENTRY_ATTR_TABLE_ID:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_TABLE_ID\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_ACL_ENTRY_ATTR_PRIORITY:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_PRIORITY\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_ACL_ENTRY_ATTR_ADMIN_STATE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ADMIN_STATE\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IPV6:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_SRC_IPV6\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    sai_thrift_string_to_v6_ip(attribute.value.aclfield.data.ip6, attr_list[i].value.aclfield.data.ip6);
                    sai_thrift_string_to_v6_ip(attribute.value.aclfield.mask.ip6, attr_list[i].value.aclfield.mask.ip6);
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_DST_IPV6:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_DST_IPV6\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    sai_thrift_string_to_v6_ip(attribute.value.aclfield.data.ip6, attr_list[i].value.aclfield.data.ip6);
                    sai_thrift_string_to_v6_ip(attribute.value.aclfield.mask.ip6, attr_list[i].value.aclfield.mask.ip6);
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_SRC_MAC:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_SRC_MAC\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    sai_thrift_string_to_mac(attribute.value.aclfield.data.mac, attr_list[i].value.aclfield.data.mac);
                    sai_thrift_string_to_mac(attribute.value.aclfield.mask.mac, attr_list[i].value.aclfield.mask.mac);
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_DST_MAC:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_DST_MAC\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    sai_thrift_string_to_mac(attribute.value.aclfield.data.mac, attr_list[i].value.aclfield.data.mac);
                    sai_thrift_string_to_mac(attribute.value.aclfield.mask.mac, attr_list[i].value.aclfield.mask.mac);
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IP:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_SRC_IP\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    sai_thrift_string_to_v4_ip(attribute.value.aclfield.data.ip4, &attr_list[i].value.aclfield.data.ip4);
                    sai_thrift_string_to_v4_ip(attribute.value.aclfield.mask.ip4, &attr_list[i].value.aclfield.mask.ip4);
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_DST_IP:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_DST_IP\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    sai_thrift_string_to_v4_ip(attribute.value.aclfield.data.ip4, &attr_list[i].value.aclfield.data.ip4);
                    sai_thrift_string_to_v4_ip(attribute.value.aclfield.mask.ip4, &attr_list[i].value.aclfield.mask.ip4);
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORT:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_IN_PORT\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORTS:
                    {
                        int count = attribute.value.aclfield.data.objlist.object_id_list.size();
                        sai_object_id_t *oid_list = NULL;

                        printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_IN_PORTS\n", __FUNCTION__, __LINE__);
                        std::vector<sai_thrift_object_id_t>::const_iterator it = attribute.value.aclfield.data.objlist.object_id_list.begin();
                        oid_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * count);
                        for(int j = 0; j < count; j++, it++)
                            *(oid_list + j) = (sai_object_id_t) *it;
                        attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                        attr_list[i].value.aclfield.data.objlist.list =  oid_list;
                        attr_list[i].value.aclfield.data.objlist.count =  count;
                    }
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORT:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORT\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                    break;
                /*
                case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORTS:
                */
               case SAI_ACL_ENTRY_ATTR_FIELD_ICMP_TYPE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ICMP_TYPE\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
               case SAI_ACL_ENTRY_ATTR_FIELD_ICMP_CODE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ICMP_CODE\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
               case SAI_ACL_ENTRY_ATTR_FIELD_ICMPV6_TYPE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ICMPV6_TYPE\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
               case SAI_ACL_ENTRY_ATTR_FIELD_ICMPV6_CODE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ICMPV6_CODE\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;                    
                case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_PRI:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_PRI\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_CFI:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_CFI\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_PRI:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_PRI\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_CFI:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_CFI\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_ID:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_ID\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_ID:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_ID\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_L4_SRC_PORT:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_L4_SRC_PORT\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_L4_DST_PORT:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_L4_DST_PORT\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ETHER_TYPE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ETHER_TYPE\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ACL_IP_TYPE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ACL_IP_TYPE\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.s32 = attribute.value.aclfield.data.s32;
                    attr_list[i].value.aclfield.mask.s32 = attribute.value.aclfield.mask.s32;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_PACKET_VLAN:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_PACKET_VLAN\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.s32 = attribute.value.aclfield.data.s32;
                    attr_list[i].value.aclfield.mask.s32 = attribute.value.aclfield.mask.s32;
                    break;                    
                case SAI_ACL_ENTRY_ATTR_FIELD_IP_PROTOCOL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_IP_PROTOCOL:%u\n", __FUNCTION__, __LINE__, attribute.value.aclfield.data.u8);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IPV6_NEXT_HEADER:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_IPV6_NEXT_HEADER:%u\n", __FUNCTION__, __LINE__, attribute.value.aclfield.data.u8);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;                    
                case SAI_ACL_ENTRY_ATTR_FIELD_DSCP:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_DSCP\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ECN:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ECN\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_TTL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_TTL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_TOS:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_TOS\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IP_FLAGS:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_IP_FLAGS\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_TCP_FLAGS:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_TCP_FLAGS\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ACL_IP_FRAG:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ACL_IP_FRAG\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_TC:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_TC\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IPV6_FLOW_LABEL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_IPV6_FLOW_LABEL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u32 = attribute.value.aclfield.data.u32;
                    attr_list[i].value.aclfield.mask.u32 = attribute.value.aclfield.mask.u32;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_FDB_DST_USER_META:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_FDB_DST_USER_META\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u32 = attribute.value.aclfield.data.u32;
                    attr_list[i].value.aclfield.mask.u32 = attribute.value.aclfield.mask.u32;
                    break;                    
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_LABEL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_LABEL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u32 = attribute.value.aclfield.data.u32;
                    attr_list[i].value.aclfield.mask.u32 = attribute.value.aclfield.mask.u32;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_TTL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_TTL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_EXP:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_EXP\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_BOS:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_BOS\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.booldata = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL1_LABEL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL1_LABEL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u32 = attribute.value.aclfield.data.u32;
                    attr_list[i].value.aclfield.mask.u32 = attribute.value.aclfield.mask.u32;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL1_TTL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL1_TTL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL1_EXP:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL1_EXP\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL1_BOS:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL1_BOS\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.booldata = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL2_LABEL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL2_LABEL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u32 = attribute.value.aclfield.data.u32;
                    attr_list[i].value.aclfield.mask.u32 = attribute.value.aclfield.mask.u32;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL2_TTL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL2_TTL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL2_EXP:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL2_EXP\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL2_BOS:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL2_BOS\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.booldata = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL3_LABEL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL3_LABEL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u32 = attribute.value.aclfield.data.u32;
                    attr_list[i].value.aclfield.mask.u32 = attribute.value.aclfield.mask.u32;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL3_TTL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL3_TTL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL3_EXP:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL3_EXP\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL3_BOS:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL3_BOS\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.booldata = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL4_LABEL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL4_LABEL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u32 = attribute.value.aclfield.data.u32;
                    attr_list[i].value.aclfield.mask.u32 = attribute.value.aclfield.mask.u32;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL4_TTL:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL4_TTL\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL4_EXP:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL4_EXP\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL4_BOS:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL4_BOS\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                    attr_list[i].value.aclfield.data.booldata = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_INGRESS_SAMPLEPACKET_ENABLE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_INGRESS_SAMPLEPACKET_ENABLE\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable = attribute.value.aclaction.enable;
                    attr_list[i].value.aclaction.parameter.oid = attribute.value.aclaction.parameter.oid;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_INGRESS:
                    {
                        int count = attribute.value.aclaction.parameter.objlist.object_id_list.size();
                        sai_object_id_t *oid_list = NULL;
                        std::vector<sai_thrift_object_id_t>::const_iterator it = attribute.value.aclaction.parameter.objlist.object_id_list.begin();

                        printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_INGRESS\n", __FUNCTION__, __LINE__);
                        oid_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * count);
                        for(int j = 0; j < count; j++, it++)
                            *(oid_list + j) = (sai_object_id_t) *it;
                        attr_list[i].value.aclaction.enable = attribute.value.aclaction.enable;
                        attr_list[i].value.aclaction.parameter.objlist.list =  oid_list;
                        attr_list[i].value.aclaction.parameter.objlist.count =  count;
                    }
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_EGRESS:
                    {
                        int count = attribute.value.aclaction.parameter.objlist.object_id_list.size();
                        sai_object_id_t *oid_list = NULL;
                        std::vector<sai_thrift_object_id_t>::const_iterator it = attribute.value.aclaction.parameter.objlist.object_id_list.begin();

                        printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_EGRESS\n", __FUNCTION__, __LINE__);
                        oid_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * count);
                        for(int j = 0; j < count; j++, it++)
                            *(oid_list + j) = (sai_object_id_t) *it;
                        attr_list[i].value.aclaction.enable = attribute.value.aclaction.enable;
                        attr_list[i].value.aclaction.parameter.objlist.list =  oid_list;
                        attr_list[i].value.aclaction.parameter.objlist.count =  count;
                    }
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_POLICER:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_SET_POLICER\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable = attribute.value.aclaction.enable;
                    attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_COUNTER:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_COUNTER\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable = attribute.value.aclaction.enable;
                    attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_PACKET_ACTION:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_PACKET_ACTION\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable        = attribute.value.aclaction.enable;
                    attr_list[i].value.aclaction.parameter.s32 = attribute.value.aclaction.parameter.s32;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_OUTER_VLAN_ID:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_SET_OUTER_VLAN_ID\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable        = attribute.value.aclaction.enable;
                    attr_list[i].value.aclaction.parameter.u16 = attribute.value.aclaction.parameter.u16;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_INNER_VLAN_ID:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_SET_INNER_VLAN_ID\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable        = attribute.value.aclaction.enable;
                    attr_list[i].value.aclaction.parameter.u16 = attribute.value.aclaction.parameter.u16;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_OUTER_VLAN_PRI:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_SET_OUTER_VLAN_PRI\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable        = attribute.value.aclaction.enable;
                    attr_list[i].value.aclaction.parameter.u8 = attribute.value.aclaction.parameter.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_INNER_VLAN_PRI:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_SET_INNER_VLAN_PRI\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable        = attribute.value.aclaction.enable;
                    attr_list[i].value.aclaction.parameter.u8 = attribute.value.aclaction.parameter.u8;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_DO_NOT_LEARN:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_SET_DO_NOT_LEARN\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable        = attribute.value.aclaction.enable;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT\n", __FUNCTION__, __LINE__);
                    attr_list[i].value.aclaction.enable        = attribute.value.aclaction.enable;
                    attr_list[i].value.aclaction.parameter.oid = attribute.value.aclaction.parameter.oid;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ACL_RANGE_TYPE:
                    printf("%s %d, SAI_ACL_ENTRY_ATTR_FIELD_ACL_RANGE_TYPE\n", __FUNCTION__, __LINE__);
                    {
                        int count = attribute.value.aclfield.data.objlist.object_id_list.size();
                        sai_object_id_t *oid_list = NULL;
                        std::vector<sai_thrift_object_id_t>::const_iterator it = attribute.value.aclfield.data.objlist.object_id_list.begin();
                        oid_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * count);
                        for(int j = 0; j < count; j++, it++)
                            *(oid_list + j) = (sai_object_id_t) *it;
                        attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;
                        attr_list[i].value.aclfield.data.objlist.list =  oid_list;
                        attr_list[i].value.aclfield.data.objlist.count =  count;
                    }
                    break;
                default:
                    if (attribute.id >= SAI_ACL_ENTRY_ATTR_USER_DEFINED_FIELD_GROUP_MIN
                        && attribute.id <= SAI_ACL_ENTRY_ATTR_USER_DEFINED_FIELD_GROUP_MAX)
                    {
                        sai_uint8_t* u8list = NULL;
                        attr_list[i].value.aclfield.enable = attribute.value.aclfield.enable;

                        u8list = (sai_uint8_t *)malloc(sizeof(sai_uint8_t) * attribute.value.aclfield.data.u8list.count);
                        std::vector <sai_int8_t> ::const_iterator it2 = attribute.value.aclfield.data.u8list.u8list.begin();

                        printf("%s %d, SAI_ACL_ENTRY_ATTR_USER_DEFINED_FIELD_GROUP_MIN+%u\n", __FUNCTION__, __LINE__, attribute.id-SAI_ACL_ENTRY_ATTR_USER_DEFINED_FIELD_GROUP_MIN);
                        for (uint32_t j = 0; j < attribute.value.aclfield.data.u8list.u8list.size(); j++, *it2++)
                        {
                            u8list[j] = (sai_uint8_t) *it2;
                        }
                        attr_list[i].value.aclfield.data.u8list.count = attribute.value.aclfield.data.u8list.count;
                        attr_list[i].value.aclfield.data.u8list.list = u8list;

                        u8list = (sai_uint8_t *)malloc(sizeof(sai_uint8_t) * attribute.value.aclfield.mask.u8list.count);
                        std::vector <sai_int8_t> ::const_iterator it3 = attribute.value.aclfield.mask.u8list.u8list.begin();
                        for (uint32_t j = 0; j < attribute.value.aclfield.data.u8list.u8list.size(); j++, *it3++)
                        {
                            u8list[j] = (sai_uint8_t)*it3;
                        }
                        attr_list[i].value.aclfield.mask.u8list.count = attribute.value.aclfield.mask.u8list.count;
                        attr_list[i].value.aclfield.mask.u8list.list = u8list;
                    }
                    break;
            }
        }
    }

    void sai_thrift_parse_acl_table_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                     sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_ACL_TABLE_GROUP_ATTR_ACL_STAGE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_ACL_TABLE_GROUP_ATTR_ACL_BIND_POINT_TYPE_LIST:
                    {
                        int count = attribute.value.s32list.s32list.size();
                        sai_int32_t *s32_list = NULL;
                        std::vector<sai_int32_t>::const_iterator it = attribute.value.s32list.s32list.begin();
                        s32_list = (sai_int32_t *) malloc(sizeof(sai_int32_t) * count);
                        for(int j = 0; j < count; j++, it++)
                            *(s32_list + j) = (sai_int32_t) *it;
                        attr_list[i].value.s32list.list = s32_list;
                        attr_list[i].value.s32list.count = count;
                    }
                    break;
                case SAI_ACL_TABLE_GROUP_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                default:
                    break;
            }
        }
    }

    void sai_thrift_parse_acl_table_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                            sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
              case SAI_ACL_TABLE_GROUP_MEMBER_ATTR_ACL_TABLE_GROUP_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_ACL_TABLE_GROUP_MEMBER_ATTR_ACL_TABLE_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_ACL_TABLE_GROUP_MEMBER_ATTR_PRIORITY:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              default:
                  break;
            }
        }
    }

    void sai_thrift_convert_to_acl_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                      sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_ACL_COUNTER_ATTR_TABLE_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_ACL_COUNTER_ATTR_PACKETS:
                    attr_list[i].value.u64= attribute.value.u64;
                    break;
                case SAI_ACL_COUNTER_ATTR_BYTES:
                    attr_list[i].value.u64= attribute.value.u64;
                    break;
            }
        }
    }

    void sai_thrift_convert_to_acl_thrift_counter_attributes(sai_attribute_t *attr_list,
                                                             uint32_t attr_count,
                                                             std::vector<sai_thrift_attribute_value_t> &thrift_attr_value_list)
    {
        sai_attribute_t attribute;
        sai_thrift_attribute_value_t thrift_attribute_value;
        for(uint32_t i = 0; i < attr_count; i++)
        {
            attribute = attr_list[i];
            switch (attribute.id)
            {
                case SAI_ACL_COUNTER_ATTR_TABLE_ID:
                    thrift_attribute_value.__set_oid(attribute.value.oid);
                    break;
                case SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT:
                    thrift_attribute_value.__set_booldata(attribute.value.booldata);
                    break;
                case SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT:
                    thrift_attribute_value.__set_booldata(attribute.value.booldata);
                    break;
                case SAI_ACL_COUNTER_ATTR_PACKETS:
                    thrift_attribute_value.__set_u64(attribute.value.u64);
                    break;
                case SAI_ACL_COUNTER_ATTR_BYTES:
                    thrift_attribute_value.__set_u64(attribute.value.u64);
                    break;
            }
            thrift_attr_value_list.push_back(thrift_attribute_value);
        }
    }

    sai_thrift_object_id_t sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        sai_object_id_t acl_table = 0ULL;
        sai_acl_api_t *acl_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
        printf("sai_thrift_create_acl_table\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_acl_table_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = acl_api->create_acl_table(&acl_table, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("create acl table fail !\n");
        }
        free(attr_list);
        return acl_table;
    }

    sai_thrift_status_t sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        printf("sai_thrift_remove_acl_table\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = acl_api->remove_acl_table(acl_table_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("remove acl table fail !\n");
        }
        return status;
    }

    void sai_thrift_get_acl_table_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                            const sai_thrift_object_id_t acl_table_id, 
                                            const std::vector < int32_t > & thrift_attr_ids)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        uint32_t attr_count = 0;
        uint32_t index = 0;
	    uint32_t ii = 0;
        sai_attribute_t *attr_list;
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl_api, status:%d", status);
            return;
        }
        
        attr_count = thrift_attr_ids.size();
        attr_list = (sai_attribute_t*)malloc(sizeof(sai_attribute_t) * thrift_attr_ids.size());
        
	    std::vector<int32_t>::const_iterator it = thrift_attr_ids.begin();
        
        for (index = 0; index < thrift_attr_ids.size(); index++, it++)
        {
            attr_list[index].id = (int32_t)*it;
        
            if (SAI_ACL_TABLE_ATTR_ACL_BIND_POINT_TYPE_LIST == attr_list[index].id)
            {
                attr_list[index].value.s32list.count = 5;
                attr_list[index].value.s32list.list = (int32_t*)malloc(sizeof(int32_t) * 5);
            }

            if (SAI_ACL_TABLE_ATTR_FIELD_ACL_RANGE_TYPE == attr_list[index].id)
            {
                attr_list[index].value.s32list.count = 5;
                attr_list[index].value.s32list.list = (int32_t*)malloc(sizeof(int32_t) * 5);
            }

            if (SAI_ACL_TABLE_ATTR_ACL_ACTION_TYPE_LIST == attr_list[index].id)
            {
                attr_list[index].value.s32list.count = 50;
                attr_list[index].value.s32list.list = (int32_t*)malloc(sizeof(int32_t) * 5);
            }
            
            if (SAI_ACL_TABLE_ATTR_ENTRY_LIST == attr_list[index].id)
            {
                attr_list[index].value.objlist.count = 100;
                attr_list[index].value.objlist.list = (sai_object_id_t*)malloc(sizeof(sai_object_id_t) * 100);
            }
        }
        
        status = acl_api->get_acl_table_attribute(acl_table_id, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl table group type, status:%d", status);
            return;
        }
        
        for (index = 0; index < attr_count; index++)
        {
            thrift_attr.id = attr_list[index].id;
            switch (attr_list[index].id)
            {
                case SAI_ACL_TABLE_ATTR_ACL_STAGE:
                    thrift_attr.value.__set_s32(attr_list[index].value.s32);
                    break;
                case SAI_ACL_TABLE_ATTR_ACL_BIND_POINT_TYPE_LIST:
                    {
                        thrift_attr.value.s32list.count = attr_list[index].value.s32list.count;
                        std :: vector < sai_int32_t > & bind_point_list = thrift_attr.value.s32list.s32list;
                        for (ii = 0; ii < attr_list[index].value.s32list.count; ii++)
                        {
                            bind_point_list.push_back((sai_int32_t) attr_list[index].value.s32list.list[ii]);
                        }
                        thrift_attr.value.__isset.s32list = true;
                    }
                    break;
                case SAI_ACL_TABLE_ATTR_FIELD_ACL_RANGE_TYPE:
                    {
                        thrift_attr.value.s32list.count = attr_list[index].value.s32list.count;
                        std :: vector < sai_int32_t > & range_type_list = thrift_attr.value.s32list.s32list;
                        for (ii = 0; ii < attr_list[index].value.s32list.count; ii++)
                        {
                            range_type_list.push_back((sai_int32_t) attr_list[index].value.s32list.list[ii]);
                        }
                        thrift_attr.value.__isset.s32list = true;
                    }
                    break;  
                case SAI_ACL_TABLE_ATTR_ACL_ACTION_TYPE_LIST:
                    {
                        thrift_attr.value.s32list.count = attr_list[index].value.s32list.count;
                        std :: vector < sai_int32_t > & action_type_list = thrift_attr.value.s32list.s32list;
                        for (ii = 0; ii < attr_list[index].value.s32list.count; ii++)
                        {
                            action_type_list.push_back((sai_int32_t) attr_list[index].value.s32list.list[ii]);
                        }
                        thrift_attr.value.__isset.s32list = true;
                    }
                    break;                 
                case SAI_ACL_TABLE_ATTR_SIZE:
                    thrift_attr.value.__set_u32(attr_list[index].value.u32);
                    break;
                case SAI_ACL_TABLE_ATTR_ENTRY_LIST:
                    {
                        thrift_attr.value.objlist.count = attr_list[index].value.objlist.count;
                        std :: vector < sai_thrift_object_id_t > & entry_list = thrift_attr.value.objlist.object_id_list;
                        for (ii = 0; ii < attr_list[index].value.objlist.count; ii++)
                        {
                            entry_list.push_back((sai_thrift_object_id_t) attr_list[index].value.objlist.list[ii]);
                        }
                        thrift_attr.value.__isset.objlist = true;
                    }
                    break;
                case SAI_ACL_TABLE_ATTR_AVAILABLE_ACL_ENTRY:
                    thrift_attr.value.__set_u32(attr_list[index].value.u32);
                    break;
                case SAI_ACL_TABLE_ATTR_AVAILABLE_ACL_COUNTER:
                    thrift_attr.value.__set_u32(attr_list[index].value.u32);
                    break;
                default:/* All Not support feature has returned by the function get_acl_table_attribute */
                    thrift_attr.value.__set_booldata(attr_list[index].value.booldata);
            }
		    thrift_attr_list.attr_list.push_back(thrift_attr);
            
		    /* free memory after push back */
            if ((SAI_ACL_TABLE_ATTR_ACL_BIND_POINT_TYPE_LIST == attr_list[index].id) && (attr_list[index].value.s32list.list))
            {
                free(attr_list[index].value.s32list.list);
            }

            if ((SAI_ACL_TABLE_ATTR_FIELD_ACL_RANGE_TYPE == attr_list[index].id) && (attr_list[index].value.s32list.list))
            {
                free(attr_list[index].value.s32list.list);
            }

            if ((SAI_ACL_TABLE_ATTR_ACL_ACTION_TYPE_LIST == attr_list[index].id) && (attr_list[index].value.s32list.list))
            {
                free(attr_list[index].value.s32list.list);
            }
            
            if ((SAI_ACL_TABLE_ATTR_ENTRY_LIST == attr_list[index].id) && (attr_list[index].value.objlist.list))
            {
                free(attr_list[index].value.objlist.list);
            }
        }

        if (attr_list)
        {
            free(attr_list);
        }
        
	    return;
    }

    sai_thrift_object_id_t sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        sai_object_id_t acl_entry = 0ULL;
        sai_acl_api_t *acl_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
        printf("sai_thrift_create_acl_entry\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_acl_entry_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = acl_api->create_acl_entry(&acl_entry, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("create acl entry fail !\n");
        }
        free(attr_list);
        return acl_entry;
    }

    sai_thrift_status_t sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        printf("sai_thrift_remove_acl_entry\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = acl_api->remove_acl_entry(acl_entry);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("remove acl entry fail !\n");
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_set_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_id, 
                                                           const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl_api, status:%d", status);
            return status;
        }
    
        sai_thrift_parse_acl_entry_attributes(thrift_attr_list, &attr);
    
        return acl_api->set_acl_entry_attribute(acl_entry_id, &attr);
    }

    void sai_thrift_get_acl_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                            const sai_thrift_object_id_t acl_entry_id, 
                                            const std :: vector < int32_t > & thrift_attr_ids)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        uint32_t attr_count = 0;
        uint32_t index = 0;
        uint32_t ii = 0;
        sai_attribute_t *attr_list;
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl_api, status:%d", status);
            return;
        }
        
        attr_count = thrift_attr_ids.size();
        attr_list = (sai_attribute_t*)malloc(sizeof(sai_attribute_t) * thrift_attr_ids.size());
        
        std::vector<int32_t>::const_iterator it = thrift_attr_ids.begin();
        
        for (index = 0; index < thrift_attr_ids.size(); index++, it++)
        {
            attr_list[index].id = (int32_t)*it;
        }
        
        status = acl_api->get_acl_entry_attribute(acl_entry_id, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl entry attribute, status:%d", status);
            return;
        }
        
        for (index = 0; index < attr_count; index++)
        {
            thrift_attr.id = attr_list[index].id;
            switch (attr_list[index].id)
            {
                case SAI_ACL_ENTRY_ATTR_TABLE_ID:
                    thrift_attr.value.__set_oid(attr_list[index].value.oid);
                    break;
                case SAI_ACL_ENTRY_ATTR_PRIORITY:
                    thrift_attr.value.__set_u32(attr_list[index].value.u32);
                    break;
                case SAI_ACL_ENTRY_ATTR_ADMIN_STATE:
                    thrift_attr.value.__set_booldata(attr_list[index].value.booldata);
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IPV6:
	    		  thrift_attr.value.aclfield.data.ip6 = sai_thrift_v6_ip_to_string(attr_list[index].value.aclfield.data.ip6);
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.ip6 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_DST_IPV6:
                    thrift_attr.value.aclfield.data.ip6 = sai_thrift_v6_ip_to_string(attr_list[index].value.aclfield.data.ip6);
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.ip6 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_SRC_MAC:
	    		  thrift_attr.value.aclfield.data.mac = sai_thrift_mac_to_string(attr_list[index].value.aclfield.data.mac);
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.mac = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_DST_MAC:
                    thrift_attr.value.aclfield.data.mac = sai_thrift_mac_to_string(attr_list[index].value.aclfield.data.mac);
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.mac = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IP:
	    		  thrift_attr.value.aclfield.data.ip4 = sai_thrift_v4_ip_to_string(attr_list[index].value.aclfield.data.ip4);
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.ip4 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_DST_IP:
                    thrift_attr.value.aclfield.data.ip4 = sai_thrift_v4_ip_to_string(attr_list[index].value.aclfield.data.ip4);
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.ip4 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORTS:
                case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORTS:
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORT:
                    thrift_attr.value.aclfield.data.oid = attr_list[index].value.aclfield.data.oid;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.oid = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORT:
                    thrift_attr.value.aclfield.data.oid = attr_list[index].value.aclfield.data.oid;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.oid = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_SRC_PORT:
                    thrift_attr.value.aclfield.data.oid = attr_list[index].value.aclfield.data.oid;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.oid = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_ID:
                    thrift_attr.value.aclfield.data.u16 = attr_list[index].value.aclfield.data.u16;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u16 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_PRI:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                     thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_CFI:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_ID:
                    thrift_attr.value.aclfield.data.u16 = attr_list[index].value.aclfield.data.u16;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u16 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_PRI:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_CFI:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_L4_SRC_PORT:
                    thrift_attr.value.aclfield.data.u16 = attr_list[index].value.aclfield.data.u16;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u16 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_L4_DST_PORT:
                    thrift_attr.value.aclfield.data.u16 = attr_list[index].value.aclfield.data.u16;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u16 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ETHER_TYPE:
                    thrift_attr.value.aclfield.data.u16 = attr_list[index].value.aclfield.data.u16;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u16 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IP_PROTOCOL:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_DSCP:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ECN:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_TTL:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_TOS:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IP_FLAGS:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_TCP_FLAGS:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ACL_IP_TYPE:
                    thrift_attr.value.aclfield.data.s32 = attr_list[index].value.aclfield.data.s32;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.s32 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ACL_IP_FRAG:
                    thrift_attr.value.aclfield.data.s32 = attr_list[index].value.aclfield.data.s32;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.s32 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IPV6_FLOW_LABEL:
                    thrift_attr.value.aclfield.data.u32 = attr_list[index].value.aclfield.data.u32;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u32 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_MPLS_LABEL0_LABEL:
                    thrift_attr.value.aclfield.data.u32 = attr_list[index].value.aclfield.data.u32;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u32 = true;
                    break;                    
                case SAI_ACL_ENTRY_ATTR_FIELD_TC:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ICMP_TYPE:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ICMP_CODE:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ICMPV6_TYPE:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ICMPV6_CODE:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;                    
                case SAI_ACL_ENTRY_ATTR_FIELD_PACKET_VLAN:
                    thrift_attr.value.aclfield.data.s32 = attr_list[index].value.aclfield.data.s32;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.s32 = true;
                    break;
	    	  /*
                case SAI_ACL_ENTRY_ATTR_FIELD_TUNNEL_VNI:
                    thrift_attr.value.aclfield.data.u32 = attr_list[index].value.aclfield.data.u32;
                    break;
                */
                case SAI_ACL_ENTRY_ATTR_FIELD_FDB_DST_USER_META:
                case SAI_ACL_ENTRY_ATTR_FIELD_ROUTE_DST_USER_META:
                case SAI_ACL_ENTRY_ATTR_FIELD_NEIGHBOR_DST_USER_META:
                case SAI_ACL_ENTRY_ATTR_FIELD_PORT_USER_META:
                case SAI_ACL_ENTRY_ATTR_FIELD_VLAN_USER_META:
                case SAI_ACL_ENTRY_ATTR_FIELD_ACL_USER_META:
                    thrift_attr.value.aclfield.data.u32 = attr_list[index].value.aclfield.data.u32;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u32 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_FDB_NPU_META_DST_HIT:
                case SAI_ACL_ENTRY_ATTR_FIELD_NEIGHBOR_NPU_META_DST_HIT:
                case SAI_ACL_ENTRY_ATTR_FIELD_ROUTE_NPU_META_DST_HIT:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.booldata;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_ACL_RANGE_TYPE :    /* need revise */
                    break;
                case SAI_ACL_ENTRY_ATTR_FIELD_IPV6_NEXT_HEADER:
                    thrift_attr.value.aclfield.data.u8 = attr_list[index].value.aclfield.data.u8;
                    thrift_attr.value.__isset.aclfield = true;
                    thrift_attr.value.aclfield.data.__isset.u8 = true;
                    break;
                    /* key end */
                case SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT:
                    thrift_attr.value.aclaction.parameter.oid = attr_list[index].value.aclaction.parameter.oid;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.oid = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_PACKET_ACTION:
                    thrift_attr.value.aclaction.parameter.s32 = attr_list[index].value.aclaction.parameter.s32;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.s32 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_FLOOD :    /* need revise */
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_COUNTER:
                    thrift_attr.value.aclaction.parameter.oid = attr_list[index].value.aclaction.parameter.oid;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.oid = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_INGRESS:
                case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_EGRESS :    /* need revise */
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_POLICER:
                    thrift_attr.value.aclaction.parameter.oid = attr_list[index].value.aclaction.parameter.oid;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.oid = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_DECREMENT_TTL :    /* need revise */
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_TC:
                    thrift_attr.value.aclaction.parameter.u8 = attr_list[index].value.aclaction.parameter.u8;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_PACKET_COLOR:
                    thrift_attr.value.aclaction.parameter.s32 = attr_list[index].value.aclaction.parameter.s32;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.s32 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_INNER_VLAN_ID:
                    thrift_attr.value.aclaction.parameter.u16 = attr_list[index].value.aclaction.parameter.u16;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.u16 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_INNER_VLAN_PRI:
                    thrift_attr.value.aclaction.parameter.u8 = attr_list[index].value.aclaction.parameter.u8;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_OUTER_VLAN_ID:
                    thrift_attr.value.aclaction.parameter.u16 = attr_list[index].value.aclaction.parameter.u16;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.u16 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_OUTER_VLAN_PRI:
                    thrift_attr.value.aclaction.parameter.u8 = attr_list[index].value.aclaction.parameter.u8;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_DSCP:
                    thrift_attr.value.aclaction.parameter.u8 = attr_list[index].value.aclaction.parameter.u8;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_ECN:
                    thrift_attr.value.aclaction.parameter.u8 = attr_list[index].value.aclaction.parameter.u8;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.u8 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_INGRESS_SAMPLEPACKET_ENABLE:
                case SAI_ACL_ENTRY_ATTR_ACTION_EGRESS_SAMPLEPACKET_ENABLE:
                    thrift_attr.value.aclaction.parameter.oid = attr_list[index].value.aclaction.parameter.oid;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.oid = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_ACL_META_DATA:
                    thrift_attr.value.aclaction.parameter.u32 = attr_list[index].value.aclaction.parameter.u32;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.s32 = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_EGRESS_BLOCK_PORT_LIST :    /* need revise */
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_USER_TRAP_ID:
                    thrift_attr.value.aclaction.parameter.oid = attr_list[index].value.aclaction.parameter.oid;
                    thrift_attr.value.__isset.aclaction = true;
                    thrift_attr.value.aclaction.parameter.__isset.oid = true;
                    break;
                case SAI_ACL_ENTRY_ATTR_ACTION_SET_DO_NOT_LEARN :    /* need revise */
                    break;
            }
        
            thrift_attr_list.attr_list.push_back(thrift_attr);
        }
        
	    if (attr_list)
        {
            free(attr_list);
        }
        
	    return;
    }

    sai_thrift_object_id_t sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        sai_object_id_t acl_table_group_id = 0ULL;
        sai_acl_api_t *acl_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
	    printf("sai_thrift_create_acl_table_group\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_acl_table_group_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = acl_api->create_acl_table_group(&acl_table_group_id, gSwitchId, attr_count, attr_list);
	    if (status != SAI_STATUS_SUCCESS)
        {
            printf("create acl table group fail !\n");
        }
        free(attr_list);
        return acl_table_group_id;
    }

    sai_thrift_status_t sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        printf("sai_thrift_remove_acl_table_group\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = acl_api->remove_acl_table_group(acl_table_group_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("remove acl table group fail !\n");
        }
        return status;
    }

    void sai_thrift_get_acl_table_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                  const sai_thrift_object_id_t acl_table_group_id)
    {
  	    sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        uint32_t attr_count = 0;
	    int32_t index = 0;
        sai_attribute_t attr_list[4];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl_api, status:%d", status);
            return;
        }
        
        attr_list[0].id = SAI_ACL_TABLE_GROUP_ATTR_ACL_STAGE;
        attr_list[1].id = SAI_ACL_TABLE_GROUP_ATTR_ACL_BIND_POINT_TYPE_LIST;
        attr_list[2].id = SAI_ACL_TABLE_GROUP_ATTR_TYPE;
        attr_list[3].id = SAI_ACL_TABLE_GROUP_ATTR_MEMBER_LIST;
        attr_count = 4;
        
        attr_list[1].value.s32list.list = (int32_t*)malloc(sizeof(int32_t) * 5);
        attr_list[1].value.s32list.count = 5;
        
        attr_list[3].value.objlist.list = (sai_object_id_t*)malloc(sizeof(sai_object_id_t) * 100);
        attr_list[3].value.objlist.count = 100;
        
        status = acl_api->get_acl_table_group_attribute(acl_table_group_id, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl table group type, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr_list[0].id;
	    thrift_attr.value.__set_s32(attr_list[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr_list[1].id;
	    thrift_attr.value.s32list.count = attr_list[1].value.s32list.count;
        std::vector < sai_int32_t > & bind_point_list = thrift_attr.value.s32list.s32list;
        for (index = 0; index < attr_list[1].value.s32list.count; index++)
        {
            bind_point_list.push_back((sai_int32_t) attr_list[1].value.s32list.list[index]);
        }
        thrift_attr.value.__isset.s32list = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr_list[2].id;
	    thrift_attr.value.__set_s32(attr_list[2].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr_list[3].id;
	    thrift_attr.value.objlist.count = attr_list[3].value.objlist.count;
	    std::vector < sai_thrift_object_id_t > & member_list = thrift_attr.value.objlist.object_id_list;
        for (index = 0; index < attr_list[3].value.objlist.count; index++)
        {
            member_list.push_back((sai_thrift_object_id_t) attr_list[3].value.objlist.list[index]);
        }
        thrift_attr.value.__isset.objlist = true;
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
        if (attr_list[1].value.s32list.list)
        {
	        free(attr_list[1].value.s32list.list);
        }
        
	    if (attr_list[3].value.objlist.list)
        {
	        free(attr_list[3].value.objlist.list);
        }
        
	    return;
    }

    sai_thrift_object_id_t sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        sai_object_id_t acl_table_group_member_id = 0ULL;
        sai_acl_api_t *acl_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
        printf("sai_thrift_create_acl_table_group_member\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_acl_table_group_member_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = acl_api->create_acl_table_group_member(&acl_table_group_member_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("create acl table group member fail !\n");
        }
        free(attr_list);
        return acl_table_group_member_id;
    }

    sai_thrift_status_t sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        printf("sai_thrift_remove_acl_table_group_member\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = acl_api->remove_acl_table_group_member(acl_table_group_member_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("remove acl table group member fail !\n");
        }
        return status;
    }

    void sai_thrift_get_acl_table_group_member_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                         const sai_thrift_object_id_t acl_table_group_member_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr_list[3];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl_api, status:%d", status);
            return;
        }
        
        attr_list[0].id = SAI_ACL_TABLE_GROUP_MEMBER_ATTR_ACL_TABLE_GROUP_ID;
        attr_list[1].id = SAI_ACL_TABLE_GROUP_MEMBER_ATTR_ACL_TABLE_ID;
        attr_list[2].id = SAI_ACL_TABLE_GROUP_MEMBER_ATTR_PRIORITY;
        attr_count = 3;
        
        status = acl_api->get_acl_table_group_member_attribute(acl_table_group_member_id, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl table group member attribute, status:%d", status);
            return;
        }
        
        thrift_attr.id = attr_list[0].id;
        thrift_attr.value.__set_oid(attr_list[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr_list[1].id;
        thrift_attr.value.__set_oid(attr_list[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr_list[2].id;
        thrift_attr.value.__set_u32(attr_list[2].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    return;
    }

    sai_thrift_object_id_t sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        sai_object_id_t acl_counter_id = 0ULL;
        sai_acl_api_t *acl_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
	    printf("sai_thrift_create_acl_counter\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_convert_to_acl_counter_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = acl_api->create_acl_counter(&acl_counter_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("create acl counter fail !\n");
            return SAI_NULL_OBJECT_ID;
        }        
        free(attr_list);
        return acl_counter_id;
    }

    sai_thrift_status_t sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
    {
        sai_object_id_t acl_entry = 0ULL;
        sai_acl_api_t *acl_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
	    printf("sai_thrift_remove_acl_counter\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = acl_api->remove_acl_counter(acl_counter_id);
        return status;
    }

    void sai_thrift_parse_acl_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_ACL_COUNTER_ATTR_PACKETS:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_ACL_COUNTER_ATTR_BYTES:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;                                        
                default:
                    break;
            }
        }
    } 


    sai_thrift_status_t sai_thrift_set_acl_counter_attribute(const sai_thrift_object_id_t acl_counter_id, 
                                                           const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl_api, status:%d", status);
            return status;
        }
    
        sai_thrift_parse_acl_counter_attributes(thrift_attr_list, &attr);
    
        return acl_api->set_acl_counter_attribute(acl_counter_id, &attr);
    }


    void sai_thrift_get_acl_counter_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                              const sai_thrift_object_id_t acl_counter_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr_list[5];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl_api, status:%d", status);
            return;
        }
    
        attr_list[0].id = SAI_ACL_COUNTER_ATTR_TABLE_ID;
        attr_list[1].id = SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT;
        attr_list[2].id = SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT;
        attr_list[3].id = SAI_ACL_COUNTER_ATTR_PACKETS;
        attr_list[4].id = SAI_ACL_COUNTER_ATTR_BYTES;        
        attr_count = 5;
        
        status = acl_api->get_acl_counter_attribute(acl_counter_id, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl counter attribute, status:%d", status);
            return;
        }
        
        thrift_attr.id = attr_list[0].id;
        thrift_attr.value.__set_oid(attr_list[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr_list[1].id;
        thrift_attr.value.__set_booldata(attr_list[1].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr_list[2].id;
        thrift_attr.value.__set_booldata(attr_list[2].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);

	    thrift_attr.id = attr_list[3].id;
        thrift_attr.value.__set_u64(attr_list[3].value.u64);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr_list[4].id;
        thrift_attr.value.__set_u64(attr_list[4].value.u64);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    return;
    }


    void sai_thrift_get_acl_range_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                              const sai_thrift_object_id_t acl_range_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr_list[3];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl_api, status:%d", status);
            return;
        }
    
        attr_list[0].id = SAI_ACL_RANGE_ATTR_TYPE;
        attr_list[1].id = SAI_ACL_RANGE_ATTR_LIMIT; 
        attr_list[2].id = SAI_ACL_RANGE_ATTR_STAGE;
        attr_count = 3;
        
        status = acl_api->get_acl_range_attribute(acl_range_id, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain acl counter attribute, status:%d", status);
            return;
        }
        
        thrift_attr.id = attr_list[0].id;
        thrift_attr.value.__set_s32(attr_list[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id = attr_list[1].id;
        thrift_attr.value.u32range.min = attr_list[1].value.u32range.min;
        thrift_attr.value.u32range.max = attr_list[1].value.u32range.max;
        thrift_attr.value.__isset.u32range=true;
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id = attr_list[2].id;
        thrift_attr.value.__set_s32(attr_list[2].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    return;
    }
                                              


    sai_thrift_object_id_t sai_thrift_create_acl_range(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        sai_object_id_t acl_range_id = 0ULL;
        sai_acl_api_t *acl_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_thrift_attribute_t attribute;

        printf("sai_thrift_create_acl_range\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }

        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();

        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;

            switch (attribute.id)
            {
                case SAI_ACL_RANGE_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;

                case SAI_ACL_RANGE_ATTR_STAGE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;

                case SAI_ACL_RANGE_ATTR_LIMIT:
                    attr_list[i].value.u32range.min = attribute.value.u32range.min;
                    attr_list[i].value.u32range.max = attribute.value.u32range.max;
                    break;

                default:
                    break;
            }
        }

        uint32_t attr_count = thrift_attr_list.size();
        status = acl_api->create_acl_range(&acl_range_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            printf("create acl range fail !\n");
        }
        free(attr_list);

        return acl_range_id;
    }

    sai_thrift_status_t sai_thrift_remove_acl_range(const sai_thrift_object_id_t acl_range_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_acl_api_t *acl_api;
        printf("sai_thrift_remove_acl_range\n");
        status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
        if (status != SAI_STATUS_SUCCESS)
        {
          return status;
        }
        status = acl_api->remove_acl_range(acl_range_id);
        if (status != SAI_STATUS_SUCCESS)
        {
          printf("remove acl range fail !\n");
        }
        return status;
    }

    void sai_thrift_parse_hash_attributes(const std::vector < sai_thrift_attribute_t > &thrift_attr_list, 
                                          sai_attribute_t *attr_list, sai_int32_t **buffer_profile_list1, 
                                          sai_object_id_t **buffer_profile_list2)
    {
        std::vector < sai_thrift_attribute_t > ::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST:
                    {
                        *buffer_profile_list1 = (int32_t *) malloc(sizeof(int32_t) * attribute.value.s32list.count);
                        std::vector<sai_int32_t>::const_iterator it2 = attribute.value.s32list.s32list.begin();
                        for (uint32_t j = 0; j < attribute.value.s32list.s32list.size(); j++, *it2++)
                        {
                            (*buffer_profile_list1)[j] = (sai_int32_t) *it2;
                        }
                        attr_list[i].value.s32list.count = attribute.value.s32list.count;
                        attr_list[i].value.s32list.list = *buffer_profile_list1;
                        break;
                    }
                case SAI_HASH_ATTR_UDF_GROUP_LIST:
                    {
                        *buffer_profile_list2 = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * attribute.value.objlist.count);
                        std::vector < sai_thrift_object_id_t > ::const_iterator it2 = attribute.value.objlist.object_id_list.begin();
                        for (uint32_t j = 0; j < attribute.value.objlist.object_id_list.size(); j++, *it2++)
                        {
                            (*buffer_profile_list2)[j] = (sai_object_id_t) *it2;
                        }
                        attr_list[i].value.objlist.count = attribute.value.objlist.count;
                        attr_list[i].value.objlist.list = *buffer_profile_list2;
                        break;
                    }
                default:
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_hash(const std::vector < sai_thrift_attribute_t > & thrift_attr_list)
    {
        printf("sai_thrift_create_hash\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hash_api_t *hash_api;
        sai_object_id_t hash_id = 0;
        status = sai_api_query(SAI_API_HASH, (void **) &hash_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_int32_t     *buffer_profile_list1 = NULL;
        sai_object_id_t *buffer_profile_list2 = NULL;
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_hash_attributes(thrift_attr_list, attr_list, &buffer_profile_list1, &buffer_profile_list2);
        uint32_t attr_count = thrift_attr_list.size();
        status = hash_api->create_hash(&hash_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to create hash, status:%d", status);
        }
    
        if (buffer_profile_list1)
        {
            free(buffer_profile_list1);
        }
        if (buffer_profile_list2)
        {
            free(buffer_profile_list2);
        }
        free(attr_list);
    
        return hash_id;
    }

    sai_thrift_status_t sai_thrift_remove_hash(const sai_thrift_object_id_t hash_id)
    {
        printf("sai_thrift_remove_hash\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hash_api_t *hash_api;
        status = sai_api_query(SAI_API_HASH, (void **) &hash_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = hash_api->remove_hash((sai_object_id_t) hash_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove hash.");
        }
        return status;
    }
    
    sai_thrift_status_t sai_thrift_set_hash_attribute(const sai_thrift_object_id_t hash_id, const sai_thrift_attribute_t &thrift_attr)
    {
        printf("sai_thrift_set_hash_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hash_api_t *hash_api;
        status = sai_api_query(SAI_API_HASH, (void **) &hash_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_int32_t     *buffer_profile_list1 = NULL;
        sai_object_id_t *buffer_profile_list2 = NULL;
        std::vector < sai_thrift_attribute_t > thrift_attr_list;
        thrift_attr_list.push_back(thrift_attr);
        sai_attribute_t attr;
        sai_thrift_parse_hash_attributes(thrift_attr_list, &attr, &buffer_profile_list1, &buffer_profile_list2);
        status = hash_api->set_hash_attribute((sai_object_id_t)hash_id, &attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set hash attributes, status:%d", status);
        }
        if (buffer_profile_list1)
        {
            free(buffer_profile_list1);
        }
        if (buffer_profile_list2)
        {
            free(buffer_profile_list2);
        }
        return status;
    }

    void sai_thrift_get_hash_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t hash_id)
    {
        printf("sai_thrift_get_hash_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hash_api_t *hash_api;
        sai_attribute_t sai_attrs[SAI_HASH_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint8_t loop_i = 0;
        status = sai_api_query(SAI_API_HASH, (void **) &hash_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
    
        for (loop_i = SAI_HASH_ATTR_START; loop_i < SAI_HASH_ATTR_END; loop_i++)
        {
            sai_attrs[loop_i].id = loop_i;
        }
        sai_attrs[SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST].id = SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST;
        sai_attrs[SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * (SAI_NATIVE_HASH_FIELD_IN_PORT + 1));
        sai_attrs[SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST].value.s32list.count = SAI_NATIVE_HASH_FIELD_IN_PORT + 1;
    
        sai_attrs[SAI_HASH_ATTR_UDF_GROUP_LIST].id = SAI_HASH_ATTR_UDF_GROUP_LIST;
        sai_attrs[SAI_HASH_ATTR_UDF_GROUP_LIST].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 16);
        sai_attrs[SAI_HASH_ATTR_UDF_GROUP_LIST].value.objlist.count = 16;
    
        status = hash_api->get_hash_attribute(hash_id, SAI_HASH_ATTR_END, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get hash attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        thrift_attr.id        = sai_attrs[0].id;  /* SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST */
        thrift_attr.value.s32list.count = sai_attrs[0].value.s32list.count;
        std::vector < sai_int32_t > & hash_field_list = thrift_attr.value.s32list.s32list;
        for (int index = 0; index < sai_attrs[0].value.s32list.count; index++)
        {
            hash_field_list.push_back((sai_int32_t) sai_attrs[0].value.s32list.list[index]);
        }
        thrift_attr.value.__isset.s32list = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[1].id;  /* SAI_HASH_ATTR_UDF_GROUP_LIST */
        thrift_attr.value.objlist.count = sai_attrs[1].value.objlist.count;
        std::vector < sai_thrift_object_id_t > & udf_group_list = thrift_attr.value.objlist.object_id_list;
        for (int index = 0; index < sai_attrs[1].value.objlist.count; index++)
        {
            udf_group_list.push_back((sai_thrift_object_id_t) sai_attrs[1].value.objlist.list[index]);
        }
        thrift_attr.value.__isset.objlist = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        if (sai_attrs[SAI_HASH_ATTR_UDF_GROUP_LIST].value.objlist.list)
        {
            free(sai_attrs[SAI_HASH_ATTR_UDF_GROUP_LIST].value.objlist.list);
        }
        if (sai_attrs[SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST].value.s32list.list)
        {
            free(sai_attrs[SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST].value.s32list.list);
        }
    }

    void sai_thrift_parse_udf_group_attributes(const std::vector < sai_thrift_attribute_t > &thrift_attr_list, 
                                               sai_attribute_t *attr_list, 
                                               sai_object_id_t **buffer_profile_list1)
    {
        std::vector < sai_thrift_attribute_t > ::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_UDF_GROUP_ATTR_UDF_LIST: /* @flags READ_ONLY */
                    {
                        *buffer_profile_list1 = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * attribute.value.objlist.count);
                        std::vector < sai_thrift_object_id_t > ::const_iterator it2 = attribute.value.objlist.object_id_list.begin();
                        for (uint32_t j = 0; j < attribute.value.objlist.object_id_list.size(); j++, *it2++)
                        {
                            (*buffer_profile_list1)[j] = (sai_object_id_t) *it2;
                        }
                        attr_list[i].value.objlist.count = attribute.value.objlist.count;
                        attr_list[i].value.objlist.list = *buffer_profile_list1;
                        break;
                    }
                case SAI_UDF_GROUP_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_UDF_GROUP_ATTR_LENGTH:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                default:
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_udf_group(const std::vector < sai_thrift_attribute_t > & thrift_attr_list)
    {
        printf("sai_thrift_create_udf_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_udf_api_t *udf_api;
        sai_object_id_t udf_grp_id = 0;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_object_id_t     *buffer_profile_list1 = NULL;
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_udf_group_attributes(thrift_attr_list, attr_list, &buffer_profile_list1);
        uint32_t attr_count = thrift_attr_list.size();
        status = udf_api->create_udf_group(&udf_grp_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to create udf group, status:%d", status);
        }
        if (buffer_profile_list1)
        {
            free(buffer_profile_list1);
        }
        free(attr_list);
    
        return udf_grp_id;
    }

    sai_thrift_status_t sai_thrift_remove_udf_group(const sai_thrift_object_id_t udf_group_id)
    {
        printf("sai_thrift_remove_udf_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_udf_api_t *udf_api;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = udf_api->remove_udf_group((sai_object_id_t) udf_group_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove udf group.");
        }
        return status;
    }

    void sai_thrift_get_udf_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t udf_group_id)
    {
        printf("sai_thrift_get_udf_group_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_udf_api_t *udf_api;
        sai_attribute_t sai_attrs[SAI_UDF_GROUP_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint8_t loop_i = 0;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
    
        for (loop_i = SAI_UDF_GROUP_ATTR_START; loop_i < SAI_UDF_GROUP_ATTR_END; loop_i++)
        {
            sai_attrs[loop_i].id = loop_i;
        }
    
        sai_attrs[SAI_UDF_GROUP_ATTR_UDF_LIST].id = SAI_UDF_GROUP_ATTR_UDF_LIST;
        sai_attrs[SAI_UDF_GROUP_ATTR_UDF_LIST].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 4);
        sai_attrs[SAI_UDF_GROUP_ATTR_UDF_LIST].value.objlist.count = 4;
    
        status = udf_api->get_udf_group_attribute(udf_group_id, SAI_UDF_GROUP_ATTR_END, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get udf group attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        thrift_attr.id        = sai_attrs[0].id;  /* SAI_UDF_GROUP_ATTR_UDF_LIST */
        thrift_attr.value.objlist.count = sai_attrs[0].value.objlist.count;
        std::vector < sai_thrift_object_id_t > & udf_list = thrift_attr.value.objlist.object_id_list;
        for (int index = 0; index < sai_attrs[0].value.objlist.count; index++)
        {
            udf_list.push_back((sai_thrift_object_id_t) sai_attrs[0].value.objlist.list[index]);
        }
        thrift_attr.value.__isset.objlist = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[1].id;   /* SAI_UDF_GROUP_ATTR_TYPE */
        thrift_attr.value.__set_s32(sai_attrs[1].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[2].id;   /* SAI_UDF_GROUP_ATTR_LENGTH */
        thrift_attr.value.__set_u16(sai_attrs[2].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        if (sai_attrs[SAI_UDF_GROUP_ATTR_UDF_LIST].value.objlist.list)
        {
            free(sai_attrs[SAI_UDF_GROUP_ATTR_UDF_LIST].value.objlist.list);
        }
    
    }

    void sai_thrift_parse_udf_match_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector < sai_thrift_attribute_t > ::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_UDF_MATCH_ATTR_L2_TYPE:
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_UDF_MATCH_ATTR_L3_TYPE:
                    attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                    attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                    break;
                case SAI_UDF_MATCH_ATTR_GRE_TYPE:
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_UDF_MATCH_ATTR_CUSTOM_L4_SRC_PORT:
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_UDF_MATCH_ATTR_CUSTOM_L4_DST_PORT:
                    attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                    attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                    break;
                case SAI_UDF_MATCH_ATTR_CUSTOM_MPLS_LABEL_NUM:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_UDF_MATCH_ATTR_PRIORITY:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                default:
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_udf_match(const std::vector < sai_thrift_attribute_t > & thrift_attr_list)
    {
        printf("sai_thrift_create_udf_match\n");
        sai_object_id_t udf_match_id = 0;
        sai_udf_api_t *udf_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_udf_match_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = udf_api->create_udf_match(&udf_match_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to create udf match, status:%d", status);
        }
        free(attr_list);
        return udf_match_id;
    }
    
    sai_thrift_status_t sai_thrift_remove_udf_match(const sai_thrift_object_id_t udf_match_id)
    {
        printf("sai_thrift_remove_udf_match\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_udf_api_t *udf_api;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = udf_api->remove_udf_match((sai_object_id_t) udf_match_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove udf match.");
        }
        return status;
    }

    void sai_thrift_get_udf_match_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t udf_match_id)
    {
        printf("sai_thrift_get_udf_match_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_udf_api_t *udf_api;
        sai_attribute_t sai_attrs[7];
        sai_thrift_attribute_t thrift_attr;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }

        sai_attrs[0].id = SAI_UDF_MATCH_ATTR_L2_TYPE;
        sai_attrs[1].id = SAI_UDF_MATCH_ATTR_L3_TYPE;
        sai_attrs[2].id = SAI_UDF_MATCH_ATTR_GRE_TYPE;
        sai_attrs[3].id = SAI_UDF_MATCH_ATTR_PRIORITY;
        sai_attrs[4].id = SAI_UDF_MATCH_ATTR_CUSTOM_MPLS_LABEL_NUM;
        sai_attrs[5].id = SAI_UDF_MATCH_ATTR_CUSTOM_L4_SRC_PORT;
        sai_attrs[6].id = SAI_UDF_MATCH_ATTR_CUSTOM_L4_DST_PORT;

        status = udf_api->get_udf_match_attribute(udf_match_id, 7, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get udf match attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        thrift_attr.id        = sai_attrs[0].id;   /* SAI_UDF_MATCH_ATTR_L2_TYPE */
        thrift_attr.value.aclfield.data.u16 = sai_attrs[0].value.aclfield.data.u16;
        thrift_attr.value.aclfield.mask.u16 = sai_attrs[0].value.aclfield.mask.u16;
        thrift_attr.value.__isset.aclfield = true;
        thrift_attr.value.aclfield.data.__isset.u16 = true;
        thrift_attr.value.aclfield.mask.__isset.u16 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[1].id;  /* SAI_UDF_MATCH_ATTR_L3_TYPE */
        thrift_attr.value.aclfield.data.u8 = sai_attrs[1].value.aclfield.data.u8;
        thrift_attr.value.aclfield.mask.u8 = sai_attrs[1].value.aclfield.mask.u8;
        thrift_attr.value.__isset.aclfield = true;
        thrift_attr.value.aclfield.data.__isset.u8 = true;
        thrift_attr.value.aclfield.mask.__isset.u8 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = sai_attrs[2].id;  /* SAI_UDF_MATCH_ATTR_GRE_TYPE */
        thrift_attr.value.aclfield.data.u16 = sai_attrs[2].value.aclfield.data.u16;
        thrift_attr.value.aclfield.mask.u16 = sai_attrs[2].value.aclfield.mask.u16;
        thrift_attr.value.__isset.aclfield = true;
        thrift_attr.value.aclfield.data.__isset.u16 = true;
        thrift_attr.value.aclfield.mask.__isset.u16 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = sai_attrs[3].id;  /* SAI_UDF_MATCH_ATTR_PRIORITY */
        thrift_attr.value.__set_u8(sai_attrs[3].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = sai_attrs[4].id;  /* SAI_UDF_MATCH_ATTR_CUSTOM_MPLS_LABEL_NUM */
        thrift_attr.value.__set_u8(sai_attrs[4].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = sai_attrs[5].id;  /* SAI_UDF_MATCH_ATTR_CUSTOM_L4_SRC_PORT */
        thrift_attr.value.aclfield.data.u16 = sai_attrs[5].value.aclfield.data.u16;
        thrift_attr.value.aclfield.mask.u16 = sai_attrs[5].value.aclfield.mask.u16;
        thrift_attr.value.__isset.aclfield = true;
        thrift_attr.value.aclfield.data.__isset.u16 = true;
        thrift_attr.value.aclfield.mask.__isset.u16 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = sai_attrs[6].id;  /* SAI_UDF_MATCH_ATTR_CUSTOM_L4_DST_PORT */
        thrift_attr.value.aclfield.data.u16 = sai_attrs[6].value.aclfield.data.u16;
        thrift_attr.value.aclfield.mask.u16 = sai_attrs[6].value.aclfield.mask.u16;
        thrift_attr.value.__isset.aclfield = true;
        thrift_attr.value.aclfield.data.__isset.u16 = true;
        thrift_attr.value.aclfield.mask.__isset.u16 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    void sai_thrift_parse_udf_attributes(const std::vector < sai_thrift_attribute_t > &thrift_attr_list, 
                                         sai_attribute_t *attr_list, 
                                         sai_uint8_t **buffer_profile_list1)
    {
        std::vector < sai_thrift_attribute_t > ::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_UDF_ATTR_MATCH_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_UDF_ATTR_GROUP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_UDF_ATTR_BASE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_UDF_ATTR_OFFSET:
                    attr_list[i].value.u16 = attribute.value.u16 ;
                    break;
                case SAI_UDF_ATTR_HASH_MASK:
                    {
                        *buffer_profile_list1 = (sai_uint8_t *) malloc(sizeof(sai_uint8_t) * attribute.value.u8list.count);
                        std::vector <sai_int8_t> ::const_iterator it2 = attribute.value.u8list.u8list.begin();
                        for (uint32_t j = 0; j < attribute.value.u8list.u8list.size(); j++, *it2++)
                        {
                            (*buffer_profile_list1)[j] = (sai_uint8_t) *it2;
                        }
                        attr_list[i].value.u8list.count = attribute.value.u8list.count;
                        attr_list[i].value.u8list.list = *buffer_profile_list1;
                        break;
                    }
                default:
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_udf(const std::vector < sai_thrift_attribute_t > & thrift_attr_list)
    {
        printf("sai_thrift_create_udf\n");
        sai_object_id_t udf_id = 0;
        sai_udf_api_t *udf_api;
        sai_status_t status = SAI_STATUS_SUCCESS;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        sai_uint8_t     *buffer_profile_list1 = NULL;
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_udf_attributes(thrift_attr_list, attr_list, &buffer_profile_list1);
        uint32_t attr_count = thrift_attr_list.size();
        status = udf_api->create_udf(&udf_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to create udf, status:%d", status);
        }
        free(attr_list);
        if (buffer_profile_list1)
        {
            free(buffer_profile_list1);
        }
        return udf_id;
    }

    sai_thrift_status_t sai_thrift_remove_udf(const sai_thrift_object_id_t udf_id)
    {
        printf("sai_thrift_remove_udf\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_udf_api_t *udf_api;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = udf_api->remove_udf((sai_object_id_t) udf_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove udf, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_set_udf_attribute(const sai_thrift_object_id_t udf_id, const sai_thrift_attribute_t &thrift_attr)
    {
        printf("sai_thrift_set_udf\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_udf_api_t *udf_api;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }

        sai_uint8_t     *buffer_profile_list1 = NULL;
        std::vector < sai_thrift_attribute_t > thrift_attr_list;
        thrift_attr_list.push_back(thrift_attr);
        sai_attribute_t attr;
        sai_thrift_parse_udf_attributes(thrift_attr_list, &attr, &buffer_profile_list1);
        status = udf_api->set_udf_attribute((sai_object_id_t)udf_id, &attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set udf attributes, status:%d", status);
        }
        if (buffer_profile_list1)
        {
            free(buffer_profile_list1);
        }
        return status;
    }

    void sai_thrift_get_udf_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t udf_id)
    {
        printf("sai_thrift_get_udf_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_udf_api_t *udf_api;
        sai_attribute_t sai_attrs[SAI_UDF_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint8_t loop_i = 0;
        status = sai_api_query(SAI_API_UDF, (void **) &udf_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        for (loop_i = SAI_UDF_ATTR_START; loop_i < SAI_UDF_ATTR_END; loop_i++)
        {
            sai_attrs[loop_i].id = loop_i;
        }
        sai_attrs[SAI_UDF_ATTR_HASH_MASK].id = SAI_UDF_ATTR_HASH_MASK;
        sai_attrs[SAI_UDF_ATTR_HASH_MASK].value.u8list.list = (uint8_t *) malloc(sizeof(uint8_t) * 16);
        sai_attrs[SAI_UDF_ATTR_HASH_MASK].value.u8list.count = 16;

        status = udf_api->get_udf_attribute(udf_id, SAI_UDF_ATTR_END, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get udf attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        thrift_attr.id        = sai_attrs[0].id;  /* SAI_UDF_ATTR_MATCH_ID */
        thrift_attr.value.__set_oid(sai_attrs[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[1].id;  /* SAI_UDF_ATTR_GROUP_ID */
        thrift_attr.value.__set_oid(sai_attrs[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[2].id;  /* SAI_UDF_ATTR_BASE */
        thrift_attr.value.__set_u8(sai_attrs[2].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[3].id;  /* SAI_UDF_ATTR_OFFSET */
        thrift_attr.value.__set_u16(sai_attrs[3].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[4].id;  /* SAI_UDF_ATTR_HASH_MASK */
        thrift_attr.value.u8list.count = sai_attrs[4].value.u8list.count;
        std::vector < sai_int8_t > & udf_list = thrift_attr.value.u8list.u8list;
        for (int index = 0; index < sai_attrs[4].value.u8list.count; index++)
        {
            udf_list.push_back((sai_uint8_t) sai_attrs[4].value.u8list.list[index]);
        }
        thrift_attr.value.__isset.u8list = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        if (sai_attrs[SAI_UDF_ATTR_HASH_MASK].value.u8list.list)
        {
            free (sai_attrs[SAI_UDF_ATTR_HASH_MASK].value.u8list.list);
        }

    }

    void sai_thrift_parse_mirror_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                    sai_attribute_t *attr_list, 
                                                    sai_object_id_t **buffer_profile_list)
    {
        std::vector < sai_thrift_attribute_t > ::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_MIRROR_SESSION_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_MIRROR_SESSION_ATTR_MONITOR_PORT:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_MIRROR_SESSION_ATTR_MONITOR_PORTLIST:
                {
                    *buffer_profile_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * attribute.value.objlist.count);
                    std::vector<sai_thrift_object_id_t>::const_iterator it2 = attribute.value.objlist.object_id_list.begin();
                    for (uint32_t j = 0; j < attribute.value.objlist.object_id_list.size(); j++, *it2++)
                    {
                        (*buffer_profile_list)[j] = (sai_object_id_t) *it2;
                    }
                    attr_list[i].value.objlist.count = attribute.value.objlist.count;
                    attr_list[i].value.objlist.list=*buffer_profile_list;
                    break;
                }
                case SAI_MIRROR_SESSION_ATTR_MONITOR_PORTLIST_VALID:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_MIRROR_SESSION_ATTR_TRUNCATE_SIZE:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_MIRROR_SESSION_ATTR_SAMPLE_RATE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_MIRROR_SESSION_ATTR_TC:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_MIRROR_SESSION_ATTR_VLAN_TPID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_MIRROR_SESSION_ATTR_VLAN_ID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_MIRROR_SESSION_ATTR_VLAN_PRI:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_MIRROR_SESSION_ATTR_VLAN_CFI:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_MIRROR_SESSION_ATTR_VLAN_HEADER_VALID:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_MIRROR_SESSION_ATTR_ERSPAN_ENCAPSULATION_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_MIRROR_SESSION_ATTR_IPHDR_VERSION:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_MIRROR_SESSION_ATTR_TOS:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_MIRROR_SESSION_ATTR_TTL:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_MIRROR_SESSION_ATTR_SRC_IP_ADDRESS:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                case SAI_MIRROR_SESSION_ATTR_DST_IP_ADDRESS:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                case SAI_MIRROR_SESSION_ATTR_SRC_MAC_ADDRESS:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
                case SAI_MIRROR_SESSION_ATTR_DST_MAC_ADDRESS:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
                case SAI_MIRROR_SESSION_ATTR_GRE_PROTOCOL_TYPE:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                default:
                    break;
            }
        }
    }

    void sai_thrift_parse_twamp_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                   sai_attribute_t *attr_list)
    {
        std::vector < sai_thrift_attribute_t > ::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_TWAMP_SESSION_ATTR_TWAMP_PORT:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;                   
                case SAI_TWAMP_SESSION_ATTR_RECEIVE_PORT:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;                    
                case SAI_TWAMP_SESSION_ATTR_SESSION_ROLE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_UDP_SRC_PORT:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_UDP_DST_PORT:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_SRC_IP:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                case SAI_TWAMP_SESSION_ATTR_DST_IP:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                case SAI_TWAMP_SESSION_ATTR_TC:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_TWAMP_SESSION_ATTR_VPN_VIRTUAL_ROUTER:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_TWAMP_SESSION_ATTR_TWAMP_ENCAPSULATION_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_SESSION_ENABLE_TRANSMIT:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_TWAMP_SESSION_ATTR_HW_LOOKUP_VALID:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_TWAMP_SESSION_ATTR_PACKET_LENGTH:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_AUTH_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_NEXT_HOP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_TWAMP_SESSION_ATTR_PKT_TX_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;                    
                case SAI_TWAMP_SESSION_ATTR_TX_PKT_PERIOD:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_TX_RATE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_TX_PKT_CNT:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_TWAMP_SESSION_ATTR_TX_PKT_DURATION:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
	          case SAI_TWAMP_SESSION_ATTR_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
	              break;
	          case SAI_TWAMP_SESSION_ATTR_TIMESTAMP_FORMAT:
                    attr_list[i].value.s32 = attribute.value.s32;
	              break;              
                default:
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_twamp_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_twamp_api_t *twamp_api = nullptr;
        sai_object_id_t session_id = 0;
        status = sai_api_query(SAI_API_TWAMP, (void **) &twamp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_twamp_session_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = twamp_api->create_twamp_session(&session_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to create twamp session, status:%d", status);
        }
        free (attr_list);
        return session_id;
    }

    sai_thrift_status_t sai_thrift_remove_twamp_session(const sai_thrift_object_id_t session_id)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_twamp_api_t *twamp_api = nullptr;
        status = sai_api_query(SAI_API_TWAMP, (void **) &twamp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = twamp_api->remove_twamp_session((sai_object_id_t) session_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove twamp session.");
        }
        return status;
    }
    
    sai_thrift_status_t sai_thrift_set_twamp_attribute(const sai_thrift_object_id_t twamp_session_id, const sai_thrift_attribute_t &thrift_attr)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_twamp_api_t *twamp_api = nullptr;
        status = sai_api_query(SAI_API_TWAMP, (void **) &twamp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        std::vector < sai_thrift_attribute_t > thrift_attr_list;
        thrift_attr_list.push_back(thrift_attr);
    
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = 1;
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_twamp_session_attributes(thrift_attr_list, attr_list);
        status = twamp_api->set_twamp_session_attribute((sai_object_id_t)twamp_session_id, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set twamp attributes.");
        }
        return status;
    }

    void sai_thrift_get_twamp_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t twamp_session_id)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_twamp_api_t *twamp_api = nullptr;
        sai_attribute_t attr[SAI_TWAMP_SESSION_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint32_t i = 0;
        thrift_attr_list.attr_count = 0;
        
        SAI_THRIFT_FUNC_LOG();
              
        status = sai_api_query(SAI_API_TWAMP, (void **) &twamp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }

        memset(attr, 0, sizeof(attr));
        
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_TWAMP_PORT;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_RECEIVE_PORT;        
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_SESSION_ROLE;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_UDP_SRC_PORT;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_UDP_DST_PORT;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_SRC_IP;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_DST_IP;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_TC;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_VPN_VIRTUAL_ROUTER;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_TWAMP_ENCAPSULATION_TYPE;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_SESSION_ENABLE_TRANSMIT;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_HW_LOOKUP_VALID;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_PACKET_LENGTH;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_AUTH_MODE;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_NEXT_HOP_ID;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_PKT_TX_MODE;        
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_TX_PKT_PERIOD;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_TX_RATE;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_TX_PKT_CNT;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_TX_PKT_DURATION;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_MODE;
        attr[i++].id = SAI_TWAMP_SESSION_ATTR_TIMESTAMP_FORMAT;
      
        status = twamp_api->get_twamp_session_attribute(twamp_session_id, i, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get twamp attr, status:%d", status);
            return;
        }

        i = 0;
        
        thrift_attr.id = attr[i].id;
        thrift_attr.value.__set_oid(attr[i].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
        
        thrift_attr.id = attr[i].id;
        thrift_attr.value.__set_oid(attr[i].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_s32(attr[i].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_u32(attr[i].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;

        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_u32(attr[i].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;


        
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.ipaddr.addr_family = attr[i].value.ipaddr.addr_family;
        if (SAI_IP_ADDR_FAMILY_IPV4 == thrift_attr.value.ipaddr.addr_family)
        {
            thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(attr[i].value.ipaddr.addr.ip4);
            thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
        }
        else
        {
            thrift_attr.value.ipaddr.addr.ip6 = sai_thrift_v6_ip_to_string(attr[i].value.ipaddr.addr.ip6);
            thrift_attr.value.ipaddr.addr.__isset.ip6 = true;        
        }
        
        thrift_attr.value.__isset.ipaddr = true;
        thrift_attr.value.ipaddr.__isset.addr_family = true;
        thrift_attr.value.ipaddr.__isset.addr = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;

        
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.ipaddr.addr_family = attr[i].value.ipaddr.addr_family;
        if (SAI_IP_ADDR_FAMILY_IPV4 == thrift_attr.value.ipaddr.addr_family)
        {
            thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(attr[i].value.ipaddr.addr.ip4);
            thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
        }
        else
        {
            thrift_attr.value.ipaddr.addr.ip6 = sai_thrift_v6_ip_to_string(attr[i].value.ipaddr.addr.ip6);
            thrift_attr.value.ipaddr.addr.__isset.ip6 = true;           
        }
        
        thrift_attr.value.__isset.ipaddr = true;
        thrift_attr.value.ipaddr.__isset.addr_family = true;
        thrift_attr.value.ipaddr.__isset.addr = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_u8(attr[i].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_oid(attr[i].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_s32(attr[i].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_booldata(attr[i].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_booldata(attr[i].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_u32(attr[i].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_s32(attr[i].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
                        
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_oid(attr[i].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_s32(attr[i].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_u32(attr[i].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_u32(attr[i].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_u32(attr[i].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;
            
        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_u32(attr[i].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;

        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_s32(attr[i].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        i++;

        thrift_attr.id        = attr[i].id;
        thrift_attr.value.__set_s32(attr[i].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        
    }


    void sai_thrift_get_twamp_session_stats(std::vector<int64_t> &thrift_counters,
                                   const sai_thrift_object_id_t twamp_id,
                                   const std::vector<sai_thrift_twamp_stat_counter_t> &thrift_counter_ids,
                                   const int32_t number_of_counters)
    {
        printf("sai_thrift_get_twamp_session_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_twamp_api_t *twamp_api;
        status = sai_api_query(SAI_API_TWAMP, (void **) &twamp_api);

        if (status != SAI_STATUS_SUCCESS) { return; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(_sai_twamp_session_stats_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        { counter_ids[i] = (_sai_twamp_session_stats_t) *it; }

        status = twamp_api->get_twamp_session_stats(twamp_id,
                                          number_of_counters,
                                          counter_ids,
                                          counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) { thrift_counters.push_back(counters[i]); }

        free(counter_ids);
        free(counters);

        return;
    }


    sai_thrift_status_t sai_thrift_clear_twamp_session_stats(const sai_thrift_object_id_t twamp_id,
                                                    const std::vector<sai_thrift_twamp_stat_counter_t> &thrift_counter_ids,
                                                    int32_t number_of_counters)
    {
        printf("sai_thrift_clear_twamp_session_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_twamp_api_t *twamp_api;
        status = sai_api_query(SAI_API_TWAMP, (void **) &twamp_api);

        if (status != SAI_STATUS_SUCCESS) { return status; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(_sai_twamp_session_stats_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        memset(counter_ids, 0, sizeof(_sai_twamp_session_stats_t) * thrift_counter_ids.size());
        memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (_sai_twamp_session_stats_t) *it;
        }

        status = twamp_api->clear_twamp_session_stats(twamp_id,
                                          number_of_counters,
                                          counter_ids);

        free(counter_ids);
        free(counters);

        return status;
    }


    sai_thrift_object_id_t sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_mirror_session\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mirror_api_t *mirror_api;
        sai_object_id_t session_id = 0;
        sai_object_id_t *buffer_profile_list = NULL;
        status = sai_api_query(SAI_API_MIRROR, (void **) &mirror_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_mirror_session_attributes(thrift_attr_list, attr_list, &buffer_profile_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = mirror_api->create_mirror_session(&session_id, gSwitchId, attr_count, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to create mirror session, status:%d", status);
        }
        free (attr_list);
        return session_id;
    }

    sai_thrift_status_t sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
    {
        printf("sai_thrift_remove_mirror_session\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mirror_api_t *mirror_api;
        status = sai_api_query(SAI_API_MIRROR, (void **) &mirror_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = mirror_api->remove_mirror_session((sai_object_id_t) session_id);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove mirror session.");
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_set_mirror_attribute(const sai_thrift_object_id_t mirror_id, const sai_thrift_attribute_t &thrift_attr)
    {
        printf("sai_thrift_set_mirror\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mirror_api_t *mirror_api;
        sai_object_id_t *buffer_profile_list = NULL;
        status = sai_api_query(SAI_API_MIRROR, (void **) &mirror_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
    
        std::vector < sai_thrift_attribute_t > thrift_attr_list;
        thrift_attr_list.push_back(thrift_attr);
    
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = 1;
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_mirror_session_attributes(thrift_attr_list, attr_list, &buffer_profile_list);
        status = mirror_api->set_mirror_session_attribute((sai_object_id_t)mirror_id, attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set mirror attributes.");
        }
        return status;
    }

   void sai_thrift_get_mirror_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t mirror_id)
   {
        printf("sai_thrift_get_mirror_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mirror_api_t *mirror_api;
        sai_attribute_t sai_attrs[SAI_MIRROR_SESSION_ATTR_END];
        int array_index = 0;
        sai_thrift_attribute_t thrift_attr;
        int attribute_i = 0;
        int skip_portlist = 0;
        
        memset(sai_attrs, 0, sizeof(sai_attrs));
        status = sai_api_query(SAI_API_MIRROR, (void **) &mirror_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        sai_attrs[0].id = SAI_MIRROR_SESSION_ATTR_MONITOR_PORTLIST_VALID;
        status = mirror_api->get_mirror_session_attribute(mirror_id, 1, sai_attrs);
        if (!sai_attrs[0].value.booldata)
        {
            skip_portlist = 1;
        }
        
        /* SAI_MIRROR_SESSION_ATTR_TC NOT SUPPORT, trunk:sai1.3 SAI_MIRROR_SESSION_ATTR_SAMPLE_RATE new add */
        /* SAI_MIRROR_SESSION_ATTR_MONITOR_PORTLIST_VALID == 0, skip SAI_MIRROR_SESSION_ATTR_MONITOR_PORTLIST */
        if(skip_portlist)
        {
        for (attribute_i = SAI_MIRROR_SESSION_ATTR_START; attribute_i < SAI_MIRROR_SESSION_ATTR_END; attribute_i++)
        {
            if ((SAI_MIRROR_SESSION_ATTR_TC == attribute_i) || (SAI_MIRROR_SESSION_ATTR_POLICER == attribute_i)
              || (SAI_MIRROR_SESSION_ATTR_MONITOR_PORTLIST == attribute_i))
            {
                continue;
            }
            sai_attrs[array_index++].id = attribute_i;
        }

        status = mirror_api->get_mirror_session_attribute(mirror_id, array_index, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get mirror attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        thrift_attr.id        = sai_attrs[0].id;
        thrift_attr.value.__set_s32(sai_attrs[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[1].id;
        thrift_attr.value.__set_oid(sai_attrs[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[2].id;
        thrift_attr.value.__set_u16(sai_attrs[2].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[3].id;
        thrift_attr.value.__set_u32(sai_attrs[3].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);  /* trunk:sai1.3 SAI_MIRROR_SESSION_ATTR_SAMPLE_RATE new add */
        
        
        thrift_attr.id        = sai_attrs[4].id;
        thrift_attr.value.__set_s32(sai_attrs[4].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr); /* trunk:sai1.3 SAI_MIRROR_SESSION_ATTR_CONGESTION_MODE new add */
        
        thrift_attr.id        = sai_attrs[5].id;
        thrift_attr.value.__set_u16(sai_attrs[5].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[6].id;
        thrift_attr.value.__set_u16(sai_attrs[6].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[7].id;
        thrift_attr.value.__set_u8(sai_attrs[7].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[8].id;
        thrift_attr.value.__set_u8(sai_attrs[8].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[9].id;
        thrift_attr.value.__set_booldata(sai_attrs[9].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[10].id;
        thrift_attr.value.__set_s32(sai_attrs[10].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[11].id;
        thrift_attr.value.__set_u8(sai_attrs[11].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[12].id;
        thrift_attr.value.__set_u8(sai_attrs[12].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[13].id;
        thrift_attr.value.__set_u8(sai_attrs[13].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[14].id;
        thrift_attr.value.ipaddr.addr_family = sai_attrs[14].value.ipaddr.addr_family;
        if (SAI_IP_ADDR_FAMILY_IPV4 == thrift_attr.value.ipaddr.addr_family)
        {
            thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(sai_attrs[14].value.ipaddr.addr.ip4);
        }
        else
        {
        
        }
        thrift_attr.value.__isset.ipaddr = true;
        thrift_attr.value.ipaddr.__isset.addr_family = true;
        thrift_attr.value.ipaddr.__isset.addr = true;
        thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[15].id;
        thrift_attr.value.ipaddr.addr_family = sai_attrs[15].value.ipaddr.addr_family;
        if (SAI_IP_ADDR_FAMILY_IPV4 == thrift_attr.value.ipaddr.addr_family)
        {
            thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(sai_attrs[15].value.ipaddr.addr.ip4);
        }
        else
        {
        
        }
        thrift_attr.value.__isset.ipaddr = true;
        thrift_attr.value.ipaddr.__isset.addr_family = true;
        thrift_attr.value.ipaddr.__isset.addr = true;
        thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[16].id;
        thrift_attr.value.mac = sai_thrift_mac_to_string(sai_attrs[16].value.mac);
        thrift_attr.value.__isset.mac = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[17].id;
        thrift_attr.value.mac = sai_thrift_mac_to_string(sai_attrs[17].value.mac);
        thrift_attr.value.__isset.mac = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[18].id;
        thrift_attr.value.__set_u16(sai_attrs[18].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = sai_attrs[19].id;
        thrift_attr.value.__set_u16(sai_attrs[19].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        }
        else
        {
            for (attribute_i = SAI_MIRROR_SESSION_ATTR_START; attribute_i < SAI_MIRROR_SESSION_ATTR_END; attribute_i++)
            {
                if (((SAI_MIRROR_SESSION_ATTR_TC == attribute_i) || (SAI_MIRROR_SESSION_ATTR_POLICER == attribute_i))
                  || (SAI_MIRROR_SESSION_ATTR_MONITOR_PORT == attribute_i))
                {
                    continue;
                }
                sai_attrs[array_index++].id = attribute_i;
                
            }
            array_index--;
            sai_attrs[array_index].value.objlist.count = 64;
            sai_attrs[array_index].value.objlist.list = (sai_object_id_t*)malloc(sai_attrs[array_index].value.objlist.count * sizeof(sai_object_id_t));
            array_index++;
            status = mirror_api->get_mirror_session_attribute(mirror_id, array_index, sai_attrs);
            if (status != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("Failed to get mirror attributes, status:%d", status);
                thrift_attr_list.status = status;
                return;
            }
            
            thrift_attr.id        = sai_attrs[0].id;
            thrift_attr.value.__set_s32(sai_attrs[0].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[1].id;
            thrift_attr.value.__set_u16(sai_attrs[1].value.u16);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[2].id;
            thrift_attr.value.__set_u32(sai_attrs[2].value.u32);
            thrift_attr_list.attr_list.push_back(thrift_attr);  /* trunk:sai1.3 SAI_MIRROR_SESSION_ATTR_SAMPLE_RATE new add */
            
            
            thrift_attr.id        = sai_attrs[3].id;
            thrift_attr.value.__set_s32(sai_attrs[3].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr); /* trunk:sai1.3 SAI_MIRROR_SESSION_ATTR_CONGESTION_MODE new add */
            
            thrift_attr.id        = sai_attrs[4].id;
            thrift_attr.value.__set_u16(sai_attrs[4].value.u16);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[5].id;
            thrift_attr.value.__set_u16(sai_attrs[5].value.u16);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[6].id;
            thrift_attr.value.__set_u8(sai_attrs[6].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[7].id;
            thrift_attr.value.__set_u8(sai_attrs[7].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[8].id;
            thrift_attr.value.__set_booldata(sai_attrs[8].value.booldata);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[9].id;
            thrift_attr.value.__set_s32(sai_attrs[9].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[10].id;
            thrift_attr.value.__set_u8(sai_attrs[10].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[11].id;
            thrift_attr.value.__set_u8(sai_attrs[11].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[12].id;
            thrift_attr.value.__set_u8(sai_attrs[12].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[13].id;
            thrift_attr.value.ipaddr.addr_family = sai_attrs[13].value.ipaddr.addr_family;
            if (SAI_IP_ADDR_FAMILY_IPV4 == thrift_attr.value.ipaddr.addr_family)
            {
                thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(sai_attrs[13].value.ipaddr.addr.ip4);
            }
            else
            {
            
            }
            thrift_attr.value.__isset.ipaddr = true;
            thrift_attr.value.ipaddr.__isset.addr_family = true;
            thrift_attr.value.ipaddr.__isset.addr = true;
            thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[14].id;
            thrift_attr.value.ipaddr.addr_family = sai_attrs[14].value.ipaddr.addr_family;
            if (SAI_IP_ADDR_FAMILY_IPV4 == thrift_attr.value.ipaddr.addr_family)
            {
                thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(sai_attrs[14].value.ipaddr.addr.ip4);
            }
            else
            {
            
            }
            thrift_attr.value.__isset.ipaddr = true;
            thrift_attr.value.ipaddr.__isset.addr_family = true;
            thrift_attr.value.ipaddr.__isset.addr = true;
            thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[15].id;
            thrift_attr.value.mac = sai_thrift_mac_to_string(sai_attrs[15].value.mac);
            thrift_attr.value.__isset.mac = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[16].id;
            thrift_attr.value.mac = sai_thrift_mac_to_string(sai_attrs[16].value.mac);
            thrift_attr.value.__isset.mac = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[17].id;
            thrift_attr.value.__set_u16(sai_attrs[17].value.u16);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[18].id;
            thrift_attr.value.__set_booldata(sai_attrs[18].value.booldata);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            
            thrift_attr.id        = sai_attrs[19].id;
            thrift_attr.value.objlist.count = sai_attrs[19].value.objlist.count;
            for (int index = 0; index < sai_attrs[19].value.objlist.count; index++)
   	        {
   	            thrift_attr.value.objlist.object_id_list.push_back(sai_attrs[19].value.objlist.list[index]);
   	        }
            thrift_attr.value.__isset.objlist = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
        }
    }

    sai_thrift_status_t sai_thrift_create_inseg_entry(const sai_thrift_inseg_entry_t &thrift_inseg_entry, 
                                                      const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_inseg_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mpls_api_t *mpls_api;
        sai_inseg_entry_t inseg_entry;
        status = sai_api_query(SAI_API_MPLS, (void **) &mpls_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parser_inseg_entry(thrift_inseg_entry, &inseg_entry);
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parser_mpls_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = mpls_api->create_inseg_entry(&inseg_entry, attr_count, attr_list);
        free(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to sai_thrift_create_inseg_entry, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_remove_inseg_entry(const sai_thrift_inseg_entry_t &thrift_inseg_entry)
    {
        printf("sai_thrift_remove_inseg_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mpls_api_t *mpls_api;
        sai_inseg_entry_t inseg_entry;
        status = sai_api_query(SAI_API_MPLS, (void **) &mpls_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parser_inseg_entry(thrift_inseg_entry, &inseg_entry);
        status = mpls_api->remove_inseg_entry(&inseg_entry);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to sai_thrift_remove_inseg_entry, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_set_inseg_entry_attribute(const sai_thrift_inseg_entry_t &thrift_inseg_entry, 
                                                             const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_inseg_entry_attributes\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        sai_mpls_api_t *mpls_api;
        sai_inseg_entry_t inseg_entry;
        sai_attribute_t *attr_list = nullptr;
        status = sai_api_query(SAI_API_MPLS, (void **) &mpls_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_alloc_attr(attr_list, 1);
        sai_thrift_parser_inseg_entry(thrift_inseg_entry, &inseg_entry);
        sai_thrift_parser_mpls_attributes(thrift_attr_list, attr_list);
        status = mpls_api->set_inseg_entry_attribute(&inseg_entry, attr_list);
        sai_thrift_free_attr(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to sai_thrift_set_inseg_entry_attribute, status:%d", status);
        }
        return status;
    }

    void sai_thrift_get_inseg_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                              const sai_thrift_inseg_entry_t &thrift_inseg_entry)
    {
        printf("sai_thrift_get_inseg_entry_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mpls_api_t *mpls_api;
        sai_inseg_entry_t inseg_entry;
        sai_attribute_t attr[SAI_INSEG_ENTRY_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint32_t attr_cnt = 0;
    
        status = sai_api_query(SAI_API_MPLS, (void **) &mpls_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            thrift_attr_list.status = status;
            return;
        }
    
        sai_thrift_parser_inseg_entry(thrift_inseg_entry, &inseg_entry);
    
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_NUM_OF_POP;
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_PACKET_ACTION;
        /* SAI_INSEG_ENTRY_ATTR_TRAP_PRIORITY not support */
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_NEXT_HOP_ID;
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_DECAP_TUNNEL_ID;
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_PSC_TYPE;
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_QOS_TC;
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_MPLS_EXP_TO_TC_MAP;
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_MPLS_EXP_TO_COLOR_MAP;
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_POP_TTL_MODE;
        attr[attr_cnt++].id = SAI_INSEG_ENTRY_ATTR_POP_QOS_MODE;
    
        status = mpls_api->get_inseg_entry_attribute(&inseg_entry, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to sai_thrift_get_inseg_entry_attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        thrift_attr.id        = attr[0].id;                 /* SAI_INSEG_ENTRY_ATTR_NUM_OF_POP */
        thrift_attr.value.__set_u8(attr[0].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[1].id;                 /* SAI_INSEG_ENTRY_ATTR_PACKET_ACTION */
        thrift_attr.value.__set_s32(attr[1].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[2].id;                 /* SAI_INSEG_ENTRY_ATTR_NEXT_HOP_ID */
        thrift_attr.value.__set_oid(attr[2].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id        = attr[3].id;                 /* SAI_INSEG_ENTRY_ATTR_DECAP_TUNNEL_ID */
        thrift_attr.value.__set_oid(attr[3].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[4].id;                 /* SAI_INSEG_ENTRY_ATTR_PSC_TYPE */
        thrift_attr.value.__set_s32(attr[4].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[5].id;                 /* SAI_INSEG_ENTRY_ATTR_QOS_TC */
        thrift_attr.value.__set_u8(attr[5].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[6].id;                 /* SAI_INSEG_ENTRY_ATTR_MPLS_EXP_TO_TC_MAP */
        thrift_attr.value.__set_oid(attr[6].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[7].id;                 /* SAI_INSEG_ENTRY_ATTR_MPLS_EXP_TO_COLOR_MAP */
        thrift_attr.value.__set_oid(attr[7].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[8].id;                 /* SAI_INSEG_ENTRY_ATTR_POP_TTL_MODE */
        thrift_attr.value.__set_s32(attr[8].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[9].id;                 /* SAI_INSEG_ENTRY_ATTR_POP_QOS_MODE */
        thrift_attr.value.__set_s32(attr[9].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
    }

    sai_thrift_status_t sai_thrift_dump_log(const std::string& dump_file_name)
    {
        printf("sai_thrift_dump_log\n");
        
        sai_status_t status = SAI_STATUS_SUCCESS;
        char file_name[DUMP_FILE_NAME_LEN] = {0};
        
        if (dump_file_name.length() > DUMP_FILE_NAME_LEN - 1)
        {
            SAI_THRIFT_LOG_ERR("dump_file_name is longer than DUMP_FILE_NAME_LEN, dump_file_name's max length is 50 byte");
            return SAI_STATUS_INVALID_PARAMETER;
        }
        
        strcpy(file_name, dump_file_name.c_str());
        
        status = sai_dbg_generate_dump(file_name);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to sai_thrift_dump_log, status:%d", status);
            return status;
        }
        
        return status;
    }

    void sai_thrift_parse_policer_attributes(sai_attribute_t *attr_list,
                                             const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
        
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_POLICER_ATTR_METER_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_POLICER_ATTR_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_POLICER_ATTR_COLOR_SOURCE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_POLICER_ATTR_CBS:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_POLICER_ATTR_CIR:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_POLICER_ATTR_PBS:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_POLICER_ATTR_PIR:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_POLICER_ATTR_GREEN_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_POLICER_ATTR_YELLOW_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_POLICER_ATTR_RED_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_POLICER_ATTR_ENABLE_COUNTER_PACKET_ACTION_LIST:
                case SAI_POLICER_ATTR_ENABLE_COUNTER_LIST:
                {
                    int count = attribute.value.s32list.s32list.size();
                    sai_int32_t *counter_en_list = NULL;
                    std::vector<sai_int32_t>::const_iterator it = attribute.value.s32list.s32list.begin();
                    counter_en_list = (sai_int32_t*)malloc(sizeof(sai_int32_t) * count);
        
                    for (int j = 0; j < count; j++, it++)
                    {
                        *(counter_en_list + j) = (sai_int32_t)*it;
                    }
                    attr_list[i].value.s32list.list = counter_en_list;
                    attr_list[i].value.s32list.count = count;
                          
                    break;
                }
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_policer_api_t *policer_api = nullptr;
        auto status = sai_api_query(SAI_API_POLICER, reinterpret_cast<void**>(&policer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        
        sai_thrift_alloc_array(attr_list, attr_size);
        sai_thrift_parse_policer_attributes(attr_list, thrift_attr_list);
        
        sai_object_id_t policer_oid = 0;
        status = policer_api->create_policer(&policer_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_array(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return policer_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_policer_api_t *policer_api = nullptr;
        auto status = sai_api_query(SAI_API_POLICER, reinterpret_cast<void**>(&policer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        status = policer_api->remove_policer(thrift_policer_id);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to remove OID.");
        
        return status;
    }

    void sai_thrift_get_policer_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t thrift_policer_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_policer_api_t *policer_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[11];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_POLICER, (void **) &policer_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain policer_api, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        attr[0].id = SAI_POLICER_ATTR_METER_TYPE;
        attr[1].id = SAI_POLICER_ATTR_MODE;
	    attr[2].id = SAI_POLICER_ATTR_COLOR_SOURCE;
	    attr[3].id = SAI_POLICER_ATTR_CBS;
        attr[4].id = SAI_POLICER_ATTR_CIR;
	    attr[5].id = SAI_POLICER_ATTR_PBS;
	    attr[6].id = SAI_POLICER_ATTR_PIR;
        attr[7].id = SAI_POLICER_ATTR_GREEN_PACKET_ACTION;
	    attr[8].id = SAI_POLICER_ATTR_YELLOW_PACKET_ACTION;
	    attr[9].id = SAI_POLICER_ATTR_RED_PACKET_ACTION;
        
        attr[10].id = SAI_POLICER_ATTR_ENABLE_COUNTER_LIST;
        attr[10].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * 3);
        attr[10].value.s32list.count = 3;
        
        attr_count = 11;
        
        status = policer_api->get_policer_attribute(thrift_policer_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get policer attr, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_s32(attr[1].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_s32(attr[2].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_u64(attr[3].value.u64);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[4].id;
	    thrift_attr.value.__set_u64(attr[4].value.u64);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[5].id;
	    thrift_attr.value.__set_u64(attr[5].value.u64);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[6].id;
	    thrift_attr.value.__set_u64(attr[6].value.u64);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
  	    thrift_attr.id = attr[7].id;
	    thrift_attr.value.__set_s32(attr[7].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[8].id;
	    thrift_attr.value.__set_s32(attr[8].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[9].id;
	    thrift_attr.value.__set_s32(attr[9].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[10].id;  /* SAI_POLICER_ATTR_ENABLE_COUNTER_LIST */
        thrift_attr.value.s32list.count = attr[10].value.s32list.count;
        std::vector < sai_int32_t > & counter_en_list = thrift_attr.value.s32list.s32list;
        for (int index = 0; index < attr[10].value.s32list.count; index++)
        {
            counter_en_list.push_back((sai_int32_t) attr[10].value.s32list.list[index]);
        }
        thrift_attr.value.__isset.s32list = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        if (attr[10].value.s32list.list)
        {
            free(attr[10].value.s32list.list);
        }
    }

    sai_thrift_status_t sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, 
                                                         const sai_thrift_attribute_t &thrift_attr) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_policer_api_t *policer_api = nullptr;
        auto status = sai_api_query(SAI_API_POLICER, reinterpret_cast<void**>(&policer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        
        sai_thrift_alloc_array(attr_list, attr_size);
        sai_thrift_parse_policer_attributes(attr_list, thrift_attr_list);
        
        status = policer_api->set_policer_attribute(thrift_policer_id, attr_list);
        sai_thrift_free_array(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    void sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> &_return, 
                                      const sai_thrift_object_id_t thrift_policer_id,
                                      const std::vector<sai_thrift_policer_stat_t> &thrift_counter_ids) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_policer_api_t *policer_api = nullptr;
        auto status = sai_api_query(SAI_API_POLICER, reinterpret_cast<void**>(&policer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get API.");
            return;
        }
        
        auto counter_ids = reinterpret_cast<const sai_stat_id_t*>(thrift_counter_ids.data());
        sai_size_t number_of_counters = thrift_counter_ids.size();
        sai_uint64_t *counters = nullptr;
        
        sai_thrift_alloc_array(counters, number_of_counters);
        
        status = policer_api->get_policer_stats(thrift_policer_id, number_of_counters, counter_ids, counters);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_DBG("Exited.");
            _return.assign(counters, counters + number_of_counters);
            sai_thrift_free_array(counters);
            return;
        }
        
        SAI_THRIFT_LOG_ERR("Failed to get statistics.");
        sai_thrift_free_array(counters);
    }

    void sai_thrift_get_policer_stats_ext(std::vector<sai_thrift_uint64_t> & _return,
                                                   const sai_thrift_object_id_t thrift_policer_id, 
                                                   const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids, 
                                                   const int8_t mode) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_policer_api_t *policer_api = nullptr;
        auto status = sai_api_query(SAI_API_POLICER, reinterpret_cast<void**>(&policer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get API.");
            return;
        }
        
        auto counter_ids = reinterpret_cast<const sai_stat_id_t*>(thrift_counter_ids.data());
        sai_size_t number_of_counters = thrift_counter_ids.size();
        sai_uint64_t *counters = nullptr;
        
        sai_thrift_alloc_array(counters, number_of_counters);
        
        status = policer_api->get_policer_stats_ext(thrift_policer_id, number_of_counters, counter_ids, (sai_stats_mode_t)mode, counters);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_DBG("Exited.");
            _return.assign(counters, counters + number_of_counters);
            sai_thrift_free_array(counters);
            return;
        }
        
        SAI_THRIFT_LOG_ERR("Failed to get statistics.");
        sai_thrift_free_array(counters);
    }


    sai_thrift_status_t sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id,
                                                       const std::vector<sai_thrift_policer_stat_t> &thrift_counter_ids) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_policer_api_t *policer_api = nullptr;
        auto status = sai_api_query(SAI_API_POLICER, reinterpret_cast<void**>(&policer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        auto counter_ids = reinterpret_cast<const sai_stat_id_t*>(thrift_counter_ids.data());
        sai_size_t number_of_counters = thrift_counter_ids.size();
        
        status = policer_api->clear_policer_stats(thrift_policer_id, number_of_counters, counter_ids);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to clear statistics.");
        
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_scheduler_profile\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_scheduler_api_t *scheduler_api;
        sai_object_id_t scheduler_id = 0;
        status = sai_api_query(SAI_API_SCHEDULER, (void **) &scheduler_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_scheduler_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        scheduler_api->create_scheduler(&scheduler_id, gSwitchId, attr_count, attr_list);
	    free (attr_list);
        return scheduler_id;
    }

    sai_thrift_status_t sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
    {
        printf("sai_thrift_remove_scheduler\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_scheduler_api_t *scheduler_api;
        status = sai_api_query(SAI_API_SCHEDULER, (void **) &scheduler_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = scheduler_api->remove_scheduler((sai_object_id_t) scheduler_id);
        return status;
    }

    void sai_thrift_parse_scheduler_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE :
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE:
                    attr_list[i].value.u64 = attribute.value.u64;
                    break;
                case SAI_SCHEDULER_ATTR_SCHEDULING_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
	    	    case SAI_SCHEDULER_ATTR_METER_TYPE:
	    	  	    attr_list[i].value.s32 = attribute.value.s32;
                    break;
            }
        }
    }

    void sai_thrift_get_scheduler_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                            const sai_thrift_object_id_t thrift_scheduler_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_scheduler_api_t *scheduler_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[10];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_SCHEDULER, (void **) &scheduler_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain scheduler_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_SCHEDULER_ATTR_SCHEDULING_TYPE;
        attr[1].id = SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT;
	    attr[2].id = SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE;
	    attr[3].id = SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE;
        attr[4].id = SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE;
	    attr[5].id = SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE;
        attr_count = 6;
        
        status = scheduler_api->get_scheduler_attribute(thrift_scheduler_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get scheduler attr, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_u8(attr[1].value.u8);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_u64(attr[2].value.u64);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_u64(attr[3].value.u64);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[4].id;
	    thrift_attr.value.__set_u64(attr[4].value.u64);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[5].id;
	    thrift_attr.value.__set_u64(attr[5].value.u64);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_set_scheduler_attribute(const sai_thrift_object_id_t thrift_scheduler_id, 
                                                           const sai_thrift_attribute_t &thrift_attr) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_scheduler_api_t *scheduler_api = nullptr;
        auto status = sai_api_query(SAI_API_SCHEDULER, reinterpret_cast<void**>(&scheduler_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        
        sai_thrift_alloc_array(attr_list, attr_size);
        sai_thrift_parse_scheduler_attributes(thrift_attr_list, attr_list);
        
        status = scheduler_api->set_scheduler_attribute(thrift_scheduler_id, attr_list);
        sai_thrift_free_array(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_scheduler_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_scheduler_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_scheduler_group_api_t *scheduler_group_api;
        sai_object_id_t scheduler_group_id = 0;
        status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **) &scheduler_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_scheduler_group_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        scheduler_group_api->create_scheduler_group(&scheduler_group_id, gSwitchId, attr_count, attr_list);
	    free (attr_list);
        return scheduler_group_id;
    }

    sai_thrift_status_t sai_thrift_remove_scheduler_group(const sai_thrift_object_id_t scheduler_group_id)
    {
        printf("sai_thrift_remove_scheduler_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_scheduler_group_api_t *scheduler_group_api;
        status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **) &scheduler_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = scheduler_group_api->remove_scheduler_group((sai_object_id_t) scheduler_group_id);
        return status;
    }

    void sai_thrift_parse_scheduler_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                     sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_SCHEDULER_GROUP_ATTR_PORT_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_SCHEDULER_GROUP_ATTR_LEVEL:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_SCHEDULER_GROUP_ATTR_MAX_CHILDS:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_SCHEDULER_GROUP_ATTR_SCHEDULER_PROFILE_ID :
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_SCHEDULER_GROUP_ATTR_PARENT_NODE:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_SCHEDULER_GROUP_ATTR_SERVICE_ID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
            }
        }
    }

    void sai_thrift_get_scheduler_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                  const sai_thrift_object_id_t scheduler_group_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_scheduler_group_api_t *scheduler_group_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[10];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **) &scheduler_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain scheduler_group_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_SCHEDULER_GROUP_ATTR_CHILD_COUNT;
        attr[1].id = SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST;
	    attr[2].id = SAI_SCHEDULER_GROUP_ATTR_PORT_ID;
	    attr[3].id = SAI_SCHEDULER_GROUP_ATTR_LEVEL;
        attr[4].id = SAI_SCHEDULER_GROUP_ATTR_MAX_CHILDS;
	    attr[5].id = SAI_SCHEDULER_GROUP_ATTR_SCHEDULER_PROFILE_ID;
	    attr[6].id = SAI_SCHEDULER_GROUP_ATTR_PARENT_NODE;
        attr[7].id = SAI_SCHEDULER_GROUP_ATTR_SERVICE_ID;
        attr_count = 8;
        
	    attr[1].value.objlist.count = 64;
	    attr[1].value.objlist.list = (sai_object_id_t*)malloc(attr[1].value.objlist.count * sizeof(sai_object_id_t));
        
        status = scheduler_group_api->get_scheduler_group_attribute(scheduler_group_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get scheduler group attr, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_u32(attr[0].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.objlist.count = attr[1].value.objlist.count;
	    for (int index = 0; index < attr[1].value.objlist.count; index++)
  	    {
            thrift_attr.value.objlist.object_id_list.push_back(attr[1].value.objlist.list[index]);
  	    }
        thrift_attr.value.__isset.objlist = true;
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_oid(attr[2].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_u8(attr[3].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[4].id;
	    thrift_attr.value.__set_u8(attr[4].value.u8);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[5].id;
	    thrift_attr.value.__set_oid(attr[5].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
  	    thrift_attr.id = attr[6].id;
	    thrift_attr.value.__set_oid(attr[6].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        thrift_attr.id = attr[7].id;
	    thrift_attr.value.__set_u16(attr[7].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    free(attr[1].value.objlist.list);
    }

    sai_thrift_status_t sai_thrift_set_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_id, 
                                                                 const sai_thrift_attribute_t &thrift_attr) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_scheduler_group_api_t *scheduler_group_api = nullptr;
        auto status = sai_api_query(SAI_API_SCHEDULER_GROUP, reinterpret_cast<void**>(&scheduler_group_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        
        sai_thrift_alloc_array(attr_list, attr_size);
        sai_thrift_parse_scheduler_group_attributes(thrift_attr_list, attr_list);
        
        status = scheduler_group_api->set_scheduler_group_attribute(scheduler_group_id, attr_list);
        sai_thrift_free_array(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    void sai_thrift_get_port_stats(std::vector<int64_t> & thrift_counters,
                                   const sai_thrift_object_id_t port_id,
                                   const std::vector<sai_thrift_port_stat_counter_t> & thrift_counter_ids,
                                   const int32_t number_of_counters)
    {
        printf("sai_thrift_get_port_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_port_api_t *port_api;
        
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
        
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_port_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_port_stat_t) *it;
        }
        
        status = port_api->get_port_stats((sai_object_id_t) port_id,
                                          number_of_counters,
                                          counter_ids,
                                          counters);
        
        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }
        
        free(counter_ids);
        free(counters);
        
        return;
    }

    void sai_thrift_get_port_stats_ext(std::vector<int64_t> & thrift_counters,
                                       const sai_thrift_object_id_t port_id,
                                       const std::vector<sai_thrift_port_stat_counter_t> & thrift_counter_ids,
                                       const int8_t mode,
                                       const int32_t number_of_counters)
    {
        printf("sai_thrift_get_port_stats_ext\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_port_api_t *port_api;

        status = sai_api_query(SAI_API_PORT, (void **) &port_api);

        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_port_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_port_stat_t) *it;
        }

        status = port_api->get_port_stats_ext((sai_object_id_t) port_id,
                                          number_of_counters,
                                          counter_ids,
                                          (sai_stats_mode_t)mode,
                                          counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }

        free(counter_ids);
        free(counters);
        return;
    }


    sai_thrift_status_t sai_thrift_clear_port_stats(const sai_thrift_object_id_t port_id,
                                                    const int32_t number_of_counters,
                                                    const std::vector<sai_thrift_port_stat_counter_t> & thrift_counter_ids)
    {
        printf("sai_thrift_clear_port_all_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_port_api_t *port_api;
        
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_port_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
              counter_ids[i] = (sai_port_stat_t) *it;
        }
        
        status = port_api->clear_port_stats( (sai_object_id_t) port_id, number_of_counters, counter_ids);
        
        free(counter_ids);
        free(counters);
        
        return status;
    }

    sai_thrift_status_t sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
    {
        printf("sai_thrift_clear_port_all_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_port_api_t *port_api;
        
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        status = port_api->clear_port_all_stats( (sai_object_id_t) port_id);
        return status;
    }

    void sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t port_id)
    {
        printf("sai_thrift_get_port_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_port_api_t *port_api;
	    std::vector<sai_thrift_attribute_t>& attr_list = thrift_attr_list.attr_list;
        status = sai_api_query(SAI_API_PORT, (void **) &port_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
	    sai_attribute_t port_type;
        sai_thrift_attribute_t thrift_port_type;
        port_type.id = SAI_PORT_ATTR_TYPE;
        port_api->get_port_attribute(port_id, 1, &port_type);
        thrift_port_type.id = SAI_PORT_ATTR_TYPE;
        thrift_port_type.value.__set_s32(port_type.value.s32);
        attr_list.push_back(thrift_port_type);
        
        sai_attribute_t port_oper_status_attribute;
        sai_thrift_attribute_t thrift_port_status;
        port_oper_status_attribute.id = SAI_PORT_ATTR_OPER_STATUS;
        port_api->get_port_attribute(port_id, 1, &port_oper_status_attribute);
        thrift_port_status.id = SAI_PORT_ATTR_OPER_STATUS;
        thrift_port_status.value.__set_s32(port_oper_status_attribute.value.s32);
        attr_list.push_back(thrift_port_status);
        
        sai_attribute_t support_breakout_mode_type;
        sai_thrift_attribute_t thrift_support_breakout_mode_type;
        support_breakout_mode_type.id = SAI_PORT_ATTR_SUPPORTED_BREAKOUT_MODE_TYPE;
        support_breakout_mode_type.value.s32list.list = (sai_int32_t *) malloc(sizeof(sai_int32_t) * 3);
        support_breakout_mode_type.value.s32list.count = 3;
        port_api->get_port_attribute(port_id, 1, &support_breakout_mode_type);
        thrift_support_breakout_mode_type.id = SAI_PORT_ATTR_SUPPORTED_BREAKOUT_MODE_TYPE;
        thrift_support_breakout_mode_type.value.s32list.count = support_breakout_mode_type.value.s32list.count;
        std::vector<sai_int32_t>& list = thrift_support_breakout_mode_type.value.s32list.s32list;
        sai_s32_list_t *list_value;
        list_value = &support_breakout_mode_type.value.s32list;
        for (int index = 0; index < support_breakout_mode_type.value.s32list.count; index++)
        {
            list.push_back((sai_int32_t)list_value->list[index]);
        }
        thrift_support_breakout_mode_type.value.__isset.s32list = true;
        attr_list.push_back(thrift_support_breakout_mode_type);
        free(support_breakout_mode_type.value.s32list.list);
        
	    sai_attribute_t current_breakout_mode_type;
        sai_thrift_attribute_t thrift_current_breakout_mode_type;
        current_breakout_mode_type.id = SAI_PORT_ATTR_CURRENT_BREAKOUT_MODE_TYPE;
        port_api->get_port_attribute(port_id, 1, &current_breakout_mode_type);
        thrift_current_breakout_mode_type.id = SAI_PORT_ATTR_CURRENT_BREAKOUT_MODE_TYPE;
        thrift_current_breakout_mode_type.value.__set_s32(current_breakout_mode_type.value.s32);
        attr_list.push_back(thrift_current_breakout_mode_type);
        
        sai_attribute_t qos_queue_num;
        sai_thrift_attribute_t thrift_qos_queue_num;
        qos_queue_num.id = SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES;
        port_api->get_port_attribute(port_id, 1, &qos_queue_num);
        thrift_qos_queue_num.id = SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES;
        thrift_qos_queue_num.value.__set_u32(qos_queue_num.value.u32);
        attr_list.push_back(thrift_qos_queue_num);
        
        sai_attribute_t queue_list;
        sai_thrift_attribute_t thrift_queue_list;
        queue_list.id = SAI_PORT_ATTR_QOS_QUEUE_LIST;
        queue_list.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * qos_queue_num.value.u32);
        queue_list.value.objlist.count = qos_queue_num.value.u32;
        port_api->get_port_attribute(port_id, 1, &queue_list);
        thrift_queue_list.id = SAI_PORT_ATTR_QOS_QUEUE_LIST;
        thrift_queue_list.value.objlist.count = qos_queue_num.value.u32;
        std::vector<sai_thrift_object_id_t>& queue_list_objlist = thrift_queue_list.value.objlist.object_id_list;
        sai_object_list_t *queue_list_object;
        queue_list_object = &queue_list.value.objlist;
        for (int index = 0; index < qos_queue_num.value.u32; index++)
        {
            queue_list_objlist.push_back((sai_thrift_object_id_t)queue_list_object->list[index]);
        }
        thrift_queue_list.value.__isset.objlist = true;
        attr_list.push_back(thrift_queue_list);
        free(queue_list.value.objlist.list);
        
        sai_attribute_t scheduler_group_num;
        sai_thrift_attribute_t thrift_scheduler_group_num;
        scheduler_group_num.id = SAI_PORT_ATTR_QOS_NUMBER_OF_SCHEDULER_GROUPS;
        port_api->get_port_attribute(port_id, 1, &scheduler_group_num);
        thrift_scheduler_group_num.id = SAI_PORT_ATTR_QOS_NUMBER_OF_SCHEDULER_GROUPS;
        thrift_scheduler_group_num.value.__set_u32(scheduler_group_num.value.u32);
        attr_list.push_back(thrift_scheduler_group_num);
        
        sai_attribute_t scheduler_group_list;
        sai_thrift_attribute_t thrift_scheduler_group_list;
        scheduler_group_list.id = SAI_PORT_ATTR_QOS_SCHEDULER_GROUP_LIST;
        scheduler_group_list.value.objlist.count = scheduler_group_num.value.u32;
        scheduler_group_list.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * scheduler_group_num.value.u32);
        port_api->get_port_attribute(port_id, 1, &scheduler_group_list);
        thrift_scheduler_group_list.id = SAI_PORT_ATTR_QOS_SCHEDULER_GROUP_LIST;
        thrift_scheduler_group_list.value.objlist.count = scheduler_group_list.value.objlist.count;
        std::vector<sai_thrift_object_id_t>& group_list = thrift_scheduler_group_list.value.objlist.object_id_list;
        sai_object_list_t *sched_group_list_object;
        sched_group_list_object = &scheduler_group_list.value.objlist;
        for (int index = 0; index < scheduler_group_num.value.u32; index++)
        {
            group_list.push_back((sai_thrift_object_id_t)sched_group_list_object->list[index]);
        }
        thrift_scheduler_group_list.value.__isset.objlist = true;
        attr_list.push_back(thrift_scheduler_group_list);
        free(scheduler_group_list.value.objlist.list);
        
        sai_attribute_t support_speed;
        sai_thrift_attribute_t thrift_support_speed;
        support_speed.id = SAI_PORT_ATTR_SUPPORTED_SPEED;
        support_speed.value.u32list.list = (sai_uint32_t *) malloc(sizeof(sai_uint32_t) * 11);
        support_speed.value.u32list.count = 11;
        port_api->get_port_attribute(port_id, 1, &support_speed);
        thrift_support_speed.id = SAI_PORT_ATTR_SUPPORTED_SPEED;
        thrift_support_speed.value.s32list.count = support_speed.value.u32list.count;
        std::vector<sai_int32_t>& u32_list = thrift_support_speed.value.u32list.u32list;
        sai_u32_list_t *u32_list_value;
        u32_list_value = &support_speed.value.u32list;
        for (int index = 0; index < support_speed.value.u32list.count; index++)
        {
            u32_list.push_back((sai_uint32_t)u32_list_value->list[index]);
        }
        thrift_support_speed.value.__isset.u32list = true;
        attr_list.push_back(thrift_support_speed);
        free(support_speed.value.u32list.list);
        
        sai_attribute_t support_fec_mode;
        sai_thrift_attribute_t thrift_support_fec_mode;
        support_fec_mode.id = SAI_PORT_ATTR_SUPPORTED_FEC_MODE;
        support_fec_mode.value.s32list.list = (sai_int32_t *) malloc(sizeof(sai_int32_t) * 3);
        support_fec_mode.value.s32list.count = 3;
        port_api->get_port_attribute(port_id, 1, &support_fec_mode);
        thrift_support_fec_mode.id = SAI_PORT_ATTR_SUPPORTED_FEC_MODE;
        thrift_support_fec_mode.value.s32list.count = support_fec_mode.value.s32list.count;
        std::vector<sai_int32_t>& list1 = thrift_support_fec_mode.value.s32list.s32list;
        sai_s32_list_t *list_value1;
        list_value1 = &support_fec_mode.value.s32list;
        for (int index = 0; index < support_fec_mode.value.s32list.count; index++)
        {
            list1.push_back((sai_int32_t)list_value1->list[index]);
        }
        thrift_support_fec_mode.value.__isset.s32list = true;
        attr_list.push_back(thrift_support_fec_mode);
        free(support_fec_mode.value.s32list.list);
        
        sai_attribute_t support_half_duplex_speed;
        sai_thrift_attribute_t thrift_support_half_duplex_speed;
        support_half_duplex_speed.id = SAI_PORT_ATTR_SUPPORTED_HALF_DUPLEX_SPEED;
        support_half_duplex_speed.value.u32list.list = (sai_uint32_t *) malloc(sizeof(sai_uint32_t) * 2);
        support_half_duplex_speed.value.u32list.count = 2;
        port_api->get_port_attribute(port_id, 1, &support_half_duplex_speed);
        thrift_support_half_duplex_speed.id = SAI_PORT_ATTR_SUPPORTED_HALF_DUPLEX_SPEED;
        thrift_support_half_duplex_speed.value.s32list.count = support_half_duplex_speed.value.u32list.count;
        std::vector<sai_int32_t>& u32_list1 = thrift_support_half_duplex_speed.value.u32list.u32list;
        sai_u32_list_t *u32_list_value1;
        u32_list_value1 = &support_half_duplex_speed.value.u32list;
        for (int index = 0; index < support_half_duplex_speed.value.u32list.count; index++)
        {
            u32_list1.push_back((sai_uint32_t)u32_list_value1->list[index]);
        }
        thrift_support_half_duplex_speed.value.__isset.u32list = true;
        attr_list.push_back(thrift_support_half_duplex_speed);
        free(support_half_duplex_speed.value.u32list.list);
        
	    sai_attribute_t auto_neg_mode;
        sai_thrift_attribute_t thrift_auto_neg_mode;
        auto_neg_mode.id = SAI_PORT_ATTR_SUPPORTED_AUTO_NEG_MODE;
        port_api->get_port_attribute(port_id, 1, &auto_neg_mode);
        thrift_auto_neg_mode.id = SAI_PORT_ATTR_SUPPORTED_AUTO_NEG_MODE;
        thrift_auto_neg_mode.value.__set_booldata(auto_neg_mode.value.booldata);
        attr_list.push_back(thrift_auto_neg_mode);
        
	    sai_attribute_t flow_control_mode;
        sai_thrift_attribute_t thrift_flow_control_mode;
        flow_control_mode.id = SAI_PORT_ATTR_SUPPORTED_FLOW_CONTROL_MODE;
        port_api->get_port_attribute(port_id, 1, &flow_control_mode);
        thrift_flow_control_mode.id = SAI_PORT_ATTR_SUPPORTED_FLOW_CONTROL_MODE;
        thrift_flow_control_mode.value.__set_s32(flow_control_mode.value.s32);
        attr_list.push_back(thrift_flow_control_mode);
        
        sai_attribute_t asy_pause_mode;
        sai_thrift_attribute_t thrift_asy_pause_mode;
        asy_pause_mode.id = SAI_PORT_ATTR_SUPPORTED_ASYMMETRIC_PAUSE_MODE;
        port_api->get_port_attribute(port_id, 1, &asy_pause_mode);
        thrift_asy_pause_mode.id = SAI_PORT_ATTR_SUPPORTED_ASYMMETRIC_PAUSE_MODE;
        thrift_asy_pause_mode.value.__set_booldata(asy_pause_mode.value.booldata);
        attr_list.push_back(thrift_asy_pause_mode);
        
        sai_attribute_t support_media_type;
        sai_thrift_attribute_t thrift_support_media_type;
        support_media_type.id = SAI_PORT_ATTR_SUPPORTED_MEDIA_TYPE;
        port_api->get_port_attribute(port_id, 1, &support_media_type);
        thrift_support_media_type.id = SAI_PORT_ATTR_SUPPORTED_MEDIA_TYPE;
        thrift_support_media_type.value.__set_s32(support_media_type.value.s32);
        attr_list.push_back(thrift_support_media_type);
        
        sai_attribute_t ingress_pg_num;
        sai_thrift_attribute_t thrift_ingress_pg_num;
        ingress_pg_num.id = SAI_PORT_ATTR_NUMBER_OF_INGRESS_PRIORITY_GROUPS;
        port_api->get_port_attribute(port_id, 1, &ingress_pg_num);
        thrift_ingress_pg_num.id = SAI_PORT_ATTR_NUMBER_OF_INGRESS_PRIORITY_GROUPS;
        thrift_ingress_pg_num.value.__set_u32(ingress_pg_num.value.u32);
        attr_list.push_back(thrift_ingress_pg_num);
        
        sai_attribute_t ingress_pg_list;
        sai_thrift_attribute_t thrift_ingress_pg_list;
        ingress_pg_list.id = SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST;
        ingress_pg_list.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * ingress_pg_num.value.u32);
        ingress_pg_list.value.objlist.count = ingress_pg_num.value.u32;
        port_api->get_port_attribute(port_id, 1, &ingress_pg_list);
        thrift_ingress_pg_list.id = SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST;
        thrift_ingress_pg_list.value.objlist.count = ingress_pg_num.value.u32;
        std::vector<sai_thrift_object_id_t>& pg_list_objlist = thrift_ingress_pg_list.value.objlist.object_id_list;
        sai_object_list_t *pg_list_object;
        pg_list_object = &ingress_pg_list.value.objlist;
        for (int index = 0; index < ingress_pg_num.value.u32; index++)
        {
            pg_list_objlist.push_back((sai_thrift_object_id_t)pg_list_object->list[index]);
        }
        thrift_ingress_pg_list.value.__isset.objlist = true;
        attr_list.push_back(thrift_ingress_pg_list);
        free(ingress_pg_list.value.objlist.list);
        
        sai_attribute_t oper_speed;
        sai_thrift_attribute_t thrift_oper_speed;
        oper_speed.id = SAI_PORT_ATTR_OPER_SPEED;
        port_api->get_port_attribute(port_id, 1, &oper_speed);
        thrift_oper_speed.id = SAI_PORT_ATTR_OPER_SPEED;
        thrift_oper_speed.value.__set_u32(oper_speed.value.u32);
        attr_list.push_back(thrift_oper_speed);
        
        sai_attribute_t hw_lane_list;
        sai_thrift_attribute_t thrift_hw_lane_list;
        hw_lane_list.id = SAI_PORT_ATTR_HW_LANE_LIST;
        hw_lane_list.value.u32list.list = (sai_uint32_t *) malloc(sizeof(sai_uint32_t) * 4);
        hw_lane_list.value.u32list.count = 4;
        port_api->get_port_attribute(port_id, 1, &hw_lane_list);
        thrift_hw_lane_list.id = SAI_PORT_ATTR_HW_LANE_LIST;
        thrift_hw_lane_list.value.s32list.count = hw_lane_list.value.u32list.count;
        std::vector<sai_int32_t>& thrift_lane_list = thrift_hw_lane_list.value.u32list.u32list;
        sai_u32_list_t *lane_list;
        lane_list = &hw_lane_list.value.u32list;
        for (int index = 0; index < hw_lane_list.value.u32list.count; index++)
        {
            thrift_lane_list.push_back((sai_uint32_t)lane_list->list[index]);
        }
        thrift_hw_lane_list.value.__isset.u32list = true;
        attr_list.push_back(thrift_hw_lane_list);
        free(hw_lane_list.value.u32list.list);
        
        sai_attribute_t full_duplex_mode;
        sai_thrift_attribute_t thrift_full_duplex_mode;
        full_duplex_mode.id = SAI_PORT_ATTR_FULL_DUPLEX_MODE;
        port_api->get_port_attribute(port_id, 1, &full_duplex_mode);
        thrift_full_duplex_mode.id = SAI_PORT_ATTR_FULL_DUPLEX_MODE;
        thrift_full_duplex_mode.value.__set_booldata(full_duplex_mode.value.booldata);
        attr_list.push_back(thrift_full_duplex_mode);
        
        sai_attribute_t speed;
        sai_thrift_attribute_t thrift_speed;
        speed.id = SAI_PORT_ATTR_SPEED;
        port_api->get_port_attribute(port_id, 1, &speed);
        thrift_speed.id = SAI_PORT_ATTR_SPEED;
        thrift_speed.value.__set_u32(speed.value.u32);
        attr_list.push_back(thrift_speed);
        
        sai_attribute_t curr_auto_neg_mode;
        sai_thrift_attribute_t thrift_curr_auto_neg_mode;
        curr_auto_neg_mode.id = SAI_PORT_ATTR_AUTO_NEG_MODE;
        port_api->get_port_attribute(port_id, 1, &curr_auto_neg_mode);
        thrift_curr_auto_neg_mode.id = SAI_PORT_ATTR_AUTO_NEG_MODE;
        thrift_curr_auto_neg_mode.value.__set_booldata(curr_auto_neg_mode.value.booldata);
        attr_list.push_back(thrift_curr_auto_neg_mode);
        
        sai_attribute_t curr_admin_state;
        sai_thrift_attribute_t thrift_curr_admin_state;
        curr_admin_state.id = SAI_PORT_ATTR_ADMIN_STATE;
        port_api->get_port_attribute(port_id, 1, &curr_admin_state);
        thrift_curr_admin_state.id = SAI_PORT_ATTR_ADMIN_STATE;
        thrift_curr_admin_state.value.__set_booldata(curr_admin_state.value.booldata);
        attr_list.push_back(thrift_curr_admin_state);
        
        sai_attribute_t pvid;
        sai_thrift_attribute_t thrift_pvid;
        pvid.id = SAI_PORT_ATTR_PORT_VLAN_ID;
        port_api->get_port_attribute(port_id, 1, &pvid);
        thrift_pvid.id = SAI_PORT_ATTR_PORT_VLAN_ID;
        thrift_pvid.value.__set_u16(pvid.value.u16);
        attr_list.push_back(thrift_pvid);
        
        sai_attribute_t default_vlan_pri;
        sai_thrift_attribute_t thrift_default_vlan_pri;
        default_vlan_pri.id = SAI_PORT_ATTR_DEFAULT_VLAN_PRIORITY;
        port_api->get_port_attribute(port_id, 1, &default_vlan_pri);
        thrift_default_vlan_pri.id = SAI_PORT_ATTR_DEFAULT_VLAN_PRIORITY;
        thrift_default_vlan_pri.value.__set_u8(default_vlan_pri.value.u8);
        attr_list.push_back(thrift_default_vlan_pri);
        
        sai_attribute_t drop_untag;
        sai_thrift_attribute_t thrift_drop_untag;
        drop_untag.id = SAI_PORT_ATTR_DROP_UNTAGGED;
        port_api->get_port_attribute(port_id, 1, &drop_untag);
        thrift_drop_untag.id = SAI_PORT_ATTR_DROP_UNTAGGED;
        thrift_drop_untag.value.__set_booldata(drop_untag.value.booldata);
        attr_list.push_back(thrift_drop_untag);
        
        sai_attribute_t drop_tag;
        sai_thrift_attribute_t thrift_drop_tag;
        drop_tag.id = SAI_PORT_ATTR_DROP_TAGGED;
        port_api->get_port_attribute(port_id, 1, &drop_tag);
        thrift_drop_tag.id = SAI_PORT_ATTR_DROP_TAGGED;
        thrift_drop_tag.value.__set_booldata(drop_tag.value.booldata);
        attr_list.push_back(thrift_drop_tag);

        sai_attribute_t internal_lb_mode;
        sai_thrift_attribute_t thrift_internal_lb_mode;
        internal_lb_mode.id = SAI_PORT_ATTR_INTERNAL_LOOPBACK_MODE;
        port_api->get_port_attribute(port_id, 1, &internal_lb_mode);
        thrift_internal_lb_mode.id = SAI_PORT_ATTR_INTERNAL_LOOPBACK_MODE;
        thrift_internal_lb_mode.value.__set_s32(internal_lb_mode.value.s32);
        attr_list.push_back(thrift_internal_lb_mode);
        
        sai_attribute_t fec_mode;
        sai_thrift_attribute_t thrift_fec_mode;
        fec_mode.id = SAI_PORT_ATTR_FEC_MODE;
        port_api->get_port_attribute(port_id, 1, &fec_mode);
        thrift_fec_mode.id = SAI_PORT_ATTR_FEC_MODE;
        thrift_fec_mode.value.__set_s32(fec_mode.value.s32);
        attr_list.push_back(thrift_fec_mode);
        
        sai_attribute_t update_dscp;
        sai_thrift_attribute_t thrift_update_dscp;
        update_dscp.id = SAI_PORT_ATTR_UPDATE_DSCP;
        port_api->get_port_attribute(port_id, 1, &update_dscp);
        thrift_update_dscp.id = SAI_PORT_ATTR_UPDATE_DSCP;
        thrift_update_dscp.value.__set_booldata(update_dscp.value.booldata);
        attr_list.push_back(thrift_update_dscp);
        
        sai_attribute_t mtu;
        sai_thrift_attribute_t thrift_mtu;
        mtu.id = SAI_PORT_ATTR_MTU;
        port_api->get_port_attribute(port_id, 1, &mtu);
        thrift_mtu.id = SAI_PORT_ATTR_MTU;
        thrift_mtu.value.__set_u32(mtu.value.u32);
        attr_list.push_back(thrift_mtu);
        
        sai_attribute_t f_stom_policer_id;
        sai_thrift_attribute_t thrift_f_stom_policer_id;
        f_stom_policer_id.id = SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID;
        port_api->get_port_attribute(port_id, 1, &f_stom_policer_id);
        thrift_f_stom_policer_id.id = SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID;
        thrift_f_stom_policer_id.value.__set_oid(f_stom_policer_id.value.oid);
        attr_list.push_back(thrift_f_stom_policer_id);
        
        sai_attribute_t b_stom_policer_id;
        sai_thrift_attribute_t thrift_b_stom_policer_id;
        b_stom_policer_id.id = SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID;
        port_api->get_port_attribute(port_id, 1, &b_stom_policer_id);
        thrift_b_stom_policer_id.id = SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID;
        thrift_b_stom_policer_id.value.__set_oid(b_stom_policer_id.value.oid);
        attr_list.push_back(thrift_b_stom_policer_id);
        
        sai_attribute_t m_stom_policer_id;
        sai_thrift_attribute_t thrift_m_stom_policer_id;
        m_stom_policer_id.id = SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID;
        port_api->get_port_attribute(port_id, 1, &m_stom_policer_id);
        thrift_m_stom_policer_id.id = SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID;
        thrift_m_stom_policer_id.value.__set_oid(m_stom_policer_id.value.oid);
        attr_list.push_back(thrift_m_stom_policer_id);
        
        sai_attribute_t global_flow_control_mode;
        sai_thrift_attribute_t thrift_global_flow_control_mode;
        global_flow_control_mode.id = SAI_PORT_ATTR_GLOBAL_FLOW_CONTROL_MODE;
        port_api->get_port_attribute(port_id, 1, &global_flow_control_mode);
        thrift_global_flow_control_mode.id = SAI_PORT_ATTR_GLOBAL_FLOW_CONTROL_MODE;
        thrift_global_flow_control_mode.value.__set_s32(global_flow_control_mode.value.s32);
        attr_list.push_back(thrift_global_flow_control_mode);
        
        sai_attribute_t ingress_mirror_session;
        sai_thrift_attribute_t thrift_ingress_mirror_session;
        ingress_mirror_session.id = SAI_PORT_ATTR_INGRESS_MIRROR_SESSION;
        ingress_mirror_session.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 4);
        ingress_mirror_session.value.objlist.count = ingress_pg_num.value.u32;
        port_api->get_port_attribute(port_id, 1, &ingress_mirror_session);
        thrift_ingress_mirror_session.id = SAI_PORT_ATTR_INGRESS_MIRROR_SESSION;
        thrift_ingress_mirror_session.value.objlist.count = ingress_mirror_session.value.objlist.count;
        std::vector<sai_thrift_object_id_t>& ingress_mirror_list = thrift_ingress_mirror_session.value.objlist.object_id_list;
        sai_object_list_t *ingress_mirror_list_object;
        ingress_mirror_list_object = &ingress_mirror_session.value.objlist;
        for (int index = 0; index < ingress_mirror_session.value.objlist.count; index++)
        {
            ingress_mirror_list.push_back((sai_thrift_object_id_t)ingress_mirror_list_object->list[index]);
        }
        thrift_ingress_mirror_session.value.__isset.objlist = true;
        attr_list.push_back(thrift_ingress_mirror_session);
        free(ingress_mirror_session.value.objlist.list);
        
        sai_attribute_t egress_mirror_session;
        sai_thrift_attribute_t thrift_egress_mirror_session;
        egress_mirror_session.id = SAI_PORT_ATTR_EGRESS_MIRROR_SESSION;
        egress_mirror_session.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 4);
        egress_mirror_session.value.objlist.count = ingress_pg_num.value.u32;
        port_api->get_port_attribute(port_id, 1, &egress_mirror_session);
        thrift_egress_mirror_session.id = SAI_PORT_ATTR_EGRESS_MIRROR_SESSION;
        thrift_egress_mirror_session.value.objlist.count = egress_mirror_session.value.objlist.count;
        std::vector<sai_thrift_object_id_t>& egress_mirror_list = thrift_egress_mirror_session.value.objlist.object_id_list;
        sai_object_list_t *egress_mirror_list_object;
        egress_mirror_list_object = &egress_mirror_session.value.objlist;
        for (int index = 0; index < egress_mirror_session.value.objlist.count; index++)
        {
            egress_mirror_list.push_back((sai_thrift_object_id_t)egress_mirror_list_object->list[index]);
        }
        thrift_ingress_mirror_session.value.__isset.objlist = true;
        attr_list.push_back(thrift_ingress_mirror_session);
        free(egress_mirror_session.value.objlist.list);
        
        sai_attribute_t ingress_samplepacket_oid;
        sai_thrift_attribute_t thrift_ingress_samplepacket_oid;
        ingress_samplepacket_oid.id = SAI_PORT_ATTR_INGRESS_SAMPLEPACKET_ENABLE;
        port_api->get_port_attribute(port_id, 1, &ingress_samplepacket_oid);
        thrift_ingress_samplepacket_oid.id = SAI_PORT_ATTR_INGRESS_SAMPLEPACKET_ENABLE;
        thrift_ingress_samplepacket_oid.value.__set_oid(ingress_samplepacket_oid.value.oid);
        attr_list.push_back(thrift_ingress_samplepacket_oid);
        
        sai_attribute_t egress_samplepacket_oid;
        sai_thrift_attribute_t thrift_egress_samplepacket_oid;
        egress_samplepacket_oid.id = SAI_PORT_ATTR_EGRESS_SAMPLEPACKET_ENABLE;
        port_api->get_port_attribute(port_id, 1, &egress_samplepacket_oid);
        thrift_egress_samplepacket_oid.id = SAI_PORT_ATTR_EGRESS_SAMPLEPACKET_ENABLE;
        thrift_egress_samplepacket_oid.value.__set_oid(egress_samplepacket_oid.value.oid);
        attr_list.push_back(thrift_egress_samplepacket_oid);
        
        sai_attribute_t policer_oid;
        sai_thrift_attribute_t thrift_policer_oid;
        policer_oid.id = SAI_PORT_ATTR_POLICER_ID;
        port_api->get_port_attribute(port_id, 1, &policer_oid);
        thrift_policer_oid.id = SAI_PORT_ATTR_POLICER_ID;
        thrift_policer_oid.value.__set_oid(policer_oid.value.oid);
        attr_list.push_back(thrift_policer_oid);
        
        sai_attribute_t qos_dot1p_to_tc;
        sai_thrift_attribute_t thrift_qos_dot1p_to_tc;
        qos_dot1p_to_tc.id = SAI_PORT_ATTR_QOS_DOT1P_TO_TC_MAP;
        port_api->get_port_attribute(port_id, 1, &qos_dot1p_to_tc);
        thrift_qos_dot1p_to_tc.id = SAI_PORT_ATTR_QOS_DOT1P_TO_TC_MAP;
        thrift_qos_dot1p_to_tc.value.__set_oid(qos_dot1p_to_tc.value.oid);
        attr_list.push_back(thrift_qos_dot1p_to_tc);
        
        sai_attribute_t qos_dot1p_to_color;
        sai_thrift_attribute_t thrift_qos_dot1p_to_color;
        qos_dot1p_to_color.id = SAI_PORT_ATTR_QOS_DOT1P_TO_COLOR_MAP;
        port_api->get_port_attribute(port_id, 1, &qos_dot1p_to_color);
        thrift_qos_dot1p_to_color.id = SAI_PORT_ATTR_QOS_DOT1P_TO_COLOR_MAP;
        thrift_qos_dot1p_to_color.value.__set_oid(qos_dot1p_to_color.value.oid);
        attr_list.push_back(thrift_qos_dot1p_to_color);
        
        sai_attribute_t qos_dscp_to_tc;
        sai_thrift_attribute_t thrift_qos_dscp_to_tc;
        qos_dscp_to_tc.id = SAI_PORT_ATTR_QOS_DSCP_TO_TC_MAP;
        port_api->get_port_attribute(port_id, 1, &qos_dscp_to_tc);
        thrift_qos_dscp_to_tc.id = SAI_PORT_ATTR_QOS_DSCP_TO_TC_MAP;
        thrift_qos_dscp_to_tc.value.__set_oid(qos_dscp_to_tc.value.oid);
        attr_list.push_back(thrift_qos_dscp_to_tc);
        
        sai_attribute_t qos_dscp_to_color;
        sai_thrift_attribute_t thrift_qos_dscp_to_color;
        qos_dscp_to_color.id = SAI_PORT_ATTR_QOS_DSCP_TO_COLOR_MAP;
        port_api->get_port_attribute(port_id, 1, &qos_dscp_to_color);
        thrift_qos_dscp_to_color.id = SAI_PORT_ATTR_QOS_DSCP_TO_COLOR_MAP;
        thrift_qos_dscp_to_color.value.__set_oid(qos_dscp_to_color.value.oid);
        attr_list.push_back(thrift_qos_dscp_to_color);
        
        sai_attribute_t qos_color_to_dot1p;
        sai_thrift_attribute_t thrift_qos_color_to_dot1p;
        qos_color_to_dot1p.id = SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP;
        port_api->get_port_attribute(port_id, 1, &qos_color_to_dot1p);
        thrift_qos_color_to_dot1p.id = SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP;
        thrift_qos_color_to_dot1p.value.__set_oid(qos_color_to_dot1p.value.oid);
        attr_list.push_back(thrift_qos_color_to_dot1p);
        
        sai_attribute_t qos_color_to_dscp;
        sai_thrift_attribute_t thrift_qos_color_to_dscp;
        qos_color_to_dscp.id = SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP;
        port_api->get_port_attribute(port_id, 1, &qos_color_to_dscp);
        thrift_qos_color_to_dscp.id = SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP;
        thrift_qos_color_to_dscp.value.__set_oid(qos_color_to_dscp.value.oid);
        attr_list.push_back(thrift_qos_color_to_dscp);
        
        sai_attribute_t scheduler_profile_id;
        sai_thrift_attribute_t thrift_scheduler_profile_id;
        scheduler_profile_id.id = SAI_PORT_ATTR_QOS_SCHEDULER_PROFILE_ID;
        port_api->get_port_attribute(port_id, 1, &scheduler_profile_id);
        thrift_scheduler_profile_id.id = SAI_PORT_ATTR_QOS_SCHEDULER_PROFILE_ID;
        thrift_scheduler_profile_id.value.__set_oid(scheduler_profile_id.value.oid);
        attr_list.push_back(thrift_scheduler_profile_id);
        
        sai_attribute_t pfc_mode;
        sai_thrift_attribute_t thrift_pfc_mode;
        pfc_mode.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_MODE;
        port_api->get_port_attribute(port_id, 1, &pfc_mode);
        thrift_pfc_mode.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_MODE;
        thrift_pfc_mode.value.__set_s32(pfc_mode.value.s32);
        attr_list.push_back(thrift_pfc_mode);
        
        sai_attribute_t pfc;
        sai_thrift_attribute_t thrift_pfc;
        pfc.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL;
        port_api->get_port_attribute(port_id, 1, &pfc);
        thrift_pfc.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL;
        thrift_pfc.value.__set_u8(pfc.value.u8);
        attr_list.push_back(thrift_pfc);
        
        sai_attribute_t pfc_rx;
        sai_thrift_attribute_t thrift_pfc_rx;
        pfc_rx.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_RX;
        port_api->get_port_attribute(port_id, 1, &pfc_rx);
        thrift_pfc_rx.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_RX;
        thrift_pfc_rx.value.__set_u8(pfc_rx.value.u8);
        attr_list.push_back(thrift_pfc_rx);
        
        sai_attribute_t pfc_tx;
        sai_thrift_attribute_t thrift_pfc_tx;
        pfc_tx.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_TX;
        port_api->get_port_attribute(port_id, 1, &pfc_tx);
        thrift_pfc_tx.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL_TX;
        thrift_pfc_tx.value.__set_u8(pfc_tx.value.u8);
        attr_list.push_back(thrift_pfc_tx);
        
        sai_attribute_t meta_data;
        sai_thrift_attribute_t thrift_meta_data;
        meta_data.id = SAI_PORT_ATTR_META_DATA;
        port_api->get_port_attribute(port_id, 1, &meta_data);
        thrift_meta_data.id = SAI_PORT_ATTR_META_DATA;
        thrift_meta_data.value.__set_u32(meta_data.value.u32);
        attr_list.push_back(thrift_meta_data);
        
        sai_attribute_t egress_block_port_list;
        sai_thrift_attribute_t thrift_egress_block_port_list;
        egress_block_port_list.id = SAI_PORT_ATTR_EGRESS_BLOCK_PORT_LIST;
        egress_block_port_list.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 256);
        egress_block_port_list.value.objlist.count = 256;
        port_api->get_port_attribute(port_id, 1, &egress_block_port_list);
        thrift_egress_block_port_list.id = SAI_PORT_ATTR_EGRESS_BLOCK_PORT_LIST;
        thrift_egress_block_port_list.value.objlist.count = egress_block_port_list.value.objlist.count;
        std::vector<sai_thrift_object_id_t>& block_port_list = thrift_egress_block_port_list.value.objlist.object_id_list;
        sai_object_list_t *block_port;
        block_port = &egress_block_port_list.value.objlist;
        for (int index = 0; index < egress_block_port_list.value.objlist.count; index++)
        {
            block_port_list.push_back((sai_thrift_object_id_t)block_port->list[index]);
        }
        thrift_egress_block_port_list.value.__isset.objlist = true;
        attr_list.push_back(thrift_egress_block_port_list);
        free(egress_block_port_list.value.objlist.list);
        
        
        sai_attribute_t eee_enable = {0};
        sai_thrift_attribute_t thrift_eee_enable;
        eee_enable.id = SAI_PORT_ATTR_EEE_ENABLE;
        port_api->get_port_attribute(port_id, 1, &eee_enable);
        thrift_eee_enable.id = SAI_PORT_ATTR_EEE_ENABLE;
        thrift_eee_enable.value.__set_booldata(eee_enable.value.booldata);
        attr_list.push_back(thrift_eee_enable);
        
        sai_attribute_t isolation_group;
        sai_thrift_attribute_t thrift_isolation_group;
        isolation_group.id = SAI_PORT_ATTR_ISOLATION_GROUP;
        port_api->get_port_attribute(port_id, 1, &isolation_group);
        thrift_isolation_group.id = SAI_PORT_ATTR_ISOLATION_GROUP;
        thrift_isolation_group.value.__set_oid(isolation_group.value.oid);
        attr_list.push_back(thrift_isolation_group);
        
        sai_attribute_t tx_enable;
        sai_thrift_attribute_t thrift_tx_enable;
        tx_enable.id = SAI_PORT_ATTR_PKT_TX_ENABLE;
        port_api->get_port_attribute(port_id, 1, &tx_enable);
        thrift_tx_enable.id = SAI_PORT_ATTR_PKT_TX_ENABLE;
        thrift_tx_enable.value.__set_booldata(tx_enable.value.booldata);
        attr_list.push_back(thrift_tx_enable);
        
        sai_attribute_t es;
        sai_thrift_attribute_t thrift_es;
        es.id = SAI_PORT_ATTR_ES;
        port_api->get_port_attribute(port_id, 1, &es);
        thrift_es.id = SAI_PORT_ATTR_ES;
        thrift_es.value.__set_oid(es.value.oid);
        attr_list.push_back(thrift_es);
        
        
        sai_attribute_t ptp_mode;
        sai_thrift_attribute_t thrift_ptp_mode;
        ptp_mode.id = SAI_PORT_ATTR_PTP_MODE;
        port_api->get_port_attribute(port_id, 1, &ptp_mode);
        thrift_ptp_mode.id = SAI_PORT_ATTR_PTP_MODE;
        thrift_ptp_mode.value.__set_s32(ptp_mode.value.s32);
        attr_list.push_back(thrift_ptp_mode);
        
        sai_attribute_t ing_asy_delay;
        sai_thrift_attribute_t thrift_ing_asy_delay;
        ing_asy_delay.id = SAI_PORT_ATTR_PTP_INGRESS_ASYMMETRY_DELAY;
        port_api->get_port_attribute(port_id, 1, &ing_asy_delay);
        thrift_ing_asy_delay.id = SAI_PORT_ATTR_PTP_INGRESS_ASYMMETRY_DELAY;
        thrift_ing_asy_delay.value.__set_u64(ing_asy_delay.value.u64);
        attr_list.push_back(thrift_ing_asy_delay);
        
        sai_attribute_t eg_asy_delay;
        sai_thrift_attribute_t thrift_eg_asy_delay;
        eg_asy_delay.id = SAI_PORT_ATTR_PTP_EGRESS_ASYMMETRY_DELAY;
        port_api->get_port_attribute(port_id, 1, &eg_asy_delay);
        thrift_eg_asy_delay.id = SAI_PORT_ATTR_PTP_EGRESS_ASYMMETRY_DELAY;
        thrift_eg_asy_delay.value.__set_u64(eg_asy_delay.value.u64);
        attr_list.push_back(thrift_eg_asy_delay);
        
        sai_attribute_t path_delay;
        sai_thrift_attribute_t thrift_path_delay;
        path_delay.id = SAI_PORT_ATTR_PTP_PATH_DELAY;
        port_api->get_port_attribute(port_id, 1, &path_delay);
        thrift_path_delay.id = SAI_PORT_ATTR_PTP_PATH_DELAY;
        thrift_path_delay.value.__set_u64(path_delay.value.u64);
        attr_list.push_back(thrift_path_delay);
        
        sai_attribute_t domain_id;
        sai_thrift_attribute_t thrift_domain_id;
        domain_id.id = SAI_PORT_ATTR_PTP_DOMAIN_ID;
        port_api->get_port_attribute(port_id, 1, &domain_id);
        thrift_domain_id.id = SAI_PORT_ATTR_PTP_DOMAIN_ID;
        thrift_domain_id.value.__set_u8(domain_id.value.u8);
        attr_list.push_back(thrift_domain_id);
        
        sai_attribute_t oam_enable;
        sai_thrift_attribute_t thrift_oam_enable;
        oam_enable.id = SAI_PORT_ATTR_Y1731_ENABLE;
        port_api->get_port_attribute(port_id, 1, &oam_enable);
        
        thrift_oam_enable.id = SAI_PORT_ATTR_Y1731_ENABLE;
        thrift_oam_enable.value.__set_booldata(oam_enable.value.booldata);
        attr_list.push_back(thrift_oam_enable);
        
        sai_attribute_t oam_lm_enable;
        sai_thrift_attribute_t thrift_oam_lm_enable;
        oam_lm_enable.id = SAI_PORT_ATTR_Y1731_LM_ENABLE;
        port_api->get_port_attribute(port_id, 1, &oam_lm_enable);
        
        thrift_oam_lm_enable.id = SAI_PORT_ATTR_Y1731_LM_ENABLE;
        thrift_oam_lm_enable.value.__set_booldata(oam_lm_enable.value.booldata);
        attr_list.push_back(thrift_oam_lm_enable);

        sai_attribute_t oam_mip_enable;
        sai_thrift_attribute_t thrift_oam_mip_enable;
        oam_mip_enable.id = SAI_PORT_ATTR_Y1731_MIP_ENABLE;
        port_api->get_port_attribute(port_id, 1, &oam_mip_enable);
        
        thrift_oam_mip_enable.id = SAI_PORT_ATTR_Y1731_MIP_ENABLE;
        thrift_oam_mip_enable.value.__set_u8(oam_mip_enable.value.u8);
        attr_list.push_back(thrift_oam_mip_enable);
        
        sai_attribute_t port_mac;
        sai_thrift_attribute_t thrift_port_mac;
        port_mac.id = SAI_PORT_ATTR_MAC_ADDRESS;
        port_api->get_port_attribute(port_id, 1, &port_mac);
        
        thrift_port_mac.id = SAI_PORT_ATTR_MAC_ADDRESS;
        thrift_port_mac.value.mac = sai_thrift_mac_to_string(port_mac.value.mac);
        thrift_port_mac.value.__isset.mac = true;
        attr_list.push_back(thrift_port_mac);   
        
    }

    void sai_thrift_get_queue_stats(std::vector<int64_t> & thrift_counters,
                                    const sai_thrift_object_id_t queue_id,
                                    const std::vector<sai_thrift_queue_stat_counter_t> & thrift_counter_ids,
                                    const int32_t number_of_counters)
    {
        printf("sai_thrift_get_queue_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_queue_api_t *queue_api;
        status = sai_api_query(SAI_API_QUEUE, (void **) &queue_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_queue_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_queue_stat_t) *it;
        }
        
        status = queue_api->get_queue_stats(
                               (sai_object_id_t) queue_id,
                               number_of_counters,
                               counter_ids,
                               counters);
        
        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }
        free(counter_ids);
        free(counters);
        return;
    }

    void sai_thrift_parse_queue_attributes(sai_attribute_t *attr_list,
                                           const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
        
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_QUEUE_ATTR_TYPE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_QUEUE_ATTR_INDEX:
                	  attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_QUEUE_ATTR_SERVICE_ID:
                	  attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_QUEUE_ATTR_PORT:
                case SAI_QUEUE_ATTR_PARENT_SCHEDULER_NODE:
                case SAI_QUEUE_ATTR_WRED_PROFILE_ID:
                case SAI_QUEUE_ATTR_SCHEDULER_PROFILE_ID:
                	  attr_list[i].value.oid = attribute.value.oid;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    sai_thrift_object_id_t sai_thrift_create_queue(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_queue_api_t *queue_api = nullptr;
        auto status = sai_api_query(SAI_API_QUEUE, reinterpret_cast<void**>(&queue_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        
        sai_thrift_alloc_array(attr_list, attr_size);
        sai_thrift_parse_queue_attributes(attr_list, thrift_attr_list);
        
        sai_object_id_t queue_oid = 0;
        status = queue_api->create_queue(&queue_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_array(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return queue_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_queue(const sai_thrift_object_id_t queue_id) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_queue_api_t *queue_api = nullptr;
        auto status = sai_api_query(SAI_API_QUEUE, reinterpret_cast<void**>(&queue_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        status = queue_api->remove_queue(queue_id);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to remove OID.");
        
        return status;
    }

    void sai_thrift_get_queue_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t queue_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_queue_api_t *queue_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[10];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_QUEUE, (void **) &queue_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain queue_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_QUEUE_ATTR_TYPE;
        attr[1].id = SAI_QUEUE_ATTR_PORT;
	    attr[2].id = SAI_QUEUE_ATTR_INDEX;
	    attr[3].id = SAI_QUEUE_ATTR_PARENT_SCHEDULER_NODE;
        attr[4].id = SAI_QUEUE_ATTR_WRED_PROFILE_ID;
	    attr[5].id = SAI_QUEUE_ATTR_SCHEDULER_PROFILE_ID;
	    attr[6].id = SAI_QUEUE_ATTR_BUFFER_PROFILE_ID;
        attr[7].id = SAI_QUEUE_ATTR_SERVICE_ID;
        attr_count = 8;
        
        status = queue_api->get_queue_attribute(queue_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get queue attr, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_u32(attr[0].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_oid(attr[1].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_u8(attr[2].value.u8);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_oid(attr[3].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[4].id;
	    thrift_attr.value.__set_oid(attr[4].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[5].id;
	    thrift_attr.value.__set_oid(attr[5].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[6].id;
	    thrift_attr.value.__set_oid(attr[6].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        thrift_attr.id = attr[7].id;
	    thrift_attr.value.__set_u16(attr[7].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }


    sai_thrift_status_t sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id,
                                                       const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_queue_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_queue_api_t *queue_api;
        status = sai_api_query(SAI_API_QUEUE, (void **) &queue_api);
          if (status != SAI_STATUS_SUCCESS)
          {
              return status;
          }
        sai_attribute_t attr;
        attr.id = thrift_attr.id;
        attr.value.oid = thrift_attr.value.oid;
        status = queue_api->set_queue_attribute((sai_object_id_t)queue_id, &attr);
        return status;
    }

    sai_thrift_status_t sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id,
                                                     const std::vector<sai_thrift_queue_stat_counter_t> & thrift_counter_ids,
                                                     const int32_t number_of_counters)
    {
        printf("sai_thrift_clear_queue_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_queue_api_t *queue_api;
        status = sai_api_query(SAI_API_QUEUE, (void **) &queue_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_queue_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_queue_stat_t) *it;
        }
        
        status = queue_api->clear_queue_stats(
                               (sai_object_id_t) queue_id,
                               number_of_counters,
                               counter_ids);
        
        free(counter_ids);
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_buffer_profile\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_buffer_api_t *buffer_api;
        sai_object_id_t buffer_id = 0;
        status = sai_api_query(SAI_API_BUFFER, (void **) &buffer_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_buffer_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        buffer_api->create_buffer_profile(&buffer_id, gSwitchId, attr_count, attr_list);
        
        return buffer_id;
    }

    void sai_thrift_parse_buffer_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_BUFFER_PROFILE_ATTR_POOL_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_BUFFER_PROFILE_ATTR_BUFFER_SIZE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_BUFFER_PROFILE_ATTR_THRESHOLD_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_BUFFER_PROFILE_ATTR_SHARED_DYNAMIC_TH:
                    attr_list[i].value.s8 = attribute.value.s8;
                    break;
                case SAI_BUFFER_PROFILE_ATTR_SHARED_STATIC_TH:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_BUFFER_PROFILE_ATTR_XOFF_TH:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_BUFFER_PROFILE_ATTR_XON_TH:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
            }
        }
    }

    sai_thrift_status_t sai_thrift_remove_buffer_profile(const sai_thrift_object_id_t buffer_profile_id) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_buffer_api_t *buffer_api = nullptr;
        auto status = sai_api_query(SAI_API_BUFFER, reinterpret_cast<void**>(&buffer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        status = buffer_api->remove_buffer_profile(buffer_profile_id);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to remove OID.");
        
        return status;
    }

    void sai_thrift_get_buffer_profile_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                 const sai_thrift_object_id_t buffer_profile_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_buffer_api_t *buffer_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[10];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_BUFFER, (void **) &buffer_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain buffer api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_BUFFER_PROFILE_ATTR_POOL_ID;
        attr[1].id = SAI_BUFFER_PROFILE_ATTR_BUFFER_SIZE;
	    attr[2].id = SAI_BUFFER_PROFILE_ATTR_THRESHOLD_MODE;
	    attr[3].id = SAI_BUFFER_PROFILE_ATTR_SHARED_DYNAMIC_TH;
        attr[4].id = SAI_BUFFER_PROFILE_ATTR_SHARED_STATIC_TH;
	    attr[5].id = SAI_BUFFER_PROFILE_ATTR_XOFF_TH;
	    attr[6].id = SAI_BUFFER_PROFILE_ATTR_XON_TH;
        attr_count = 7;
        
        status = buffer_api->get_buffer_profile_attribute(buffer_profile_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get buffer profile attr, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_oid(attr[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_u32(attr[1].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_s32(attr[2].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_s8(attr[3].value.s8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[4].id;
	    thrift_attr.value.__set_u32(attr[4].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[5].id;
	    thrift_attr.value.__set_u32(attr[5].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[6].id;
	    thrift_attr.value.__set_u32(attr[6].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_set_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_id, 
                                                                const sai_thrift_attribute_t &thrift_attr) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_buffer_api_t *buffer_api = nullptr;
        auto status = sai_api_query(SAI_API_BUFFER, reinterpret_cast<void**>(&buffer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        
        sai_thrift_alloc_array(attr_list, attr_size);
        sai_thrift_parse_buffer_attributes(thrift_attr_list, attr_list);
        
        status = buffer_api->set_buffer_profile_attribute(buffer_profile_id, attr_list);
        sai_thrift_free_array(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_pool\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_buffer_api_t *buffer_api;
        sai_object_id_t pool_id = 0;
        status = sai_api_query(SAI_API_BUFFER, (void **) &buffer_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_pool_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        buffer_api->create_buffer_pool(&pool_id, gSwitchId, attr_count, attr_list);
        return pool_id;
    }

    void sai_thrift_parse_pool_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_BUFFER_POOL_ATTR_TYPE:
                    attr_list[i].value.u32 = attribute.value.s32;
                    break;
                case SAI_BUFFER_POOL_ATTR_SIZE:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_BUFFER_POOL_ATTR_THRESHOLD_MODE:
                    attr_list[i].value.u32 = attribute.value.s32;
                    break;
            }
        }
    }

    void sai_thrift_parse_priority_group_attributes(sai_attribute_t *attr_list,
                                                    const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const noexcept
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
        
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
		        case SAI_INGRESS_PRIORITY_GROUP_ATTR_INDEX:
		        	  attr_list[i].value.u8 = attribute.value.u8;
                    break;
		        case SAI_INGRESS_PRIORITY_GROUP_ATTR_BUFFER_PROFILE:
		        case SAI_INGRESS_PRIORITY_GROUP_ATTR_PORT:
		        	  attr_list[i].value.oid = attribute.value.oid;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }
    
    sai_thrift_object_id_t sai_thrift_create_priority_group(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_buffer_api_t *buffer_api = nullptr;
        auto status = sai_api_query(SAI_API_BUFFER, reinterpret_cast<void**>(&buffer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        
        sai_thrift_alloc_array(attr_list, attr_size);
        sai_thrift_parse_priority_group_attributes(attr_list, thrift_attr_list);
        
        sai_object_id_t priority_group_oid = 0;
        status = buffer_api->create_ingress_priority_group(&priority_group_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_array(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return priority_group_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_priority_group(const sai_thrift_object_id_t priority_group_oid) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_buffer_api_t *buffer_api = nullptr;
        auto status = sai_api_query(SAI_API_BUFFER, reinterpret_cast<void**>(&buffer_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        status = buffer_api->remove_ingress_priority_group(priority_group_oid);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to remove OID.");
        
        return status;
    }

    void sai_thrift_get_priority_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                 const sai_thrift_object_id_t priority_group_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_buffer_api_t *buffer_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[10];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_BUFFER, (void **) &buffer_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain buffer api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_INGRESS_PRIORITY_GROUP_ATTR_BUFFER_PROFILE;
        attr[1].id = SAI_INGRESS_PRIORITY_GROUP_ATTR_PORT;
	    attr[2].id = SAI_INGRESS_PRIORITY_GROUP_ATTR_INDEX;
        attr_count = 3;
        
        status = buffer_api->get_ingress_priority_group_attribute(priority_group_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get ingress priority group attr, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_oid(attr[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_oid(attr[1].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_u8(attr[2].value.u8);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, 
                                                                const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_priority_group_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_buffer_api_t *buffer_api;
        status = sai_api_query(SAI_API_BUFFER, (void **) &buffer_api);
          if (status != SAI_STATUS_SUCCESS)
          {
              return status;
          }
        sai_attribute_t attr;
        attr.id = thrift_attr.id;
        attr.value.oid = thrift_attr.value.oid;
        status = buffer_api->set_ingress_priority_group_attribute((sai_object_id_t)pg_id, &attr);
        return status;
    }

    void sai_thrift_get_pg_stats(std::vector<int64_t> & thrift_counters,
                                 const sai_thrift_object_id_t pg_id,
                                 const std::vector<sai_thrift_pg_stat_counter_t> & thrift_counter_ids,
                                 const int32_t number_of_counters)
    {
        printf("sai_thrift_get_pg_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_buffer_api_t *buffer_api;
        status = sai_api_query(SAI_API_BUFFER, (void **) &buffer_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_ingress_priority_group_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_ingress_priority_group_stat_t) *it;
        }
        
        status = buffer_api->get_ingress_priority_group_stats((sai_object_id_t) pg_id,
                                                              number_of_counters,
                                                              counter_ids,
                                                              counters);
        
        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }
        free(counter_ids);
        free(counters);
        return;
    }

    sai_thrift_object_id_t sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_wred_profile\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_wred_api_t *wred_api;
        sai_object_id_t wred_id = 0;
        status = sai_api_query(SAI_API_WRED, (void **) &wred_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_wred_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        wred_api->create_wred(&wred_id, gSwitchId, attr_count, attr_list);
        free(attr_list);
        return wred_id;
    }

    void sai_thrift_parse_wred_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
            switch (attribute.id)
            {
                case SAI_WRED_ATTR_GREEN_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_WRED_ATTR_GREEN_MIN_THRESHOLD:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_GREEN_MAX_THRESHOLD:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_GREEN_DROP_PROBABILITY:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_YELLOW_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_WRED_ATTR_YELLOW_MIN_THRESHOLD:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_YELLOW_MAX_THRESHOLD:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_YELLOW_DROP_PROBABILITY:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_RED_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_WRED_ATTR_RED_MIN_THRESHOLD:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_RED_MAX_THRESHOLD:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_RED_DROP_PROBABILITY:
                case SAI_WRED_ATTR_ECN_GREEN_MAX_THRESHOLD:
                case SAI_WRED_ATTR_ECN_YELLOW_MAX_THRESHOLD:
                case SAI_WRED_ATTR_ECN_RED_MAX_THRESHOLD:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_WRED_ATTR_WEIGHT:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_WRED_ATTR_ECN_MARK_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
            }
        }
    }

    sai_thrift_status_t sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
    {
        printf("sai_thrift_remove_wred_profile\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_wred_api_t *wred_api;
        status = sai_api_query(SAI_API_WRED, (void **) &wred_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = wred_api->remove_wred((sai_object_id_t) wred_id);
        return status;
    }

    void sai_thrift_get_wred_attribute_profile(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t wred_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_wred_api_t *wred_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[15];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_WRED, (void **) &wred_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain wred_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_WRED_ATTR_GREEN_ENABLE;
        attr[1].id = SAI_WRED_ATTR_GREEN_MIN_THRESHOLD;
	    attr[2].id = SAI_WRED_ATTR_GREEN_MAX_THRESHOLD;
	    attr[3].id = SAI_WRED_ATTR_GREEN_DROP_PROBABILITY;
        attr[4].id = SAI_WRED_ATTR_YELLOW_ENABLE;
	    attr[5].id = SAI_WRED_ATTR_YELLOW_MIN_THRESHOLD;
	    attr[6].id = SAI_WRED_ATTR_YELLOW_MAX_THRESHOLD;
        attr[7].id = SAI_WRED_ATTR_YELLOW_DROP_PROBABILITY;
	    attr[8].id = SAI_WRED_ATTR_RED_ENABLE;
	    attr[9].id = SAI_WRED_ATTR_RED_MIN_THRESHOLD;
	    attr[10].id = SAI_WRED_ATTR_RED_MAX_THRESHOLD;
        attr[11].id = SAI_WRED_ATTR_RED_DROP_PROBABILITY;
        attr[12].id = SAI_WRED_ATTR_ECN_GREEN_MAX_THRESHOLD;
        attr[13].id = SAI_WRED_ATTR_ECN_YELLOW_MAX_THRESHOLD;
        attr[14].id = SAI_WRED_ATTR_ECN_RED_MAX_THRESHOLD;
        attr_count = 15;
        
        status = wred_api->get_wred_attribute(wred_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get wred attr, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_booldata(attr[0].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_u32(attr[1].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_u32(attr[2].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_u32(attr[3].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[4].id;
	    thrift_attr.value.__set_booldata(attr[4].value.booldata);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[5].id;
	    thrift_attr.value.__set_u32(attr[5].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[6].id;
	    thrift_attr.value.__set_u32(attr[6].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
  	    thrift_attr.id = attr[7].id;
	    thrift_attr.value.__set_u32(attr[7].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[8].id;
	    thrift_attr.value.__set_booldata(attr[8].value.booldata);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[9].id;
	    thrift_attr.value.__set_u32(attr[9].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[10].id;
	    thrift_attr.value.__set_u32(attr[10].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[11].id;
	    thrift_attr.value.__set_u32(attr[11].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        thrift_attr.id = attr[12].id;
	    thrift_attr.value.__set_u32(attr[12].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[13].id;
	    thrift_attr.value.__set_u32(attr[13].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[14].id;
	    thrift_attr.value.__set_u32(attr[14].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_status_t sai_thrift_set_wred_attribute_profile(const sai_thrift_object_id_t wred_id, 
                                                              const sai_thrift_attribute_t &thrift_attr)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_wred_api_t *wred_api = nullptr;
        auto status = sai_api_query(SAI_API_WRED, reinterpret_cast<void**>(&wred_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }
        
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        
        sai_thrift_alloc_array(attr_list, attr_size);
        sai_thrift_parse_wred_attributes(thrift_attr_list, attr_list);
        
        status = wred_api->set_wred_attribute(wred_id, attr_list);
        sai_thrift_free_array(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        sai_attribute_t *attr_list;
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_qos_map_api_t *qos_map_api;
        sai_object_id_t qos_map_id = 0;
        sai_qos_map_t *qos_map_list = NULL;
        
        printf("sai_thrift_create_qos_map\n");
        
        status = sai_api_query(SAI_API_QOS_MAP, (void **) &qos_map_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        
        for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_QOS_MAP_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
        
                case SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST:
                    sai_attribute_t *attr = &attr_list[i];
        
                    attr->value.qosmap.count = attribute.value.qosmap.count;
        
                    qos_map_list = (sai_qos_map_t *) malloc(attr->value.qosmap.count * sizeof(sai_qos_map_t));
                    attr->value.qosmap.list = qos_map_list;
        
                    for (uint32_t j = 0; j < attribute.value.qosmap.count; j++)
                    {
                        sai_thrift_parse_qos_map_params(&attribute.value.qosmap.map_list[j].key, &attr->value.qosmap.list[j].key);
                        sai_thrift_parse_qos_map_params(&attribute.value.qosmap.map_list[j].value, &attr->value.qosmap.list[j].value);
                    }
                    break;
            }
        }
        
        qos_map_api->create_qos_map(&qos_map_id, gSwitchId, thrift_attr_list.size(), attr_list);
        
        free(qos_map_list);
        free(attr_list);
        return qos_map_id;
    }

    void sai_thrift_parse_qos_map_params(const sai_thrift_qos_map_params_t *thrift_qos_params, sai_qos_map_params_t *qos_params)
    {
        qos_params->tc = thrift_qos_params->tc;
        qos_params->dscp = thrift_qos_params->dscp;
        qos_params->dot1p = thrift_qos_params->dot1p;
        qos_params->prio = thrift_qos_params->prio;
        qos_params->pg = thrift_qos_params->pg;
        qos_params->queue_index = thrift_qos_params->queue_index;
        qos_params->color = (sai_packet_color_t) thrift_qos_params->color;
        qos_params->mpls_exp = thrift_qos_params->mpls_exp;
    }

    void sai_thrift_parse_qos_map_params(const sai_qos_map_params_t *qos_params, sai_thrift_qos_map_params_t *thrift_qos_params)
    {
        thrift_qos_params->tc = qos_params->tc;
        thrift_qos_params->dscp = qos_params->dscp;
        thrift_qos_params->dot1p = qos_params->dot1p;
        thrift_qos_params->prio = qos_params->prio;
        thrift_qos_params->pg = qos_params->pg;
        thrift_qos_params->queue_index = qos_params->queue_index;
        thrift_qos_params->color = (sai_packet_color_t)qos_params->color;
        thrift_qos_params->mpls_exp = qos_params->mpls_exp;
    }

    sai_thrift_status_t sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_qos_map_api_t *qos_map_api;
        
        printf("sai_thrift_remove_qos_map\n");
        
        status = sai_api_query(SAI_API_QOS_MAP, (void **) &qos_map_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        status = qos_map_api->remove_qos_map((sai_object_id_t) qos_map_id);
        return status;
    }

    void sai_thrift_get_qos_map_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t qos_map_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_qos_map_api_t *qos_map_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[2];
	    sai_thrift_attribute_t thrift_attr;
	    sai_thrift_qos_map_t map_list;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_QOS_MAP, (void **) &qos_map_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain qos_map api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_QOS_MAP_ATTR_TYPE;
        attr[1].id = SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST;
        attr_count = 2;
	    attr[1].value.qosmap.count = 64;
	    attr[1].value.qosmap.list = (sai_qos_map_t*)malloc(attr[1].value.qosmap.count * sizeof(sai_qos_map_t));
        
        status = qos_map_api->get_qos_map_attribute(qos_map_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get qos_map attr, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_u32(attr[0].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.qosmap.count = attr[1].value.qosmap.count;
        
	    for (int index = 0; index < attr[1].value.qosmap.count; index++)
  	    {
  	    	memset(&map_list, 0, sizeof(map_list));
	        //map_list.key.tc = attr[1].value.qosmap.list[index].key.tc;
	        sai_thrift_parse_qos_map_params(&attr[1].value.qosmap.list[index].key, &map_list.key);
            sai_thrift_parse_qos_map_params(&attr[1].value.qosmap.list[index].value, &map_list.value);
            thrift_attr.value.__isset.qosmap = true;
	        thrift_attr.value.qosmap.map_list.push_back(map_list);
  	    }
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    free(attr[1].value.qosmap.list);
    }

    sai_thrift_status_t sai_thrift_set_qos_map_attribute(const sai_thrift_object_id_t qos_map_id, 
                                                         const sai_thrift_attribute_t &thrift_attr)
    {
        sai_attribute_t attr;
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_qos_map_api_t *qos_map_api = NULL;
        sai_qos_map_t *qos_map_list = NULL;
        
	    if (thrift_attr.id != SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST)
  	    {
  	    	status= SAI_STATUS_NOT_SUPPORTED;
  	    	SAI_THRIFT_LOG_DBG("Error Exited.");return status;
  	    }
        
	    status = sai_api_query(SAI_API_QOS_MAP, (void **) &qos_map_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain qos_map api, status:%d", status);
            return status;
        }
        
	    attr.id = thrift_attr.id;
        attr.value.qosmap.count = thrift_attr.value.qosmap.count;
        
        qos_map_list = (sai_qos_map_t *) malloc(attr.value.qosmap.count * sizeof(sai_qos_map_t));
        attr.value.qosmap.list = qos_map_list;
        
        for (uint32_t j = 0; j < thrift_attr.value.qosmap.count; j++)
        {
            sai_thrift_parse_qos_map_params(&thrift_attr.value.qosmap.map_list[j].key, &attr.value.qosmap.list[j].key);
            sai_thrift_parse_qos_map_params(&thrift_attr.value.qosmap.map_list[j].value, &attr.value.qosmap.list[j].value);
        }
        
	    status = qos_map_api->set_qos_map_attribute(qos_map_id, &attr);
        
        free(qos_map_list);
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited.");return status; }
        
        SAI_THRIFT_LOG_ERR("Failed to set attribute.");
        
        return status;
    }
    //
    // SAI Next Hop Group API *****************************************************************************************
    //

    void sai_thrift_parse_next_hop_group_attributes(sai_attribute_t *attr_list, 
                                                    const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        if (thrift_attr_list.empty() || attr_list == nullptr) { SAI_THRIFT_LOG_ERR("Invalid input arguments."); }

        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();

        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;

            switch (attribute.id)
            {
                case SAI_NEXT_HOP_GROUP_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;

                case SAI_NEXT_HOP_GROUP_ATTR_SET_SWITCHOVER:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;

                case SAI_NEXT_HOP_GROUP_ATTR_COUNTER_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;

                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attributes.");
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");

        sai_next_hop_group_api_t *nhop_group_api = nullptr;
        auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP, reinterpret_cast<void**>(&nhop_group_api));

        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }

        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_next_hop_group_attributes(attr_list, thrift_attr_list);

        sai_object_id_t nhop_group_oid = 0;
        status = nhop_group_api->create_next_hop_group(&nhop_group_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);

        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return nhop_group_oid; }

        SAI_THRIFT_LOG_ERR("Failed to create next hop group, status:%d", status);

        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");

        sai_next_hop_group_api_t *nhop_group_api = nullptr;
        auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP, reinterpret_cast<void**>(&nhop_group_api));

        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }

        status = nhop_group_api->remove_next_hop_group(nhop_group_oid);

        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to remove next hop group, status:%d", status);
        }

        return status;
    }

    sai_thrift_status_t sai_thrift_set_next_hop_group_attribute(const sai_thrift_object_id_t nhop_group_oid,
                                                                const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_next_hop_group_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_next_hop_group_api_t *nhop_group_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };

        status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **) &nhop_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to set next hop group  attributes, status:%d", status);
            return status;
        }
        sai_thrift_parse_next_hop_group_attributes(&attr, thrift_attr_list);

        return nhop_group_api->set_next_hop_group_attribute(nhop_group_oid, &attr);
    }

    void sai_thrift_get_next_hop_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                 const sai_thrift_object_id_t nhop_group_oid)
    {
        printf("sai_thrift_get_next_hop_group_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_next_hop_group_api_t *nhop_group_api;
        sai_attribute_t attr[SAI_NEXT_HOP_GROUP_ATTR_END];
        uint32_t attr_cnt = 0;
        sai_object_list_t *member_list_object;
        sai_thrift_attribute_t thrift_attr;
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **) &nhop_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        attr[0].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 128);
        attr[0].value.objlist.count = 128;
        
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_MEMBER_LIST;
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_COUNT;
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_ATTR_TYPE;
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_ATTR_SET_SWITCHOVER;
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_ATTR_COUNTER_ID;
        
        
        status = nhop_group_api->get_next_hop_group_attribute(nhop_group_oid, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get next hop group attributes, status:%d", status);
            thrift_attr_list.status = status;
            free(attr[0].value.objlist.list);
            return;
        }
        
        thrift_attr.id        = attr[0].id;
        thrift_attr.value.objlist.count = attr[0].value.objlist.count;
        std :: vector < sai_thrift_object_id_t > & member_list = thrift_attr.value.objlist.object_id_list;
        member_list_object = &attr[0].value.objlist;
        for (int index = 0; index < attr[0].value.objlist.count; index++)
        {
            member_list.push_back((sai_thrift_object_id_t) member_list_object->list[index]);
        }
        thrift_attr.value.__isset.objlist = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[1].id;
        thrift_attr.value.__set_u32(attr[1].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[2].id;
        thrift_attr.value.__set_s32(attr[2].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[3].id;
        thrift_attr.value.__set_booldata(attr[3].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[4].id;
        thrift_attr.value.__set_oid(attr[4].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        free(attr[0].value.objlist.list);
    }

    void sai_thrift_parse_next_hop_group_member_attributes(sai_attribute_t *attr_list, 
                                                           const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        if (thrift_attr_list.empty() || attr_list == nullptr) { SAI_THRIFT_LOG_ERR("Invalid input arguments."); }

        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();

        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;

            switch (attribute.id)
            {
                case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_GROUP_ID:
                case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;

                case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_WEIGHT:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;

                case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_CONFIGURED_ROLE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;

                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attributes.");
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");

        sai_next_hop_group_api_t *nhop_group_api = nullptr;
        auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP, reinterpret_cast<void**>(&nhop_group_api));

        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }

        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_next_hop_group_member_attributes(attr_list, thrift_attr_list);

        sai_object_id_t nhop_group_member_oid = 0;
        status = nhop_group_api->create_next_hop_group_member(&nhop_group_member_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);

        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return nhop_group_member_oid; }

        SAI_THRIFT_LOG_ERR("Failed to create group member.");

        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");

        sai_next_hop_group_api_t *nhop_group_api = nullptr;
        auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP, reinterpret_cast<void**>(&nhop_group_api));

        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return status; }

        status = nhop_group_api->remove_next_hop_group_member(nhop_group_member_oid);

        SAI_THRIFT_LOG_DBG("Exited.");

        return status;
    }

    void sai_thrift_get_next_hop_group_member_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                        const sai_thrift_object_id_t nhop_group_member_oid)
    {
        printf("sai_thrift_get_next_hop_group_member_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_next_hop_group_api_t *nhop_group_api;
        sai_attribute_t attr[SAI_NEXT_HOP_GROUP_MEMBER_ATTR_END];
        uint32_t attr_cnt = 0;
        sai_thrift_attribute_t thrift_attr;

        thrift_attr_list.attr_count = 0;

        status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **) &nhop_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }

        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_GROUP_ID;
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_ID;
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_MEMBER_ATTR_CONFIGURED_ROLE;
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_MEMBER_ATTR_OBSERVED_ROLE;

        status = nhop_group_api->get_next_hop_group_member_attribute(nhop_group_member_oid, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get next hop group member attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }

        thrift_attr.id        = attr[0].id;
        thrift_attr.value.__set_oid(attr[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[1].id;
        thrift_attr.value.__set_oid(attr[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[2].id;
        thrift_attr.value.__set_s32(attr[2].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[3].id;
        thrift_attr.value.__set_s32(attr[3].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);

    }

    void sai_thrift_get_next_hop_group_member_attribute_ecmp(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                        const sai_thrift_object_id_t nhop_group_member_oid)
    {
        printf("sai_thrift_get_next_hop_group_member_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_next_hop_group_api_t *nhop_group_api;
        sai_attribute_t attr[SAI_NEXT_HOP_GROUP_MEMBER_ATTR_END];
        uint32_t attr_cnt = 0;
        sai_thrift_attribute_t thrift_attr;

        thrift_attr_list.attr_count = 0;

        status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **) &nhop_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }

        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_GROUP_ID;
        attr[attr_cnt++].id = SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_ID;


        status = nhop_group_api->get_next_hop_group_member_attribute(nhop_group_member_oid, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to get next hop group member attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }

        thrift_attr.id        = attr[0].id;
        thrift_attr.value.__set_oid(attr[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id        = attr[1].id;
        thrift_attr.value.__set_oid(attr[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);



    }


    void sai_thrift_create_next_hop_group_members(sai_thrift_results_t& ret,
                                                  const std::vector<sai_thrift_attribute_t> & thrift_attr_lists,
                                                  const std::vector<int32_t> & thrift_attr_count_lists,
                                                  const int8_t mode)
    {
        printf("sai_thrift_create_next_hop_group_members\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_status_t *status_list = NULL;
        sai_next_hop_group_api_t *nhop_group_api;
        sai_object_id_t *nexthop_group_member_ids = NULL;
        //sai_object_id_t *vlan_member_ids = NULL;
        status = sai_api_query(SAI_API_NEXT_HOP_GROUP, reinterpret_cast<void**>(&nhop_group_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        uint32_t attr_num = 0;
        uint32 obj_count = thrift_attr_count_lists.size();
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_lists.begin();
        std::vector<int32_t>::const_iterator it_count = thrift_attr_count_lists.begin();
    
        std::vector<sai_thrift_attribute_t> thrift_attr_list;
    
        uint32_t *attr_count_list = malloc(sizeof(uint32_t) * thrift_attr_count_lists.size());
        memset(attr_count_list, 0, sizeof(uint32_t) * thrift_attr_count_lists.size());
        sai_attribute_t **p_attr_list = malloc(sizeof(sai_attribute_t*) * thrift_attr_count_lists.size());
    
        for(uint32_t i = 0; i < thrift_attr_count_lists.size(); i++, it_count++)
        {
            attr_num = (uint32_t)*it_count;
    
            for(uint32_t j = 0; j < attr_num; j++, it++)
            {
                thrift_attr_list.push_back((sai_thrift_attribute_t)*it);
            }
    
            p_attr_list[i] = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * attr_num);
            memset(p_attr_list[i], 0, sizeof(sai_attribute_t*) * attr_num);
    
            sai_thrift_parse_next_hop_group_member_attributes(p_attr_list[i], thrift_attr_list);
    
            thrift_attr_list.clear();
    
            attr_count_list[i] = attr_num;
    
        }
    
        status_list = malloc(sizeof(sai_status_t) * obj_count);
        nexthop_group_member_ids = malloc(sizeof(sai_object_id_t) * obj_count);
        memset(status_list, 0, sizeof(sai_status_t) * obj_count);
        memset(nexthop_group_member_ids, 0, sizeof(sai_object_id_t) * obj_count);
    
        nhop_group_api->create_next_hop_group_members(gSwitchId, obj_count, attr_count_list, p_attr_list, mode, nexthop_group_member_ids, status_list);
    
    
        for(uint32_t m = 0; m < obj_count; m ++)
        {
            ret.objlist.object_id_list.push_back(nexthop_group_member_ids[m]);
            ret.statuslist.status_list.push_back(status_list[m]);
        }
    
        ret.__isset.objlist = true;
        ret.__isset.statuslist = true;
    
        free(status_list);
        free(nexthop_group_member_ids);
    
        free(attr_count_list);
    
        for(uint32_t i = 0; i < thrift_attr_count_lists.size(); i++, it_count++)
        {
            free(p_attr_list[i]);
        }
    
        free(p_attr_list);
    }
    
    void sai_thrift_remove_next_hop_group_members(sai_thrift_status_list_t& ret,
                                                  const std::vector<sai_thrift_object_id_t> & thrift_object_id_list,
                                                  const int8_t mode)
    {
        printf("sai_thrift_remove_next_hop_group_members\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_next_hop_group_api_t *nhop_group_api;
        sai_status_t *statuslist;
        sai_object_id_t *obj_ids;
        status = sai_api_query(SAI_API_NEXT_HOP_GROUP, reinterpret_cast<void**>(&nhop_group_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        
        uint32 obj_count = thrift_object_id_list.size();
        statuslist = malloc(sizeof(sai_status_t) * obj_count);
        memset(statuslist, 0, sizeof(sai_status_t) * obj_count);
        
        obj_ids = malloc(sizeof(sai_object_id_t) * obj_count);
        std::vector<sai_thrift_object_id_t>::const_iterator it = thrift_object_id_list.begin();
        
        for(uint32_t i = 0; i < obj_count; i++, it++)
        {
          obj_ids[i] = (sai_thrift_object_id_t)*it;
        }
        
        nhop_group_api->remove_next_hop_group_members(obj_count,obj_ids,mode,statuslist);
        
        for(uint32_t j = 0; j < obj_count; j++)
        {
          ret.status_list.push_back(statuslist[j]);
        }
        
        ret.__isset.status_list = true;
        free(obj_ids);
        free(statuslist);
    }

	sai_thrift_object_id_t sai_thrift_create_l2mc_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_l2mc_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_l2mc_group_api_t *l2mc_grp_api;
        sai_object_id_t	grp_id = SAI_NULL_OBJECT_ID;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_L2MC_GROUP, (void **) &l2mc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = l2mc_grp_api->create_l2mc_group(&grp_id, gSwitchId, 0, NULL);
        
        return grp_id;
    }

	sai_thrift_status_t sai_thrift_remove_l2mc_group(const sai_thrift_object_id_t grp_id)
    {
        printf("sai_thrift_remove_l2mc_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_l2mc_group_api_t *l2mc_grp_api;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_L2MC_GROUP, (void **) &l2mc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = l2mc_grp_api->remove_l2mc_group(grp_id);
        
        return status;
    }

	void sai_thrift_get_l2mc_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t grp_id)
    {
        sai_l2mc_group_api_t *l2mc_grp_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[2];
	    sai_thrift_attribute_t thrift_attr;
	    sai_object_list_t *member_list_object;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        thrift_attr_list.status = sai_api_query(SAI_API_L2MC_GROUP, (void **) &l2mc_grp_api);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
	    attr_count = 2;
        
        attr[0].id = SAI_L2MC_GROUP_ATTR_L2MC_OUTPUT_COUNT;
        attr[1].id = SAI_L2MC_GROUP_ATTR_L2MC_MEMBER_LIST;
        attr[1].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 128);
        attr[1].value.objlist.count = 128;
        
        thrift_attr_list.status = l2mc_grp_api->get_l2mc_group_attribute(grp_id, attr_count, attr);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain l2mc group attribute, status:%d", thrift_attr_list.status);
	        free(attr[1].value.objlist.list);
            return;
        }
        
        thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_u32(attr[0].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.objlist.count = attr[1].value.objlist.count;
	    std::vector<sai_thrift_object_id_t>& member_list = thrift_attr.value.objlist.object_id_list;
        member_list_object = &attr[1].value.objlist;
        for (int index = 0; index < attr[1].value.objlist.count; index++)
        {
            member_list.push_back((sai_thrift_object_id_t) member_list_object->list[index]);
        }
        
        thrift_attr.value.__isset.objlist = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    free(attr[1].value.objlist.list);
    }

	void sai_thrift_parse_l2mc_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                       sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_L2MC_GROUP_MEMBER_ATTR_L2MC_GROUP_ID:
                case SAI_L2MC_GROUP_MEMBER_ATTR_L2MC_OUTPUT_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
        
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse l2mc member attributes.");
                    break;
            }
        }
    }

	sai_thrift_object_id_t sai_thrift_create_l2mc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_l2mc_group_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_l2mc_group_api_t *l2mc_grp_api;
	    sai_attribute_t  *sai_attrs = nullptr;
	    sai_object_id_t	member_oid = SAI_NULL_OBJECT_ID;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_L2MC_GROUP, (void **) &l2mc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        sai_uint32_t attr_size = thrift_attr_list.size();

        sai_thrift_alloc_attr(sai_attrs, attr_size);

        sai_thrift_parse_l2mc_group_member_attributes(thrift_attr_list, sai_attrs);

        status = l2mc_grp_api->create_l2mc_group_member(&member_oid, gSwitchId, attr_size, sai_attrs);

        return member_oid;
    }

	sai_thrift_status_t sai_thrift_remove_l2mc_group_member(const sai_thrift_object_id_t member_id)
    {
        printf("sai_thrift_remove_l2mc_group_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_l2mc_group_api_t *l2mc_grp_api;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_L2MC_GROUP, (void **) &l2mc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = l2mc_grp_api->remove_l2mc_group_member(member_id);
        
        return status;
    }

	sai_thrift_status_t sai_thrift_set_l2mc_group_member_attribute(const sai_thrift_object_id_t member_id,
                                                                   const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_l2mc_group_api_t *l2mc_grp_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_L2MC_GROUP, (void **) &l2mc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain l2mc_grp_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_l2mc_group_member_attributes(thrift_attr_list, &attr);
        
        return l2mc_grp_api->set_l2mc_group_member_attribute(member_id, &attr);
    }

	void sai_thrift_get_l2mc_group_member_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                    const sai_thrift_object_id_t member_id)
    {
        sai_l2mc_group_api_t *l2mc_grp_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
	    sai_object_list_t *member_list_object;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        thrift_attr_list.status = sai_api_query(SAI_API_L2MC_GROUP, (void **) &l2mc_grp_api);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        attr_count = 2;
        attr[0].id = SAI_L2MC_GROUP_MEMBER_ATTR_L2MC_GROUP_ID;
        attr[1].id = SAI_L2MC_GROUP_MEMBER_ATTR_L2MC_OUTPUT_ID;
        
        thrift_attr_list.status = l2mc_grp_api->get_l2mc_group_member_attribute(member_id, attr_count, attr);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain l2mc group member attribute, status:%d", thrift_attr_list.status);
            return;
        }
        
        thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_oid(attr[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = attr[1].id;
        thrift_attr.value.__set_oid(attr[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

	void sai_thrift_parse_l2mc_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
	    	    case SAI_L2MC_ENTRY_ATTR_PACKET_ACTION:
	    	    	attr_list[i].value.s32 = attribute.value.s32;
	    	    	break;
                case SAI_L2MC_ENTRY_ATTR_OUTPUT_GROUP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse l2mc member attributes.");
                    break;
            }
        }
    }

	sai_thrift_status_t sai_thrift_create_l2mc_entry(const sai_thrift_l2mc_entry_t &thrift_l2mc_entry,
                                                     const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_l2mc_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_l2mc_api_t *l2mc_api;
        sai_l2mc_entry_t l2mc_entry;
        sai_attribute_t  *sai_attrs = nullptr;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_L2MC, (void **) &l2mc_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
    
	    sai_thrift_parse_l2mc_entry(thrift_l2mc_entry, &l2mc_entry);
        
	    sai_uint32_t attr_size = thrift_attr_list.size();

        sai_thrift_alloc_attr(sai_attrs, attr_size);

        sai_thrift_parse_l2mc_entry_attributes(thrift_attr_list, sai_attrs);

        status = l2mc_api->create_l2mc_entry(&l2mc_entry, attr_size, sai_attrs);

        return status;
    }

	sai_thrift_status_t sai_thrift_remove_l2mc_entry(const sai_thrift_l2mc_entry_t &thrift_l2mc_entry)
    {
        printf("sai_thrift_remove_l2mc_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_l2mc_api_t *l2mc_api;
        sai_l2mc_entry_t l2mc_entry;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_L2MC, (void **) &l2mc_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }

	    sai_thrift_parse_l2mc_entry(thrift_l2mc_entry, &l2mc_entry);

        status = l2mc_api->remove_l2mc_entry(&l2mc_entry);

        return status;
    }

	sai_thrift_status_t sai_thrift_set_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t &thrift_l2mc_entry,
                                                            const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_l2mc_api_t *l2mc_api;
        sai_l2mc_entry_t l2mc_entry;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_L2MC, (void **) &l2mc_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain l2mc_api, status:%d", status);
            return status;
        }
        
	    sai_thrift_parse_l2mc_entry(thrift_l2mc_entry, &l2mc_entry);
        sai_thrift_parse_l2mc_entry_attributes(thrift_attr_list, &attr);
    
        return l2mc_api->set_l2mc_entry_attribute(&l2mc_entry, &attr);
    }

	void sai_thrift_get_l2mc_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list,
                                             const sai_thrift_l2mc_entry_t &thrift_l2mc_entry)
    {
        sai_l2mc_api_t *l2mc_api;
        sai_l2mc_entry_t l2mc_entry;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        thrift_attr_list.status = sai_api_query(SAI_API_L2MC, (void **) &l2mc_api);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        attr_count = 2;
        attr[0].id = SAI_L2MC_ENTRY_ATTR_PACKET_ACTION;
        attr[1].id = SAI_L2MC_ENTRY_ATTR_OUTPUT_GROUP_ID;
        
        sai_thrift_parse_l2mc_entry(thrift_l2mc_entry, &l2mc_entry);
        thrift_attr_list.status = l2mc_api->get_l2mc_entry_attribute(&l2mc_entry, attr_count, attr);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain l2mc entry attribute, status:%d", thrift_attr_list.status);
            return;
        }

		thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_s32(attr[0].value.s32);
		thrift_attr_list.attr_list.push_back(thrift_attr);

        thrift_attr.id = attr[1].id;
        thrift_attr.value.__set_oid(attr[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

	void sai_thrift_parse_mcast_fdb_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                     sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_MCAST_FDB_ENTRY_ATTR_PACKET_ACTION:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
        
                case SAI_MCAST_FDB_ENTRY_ATTR_GROUP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
        
                case SAI_MCAST_FDB_ENTRY_ATTR_META_DATA:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
        
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse mcast fdb entry attributes.");
                    break;
            }
        }
    }

	sai_thrift_status_t sai_thrift_create_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t &thrift_mcast_fdb_entry,
                                                          const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_mcast_fdb_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mcast_fdb_api_t *mcast_fdb_api;
        sai_mcast_fdb_entry_t mcast_fdb_entry;
        sai_attribute_t  *sai_attrs = nullptr;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_MCAST_FDB, (void **) &mcast_fdb_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }

	    sai_thrift_parse_mcast_fdb_entry(thrift_mcast_fdb_entry, &mcast_fdb_entry);

	    sai_uint32_t attr_size = thrift_attr_list.size();

	    sai_thrift_alloc_attr(sai_attrs, attr_size);

	    sai_thrift_parse_mcast_fdb_entry_attributes(thrift_attr_list, sai_attrs);

	    status = mcast_fdb_api->create_mcast_fdb_entry(&mcast_fdb_entry, attr_size, sai_attrs);

	    return status;
    }

	sai_thrift_status_t sai_thrift_remove_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t &thrift_mcast_fdb_entry)
    {
        printf("sai_thrift_remove_mcast_fdb_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mcast_fdb_api_t *mcast_fdb_api;
        sai_mcast_fdb_entry_t mcast_fdb_entry;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_MCAST_FDB, (void **) &mcast_fdb_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        sai_thrift_parse_mcast_fdb_entry(thrift_mcast_fdb_entry, &mcast_fdb_entry);

        status = mcast_fdb_api->remove_mcast_fdb_entry(&mcast_fdb_entry);

        return status;
    }

	sai_thrift_status_t sai_thrift_set_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t &thrift_mcast_fdb_entry,
                                                                 const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_mcast_fdb_api_t *mcast_fdb_api;
        sai_mcast_fdb_entry_t mcast_fdb_entry;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_MCAST_FDB, (void **) &mcast_fdb_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain mcast_fdb_api, status:%d", status);
            return status;
        }

        sai_thrift_parse_mcast_fdb_entry(thrift_mcast_fdb_entry, &mcast_fdb_entry);
        sai_thrift_parse_mcast_fdb_entry_attributes(thrift_attr_list, &attr);

        return mcast_fdb_api->set_mcast_fdb_entry_attribute(&mcast_fdb_entry, &attr);
    }

	void sai_thrift_get_mcast_fdb_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list,
                                                  const sai_thrift_mcast_fdb_entry_t &thrift_mcast_fdb_entry)
    {
        sai_mcast_fdb_api_t *mcast_fdb_api;
        sai_mcast_fdb_entry_t mcast_fdb_entry;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        thrift_attr_list.status = sai_api_query(SAI_API_MCAST_FDB, (void **) &mcast_fdb_api);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        attr_count = 3;
        attr[0].id = SAI_MCAST_FDB_ENTRY_ATTR_PACKET_ACTION;
        attr[1].id = SAI_MCAST_FDB_ENTRY_ATTR_GROUP_ID;
        attr[2].id = SAI_MCAST_FDB_ENTRY_ATTR_META_DATA;
        
        sai_thrift_parse_mcast_fdb_entry(thrift_mcast_fdb_entry, &mcast_fdb_entry);
        thrift_attr_list.status = mcast_fdb_api->get_mcast_fdb_entry_attribute(&mcast_fdb_entry, attr_count, attr);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain mcast fdb entry attribute, status:%d", thrift_attr_list.status);
            return;
        }
        
        thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = attr[1].id;
        thrift_attr.value.__set_oid(attr[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = attr[2].id;
        thrift_attr.value.__set_u32(attr[2].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_object_id_t sai_thrift_create_ipmc_group(const std :: vector < sai_thrift_attribute_t > & thrift_attr_list)
    {
        printf("sai_thrift_create_ipmc_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ipmc_group_api_t *ipmc_grp_api;
        sai_object_id_t	grp_id = 0;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_IPMC_GROUP, (void **) &ipmc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = ipmc_grp_api->create_ipmc_group(&grp_id, gSwitchId, 0, NULL);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to create ipmc group, status:%d", status);
        }
        
        return grp_id;
    }

	sai_thrift_status_t sai_thrift_remove_ipmc_group(const sai_thrift_object_id_t grp_id)
    {
        printf("sai_thrift_remove_ipmc_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ipmc_group_api_t *ipmc_grp_api;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_IPMC_GROUP, (void **) &ipmc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = ipmc_grp_api->remove_ipmc_group(grp_id);
        
        return status;
    }

	void sai_thrift_get_ipmc_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t grp_id)
    {
        sai_ipmc_group_api_t *ipmc_grp_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
	    sai_object_list_t *member_list_object;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        thrift_attr_list.status = sai_api_query(SAI_API_IPMC_GROUP, (void **) &ipmc_grp_api);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            return;
        }

	    attr_count = 2;
        attr[0].id = SAI_IPMC_GROUP_ATTR_IPMC_OUTPUT_COUNT;
        attr[1].id = SAI_IPMC_GROUP_ATTR_IPMC_MEMBER_LIST;
        attr[1].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 128);
        attr[1].value.objlist.count = 128;
        
        thrift_attr_list.status = ipmc_grp_api->get_ipmc_group_attribute(grp_id, attr_count, attr);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ipmc group attribute, status:%d", thrift_attr_list.status);
		    free(attr[1].value.objlist.list);
            return;
        }

	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_u16(attr[0].value.u16);
	    thrift_attr_list.attr_list.push_back(thrift_attr);

	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.objlist.count = attr[1].value.objlist.count;
	    std::vector<sai_thrift_object_id_t>& member_list = thrift_attr.value.objlist.object_id_list;
	    member_list_object = &attr[1].value.objlist;
	    for (int index = 0; index < attr[1].value.objlist.count; index++)
        {
            member_list.push_back((sai_thrift_object_id_t) member_list_object->list[index]);
	    }
	    thrift_attr.value.__isset.objlist = true;
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    free(attr[1].value.objlist.list);
    }

	void sai_thrift_parse_ipmc_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                       sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_IPMC_GROUP_MEMBER_ATTR_IPMC_GROUP_ID:
                case SAI_IPMC_GROUP_MEMBER_ATTR_IPMC_OUTPUT_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
        
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse ipmc member attributes.");
                    break;
            }
        }
    }

	sai_thrift_object_id_t sai_thrift_create_ipmc_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_ipmc_group_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ipmc_group_api_t *ipmc_grp_api;
	    sai_attribute_t  *sai_attrs = nullptr;
	    sai_object_id_t	member_oid = 0;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_IPMC_GROUP, (void **) &ipmc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }

        sai_uint32_t attr_size = thrift_attr_list.size();

        sai_thrift_alloc_attr(sai_attrs, attr_size);

        sai_thrift_parse_ipmc_group_member_attributes(thrift_attr_list, sai_attrs);

        status = ipmc_grp_api->create_ipmc_group_member(&member_oid, gSwitchId, attr_size, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to create ipmc group member, status:%d", status);
        }

        return member_oid;
    }

	sai_thrift_status_t sai_thrift_remove_ipmc_group_member(const sai_thrift_object_id_t member_id)
    {
        printf("sai_thrift_remove_ipmc_group_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ipmc_group_api_t *ipmc_grp_api;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_IPMC_GROUP, (void **) &ipmc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = ipmc_grp_api->remove_ipmc_group_member(member_id);
        
        return status;
    }

	sai_thrift_status_t sai_thrift_set_ipmc_group_member_attribute(const sai_thrift_object_id_t member_id,
                                                                   const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ipmc_group_api_t *ipmc_grp_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_IPMC_GROUP, (void **) &ipmc_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ipmc_grp_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_ipmc_group_member_attributes(thrift_attr_list, &attr);
        
        return ipmc_grp_api->set_ipmc_group_member_attribute(member_id, &attr);
    }

	void sai_thrift_get_ipmc_group_member_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                    const sai_thrift_object_id_t member_id)
    {
        sai_ipmc_group_api_t *ipmc_grp_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
	    sai_object_list_t *member_list_object;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        thrift_attr_list.status = sai_api_query(SAI_API_IPMC_GROUP, (void **) &ipmc_grp_api);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            return;
        }

	    attr_count = 2;
        attr[0].id = SAI_IPMC_GROUP_MEMBER_ATTR_IPMC_GROUP_ID;
        attr[1].id = SAI_IPMC_GROUP_MEMBER_ATTR_IPMC_OUTPUT_ID;
        
        thrift_attr_list.status = ipmc_grp_api->get_ipmc_group_member_attribute(member_id, attr_count, attr);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ipmc group member attribute, status:%d", thrift_attr_list.status);
            return;
        }

        thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_oid(attr[0].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_oid(attr[1].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

	void sai_thrift_parse_ipmc_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
	    	    case SAI_IPMC_ENTRY_ATTR_PACKET_ACTION:
	    		    attr_list[i].value.s32 = attribute.value.s32;
	    		    break;
                case SAI_IPMC_ENTRY_ATTR_OUTPUT_GROUP_ID:
                case SAI_IPMC_ENTRY_ATTR_RPF_GROUP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse ipmc member attributes.");
                    break;
            }
        }
    }

	sai_thrift_object_id_t sai_thrift_create_rpf_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_rpf_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_rpf_group_api_t *rpf_grp_api;
	    sai_object_id_t	grp_oid=0;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_RPF_GROUP, (void **) &rpf_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = rpf_grp_api->create_rpf_group(&grp_oid, gSwitchId, 0, NULL);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to create rpf group, status:%d", status);
        }
        
        return grp_oid;
    }

	sai_thrift_status_t sai_thrift_remove_rpf_group(const sai_thrift_object_id_t grp_id)
    {
        printf("sai_thrift_remove_rpf_group\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_rpf_group_api_t *rpf_grp_api;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_RPF_GROUP, (void **) &rpf_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = rpf_grp_api->remove_rpf_group(grp_id);
        
        return status;
    }

	void sai_thrift_get_rpf_group_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t grp_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_rpf_group_api_t *rpf_grp_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
	    sai_object_list_t *member_list_object;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_RPF_GROUP, (void **) &rpf_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        attr_count = 2;
        attr[0].id = SAI_RPF_GROUP_ATTR_RPF_INTERFACE_COUNT;
        attr[1].id = SAI_RPF_GROUP_ATTR_RPF_MEMBER_LIST;
        attr[1].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 16);
        attr[1].value.objlist.count = 16;
        
        status = rpf_grp_api->get_rpf_group_attribute(grp_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ipmc group attribute, status:%d", status);
	        free(attr[1].value.objlist.list);
            return;
        }
        
        thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_u16(attr[0].value.u16);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = attr[1].id;
        thrift_attr.value.objlist.count = attr[1].value.objlist.count;
	    std::vector<sai_thrift_object_id_t>& member_list = thrift_attr.value.objlist.object_id_list;
        member_list_object = &attr[1].value.objlist;
        for (int index = 0; index < attr[1].value.objlist.count; index++)
        {
            member_list.push_back((sai_thrift_object_id_t) member_list_object->list[index]);
        }
        thrift_attr.value.__isset.objlist = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        free(attr[1].value.objlist.list);
    }

	void sai_thrift_parse_rpf_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                      sai_attribute_t *attr_list)
    {
        std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
        sai_thrift_attribute_t attribute;
        for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++)
        {
            attribute = (sai_thrift_attribute_t)*it;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_RPF_GROUP_MEMBER_ATTR_RPF_GROUP_ID:
                case SAI_RPF_GROUP_MEMBER_ATTR_RPF_INTERFACE_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
        
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse ipmc member attributes.");
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_rpf_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_rpf_group_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_rpf_group_api_t *rpf_grp_api;
	    sai_attribute_t  *sai_attrs = nullptr;
	    sai_object_id_t	member_oid = 0;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_RPF_GROUP, (void **) &rpf_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }

	    sai_uint32_t attr_size = thrift_attr_list.size();

        sai_thrift_alloc_attr(sai_attrs, attr_size);

        sai_thrift_parse_rpf_group_member_attributes(thrift_attr_list, sai_attrs);

        status = rpf_grp_api->create_rpf_group_member(&member_oid, gSwitchId, attr_size, sai_attrs);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to create rpf group member, status:%d", status);
        }

        return member_oid;
    }

	sai_thrift_status_t sai_thrift_remove_rpf_group_member(const sai_thrift_object_id_t member_id)
    {
        printf("sai_thrift_remove_rpf_group_member\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_rpf_group_api_t *rpf_grp_api;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_RPF_GROUP, (void **) &rpf_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
        status = rpf_grp_api->remove_rpf_group_member(member_id);
        
        return status;
    }

	sai_thrift_status_t sai_thrift_set_rpf_group_member_attribute(const sai_thrift_object_id_t member_id,
                                                                  const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_rpf_group_api_t *rpf_grp_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_RPF_GROUP, (void **) &rpf_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain rpf_grp_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_rpf_group_member_attributes(thrift_attr_list, &attr);
        
        return rpf_grp_api->set_rpf_group_member_attribute(member_id, &attr);
    }

	void sai_thrift_get_rpf_group_member_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                   const sai_thrift_object_id_t member_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_rpf_group_api_t *rpf_grp_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
	    sai_object_list_t *member_list_object;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_RPF_GROUP, (void **) &rpf_grp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }

        attr_count = 2;
        attr[0].id = SAI_RPF_GROUP_MEMBER_ATTR_RPF_GROUP_ID;
        attr[1].id = SAI_RPF_GROUP_MEMBER_ATTR_RPF_INTERFACE_ID;

        status = rpf_grp_api->get_rpf_group_member_attribute(member_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain rpf group member attribute, status:%d", status);
            return;
        }

        thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_oid(attr[0].value.oid);
		thrift_attr_list.attr_list.push_back(thrift_attr);

		thrift_attr.id = attr[1].id;
        thrift_attr.value.__set_oid(attr[1].value.oid);
		thrift_attr_list.attr_list.push_back(thrift_attr);
    }

	sai_thrift_status_t sai_thrift_create_ipmc_entry(const sai_thrift_ipmc_entry_t &thrift_ipmc_entry,
                                                     const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_ipmc_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ipmc_api_t *ipmc_api;
        sai_ipmc_entry_t ipmc_entry;
        sai_attribute_t  *sai_attrs = nullptr;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_IPMC, (void **) &ipmc_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }

        sai_thrift_parse_ipmc_entry(thrift_ipmc_entry, &ipmc_entry);

        sai_uint32_t attr_size = thrift_attr_list.size();

        sai_thrift_alloc_attr(sai_attrs, attr_size);

        sai_thrift_parse_ipmc_entry_attributes(thrift_attr_list, sai_attrs);

        status = ipmc_api->create_ipmc_entry(&ipmc_entry, attr_size, sai_attrs);

        return status;
    }

	sai_thrift_status_t sai_thrift_remove_ipmc_entry(const sai_thrift_ipmc_entry_t &thrift_ipmc_entry)
    {
        printf("sai_thrift_remove_ipmc_entry\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ipmc_api_t *ipmc_api;
        sai_ipmc_entry_t ipmc_entry;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_IPMC, (void **) &ipmc_api);
        if (status != SAI_STATUS_SUCCESS)
        {
           return status;
        }
        
	    sai_thrift_parse_ipmc_entry(thrift_ipmc_entry, &ipmc_entry);

        status = ipmc_api->remove_ipmc_entry(&ipmc_entry);

        return status;
    }

	sai_thrift_status_t sai_thrift_set_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t &thrift_ipmc_entry,
                                                            const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ipmc_api_t *ipmc_api;
        sai_ipmc_entry_t ipmc_entry;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_IPMC, (void **) &ipmc_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ipmc_api, status:%d", status);
            return status;
        }

        sai_thrift_parse_ipmc_entry(thrift_ipmc_entry, &ipmc_entry);
        sai_thrift_parse_ipmc_entry_attributes(thrift_attr_list, &attr);

        return ipmc_api->set_ipmc_entry_attribute(&ipmc_entry, &attr);
    }

	void sai_thrift_get_ipmc_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list,
                                             const sai_thrift_ipmc_entry_t &thrift_ipmc_entry)
    {
        sai_ipmc_api_t *ipmc_api;
        sai_ipmc_entry_t ipmc_entry;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        thrift_attr_list.status = sai_api_query(SAI_API_IPMC, (void **) &ipmc_api);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        
        attr_count = 3;
        attr[0].id = SAI_IPMC_ENTRY_ATTR_PACKET_ACTION;
        attr[1].id = SAI_IPMC_ENTRY_ATTR_OUTPUT_GROUP_ID;
        attr[2].id = SAI_IPMC_ENTRY_ATTR_RPF_GROUP_ID;
        
        sai_thrift_parse_ipmc_entry(thrift_ipmc_entry, &ipmc_entry);
        thrift_attr_list.status = ipmc_api->get_ipmc_entry_attribute(&ipmc_entry, attr_count, attr);
        if (thrift_attr_list.status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ipmc entry attribute, status:%d", thrift_attr_list.status);
            return;
        }

        thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);

		thrift_attr.id = attr[1].id;
        thrift_attr.value.__set_oid(attr[1].value.oid);
		thrift_attr_list.attr_list.push_back(thrift_attr);

		thrift_attr.id = attr[2].id;
        thrift_attr.value.__set_oid(attr[2].value.oid);
		thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_object_id_t sai_thrift_create_samplepacket(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_samplepacket_api_t *samplepacket_api = nullptr;
        auto status = sai_api_query(SAI_API_SAMPLEPACKET, reinterpret_cast<void**>(&samplepacket_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_samplepacket_attributes(thrift_attr_list, attr_list);
        
        sai_object_id_t samplepacket_oid = 0;
        status = samplepacket_api->create_samplepacket(&samplepacket_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return samplepacket_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_samplepacket(const sai_thrift_object_id_t samplepacket_id)
    {
        sai_samplepacket_api_t *samplepacket_api;
        sai_status_t status;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_SAMPLEPACKET, (void **) &samplepacket_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain samplepacket_api, status:%d", status);
            return status;
        }
        
        return samplepacket_api->remove_samplepacket((sai_object_id_t) samplepacket_id);
    }

    sai_thrift_status_t sai_thrift_set_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_id,
                                                              const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_samplepacket_api_t *samplepacket_api;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_SAMPLEPACKET, (void **) &samplepacket_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain samplepacket_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_samplepacket_attributes(thrift_attr_list, &attr);
        
        return samplepacket_api->set_samplepacket_attribute(samplepacket_id, &attr);
    }

    void sai_thrift_get_samplepacket_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                               const sai_thrift_object_id_t samplepacket_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_samplepacket_api_t *samplepacket_api;
        uint32_t attr_count = 0;
        sai_attribute_t attr[4];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_SAMPLEPACKET, (void **) &samplepacket_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain samplepacket_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_SAMPLEPACKET_ATTR_SAMPLE_RATE;
        attr[1].id = SAI_SAMPLEPACKET_ATTR_TYPE;
	    attr[2].id = SAI_SAMPLEPACKET_ATTR_MODE;
        attr_count = 3;
        
        status = samplepacket_api->get_samplepacket_attribute(samplepacket_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain samplepacket port type, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_u32(attr[0].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_s32(attr[1].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_s32(attr[2].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_object_id_t sai_thrift_create_tunnel_map_entry(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_tunnel_api_t *tunnel_api = nullptr;
        auto status = sai_api_query(SAI_API_TUNNEL, reinterpret_cast<void**>(&tunnel_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_tunnel_map_entry_attributes(thrift_attr_list, attr_list);
        
        sai_object_id_t tunnel_map_entry_oid = 0;
        status = tunnel_api->create_tunnel_map_entry(&tunnel_map_entry_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return tunnel_map_entry_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_tunnel_map_entry(const sai_thrift_object_id_t tunnel_map_entry_id)
    {
        sai_tunnel_api_t *tunnel_api = nullptr;
        sai_status_t status;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return status;
        }
        
        return tunnel_api->remove_tunnel_map_entry((sai_object_id_t) tunnel_map_entry_id);
    }

    sai_thrift_status_t sai_thrift_set_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_id,
                                                                  const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_tunnel_api_t *tunnel_api = nullptr;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_tunnel_map_entry_attributes(thrift_attr_list, &attr);
        
        return tunnel_api->set_tunnel_map_entry_attribute(tunnel_map_entry_id, &attr);
    }

    void sai_thrift_get_tunnel_map_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                   const sai_thrift_object_id_t tunnel_map_entry_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_tunnel_api_t *tunnel_api = nullptr;
        uint32_t attr_count = 0;
        sai_attribute_t attr[14];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_TUNNEL_MAP_ENTRY_ATTR_TUNNEL_MAP_TYPE;
        attr[1].id = SAI_TUNNEL_MAP_ENTRY_ATTR_TUNNEL_MAP;
	    attr[2].id = SAI_TUNNEL_MAP_ENTRY_ATTR_OECN_KEY;
	    attr[3].id = SAI_TUNNEL_MAP_ENTRY_ATTR_OECN_VALUE;
	    attr[4].id = SAI_TUNNEL_MAP_ENTRY_ATTR_UECN_KEY;
	    attr[5].id = SAI_TUNNEL_MAP_ENTRY_ATTR_UECN_VALUE;
	    attr[6].id = SAI_TUNNEL_MAP_ENTRY_ATTR_VLAN_ID_KEY;
	    attr[7].id = SAI_TUNNEL_MAP_ENTRY_ATTR_VLAN_ID_VALUE;
	    attr[8].id = SAI_TUNNEL_MAP_ENTRY_ATTR_VNI_ID_KEY;
	    attr[9].id = SAI_TUNNEL_MAP_ENTRY_ATTR_VNI_ID_VALUE;
	    attr[10].id = SAI_TUNNEL_MAP_ENTRY_ATTR_BRIDGE_ID_KEY;
	    attr[11].id = SAI_TUNNEL_MAP_ENTRY_ATTR_BRIDGE_ID_VALUE;
	    attr[12].id = SAI_TUNNEL_MAP_ENTRY_ATTR_VIRTUAL_ROUTER_ID_KEY;
	    attr[13].id = SAI_TUNNEL_MAP_ENTRY_ATTR_VIRTUAL_ROUTER_ID_VALUE;
        attr_count = 14;
        
        status = tunnel_api->get_tunnel_map_entry_attribute(tunnel_map_entry_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel map entry type, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[1].id;
	    thrift_attr.value.__set_oid(attr[1].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[2].id;
	    thrift_attr.value.__set_u8(attr[2].value.u8);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[3].id;
	    thrift_attr.value.__set_u8(attr[3].value.u8);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[4].id;
	    thrift_attr.value.__set_u8(attr[4].value.u8);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[5].id;
	    thrift_attr.value.__set_u8(attr[5].value.u8);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[6].id;
	    thrift_attr.value.__set_u16(attr[6].value.u16);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[7].id;
	    thrift_attr.value.__set_u16(attr[7].value.u16);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[8].id;
	    thrift_attr.value.__set_u32(attr[8].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[9].id;
	    thrift_attr.value.__set_u32(attr[9].value.u32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[10].id;
	    thrift_attr.value.__set_oid(attr[10].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[11].id;
	    thrift_attr.value.__set_oid(attr[11].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[12].id;
	    thrift_attr.value.__set_oid(attr[12].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
	    thrift_attr.id = attr[13].id;
	    thrift_attr.value.__set_oid(attr[13].value.oid);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_object_id_t sai_thrift_create_tunnel_map(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_tunnel_api_t *tunnel_api = nullptr;
        auto status = sai_api_query(SAI_API_TUNNEL, reinterpret_cast<void**>(&tunnel_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_tunnel_map_attributes(thrift_attr_list, attr_list);
        
        sai_object_id_t tunnel_map_oid = 0;
        status = tunnel_api->create_tunnel_map(&tunnel_map_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return tunnel_map_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_tunnel_map(const sai_thrift_object_id_t tunnel_map_id)
    {
        sai_tunnel_api_t *tunnel_api = nullptr;
        sai_status_t status;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return status;
        }
        
        return tunnel_api->remove_tunnel_map((sai_object_id_t) tunnel_map_id);
    }

    sai_thrift_status_t sai_thrift_set_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_id,
                                                            const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_tunnel_api_t *tunnel_api = nullptr;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_tunnel_map_attributes(thrift_attr_list, &attr);
        
        return tunnel_api->set_tunnel_map_attribute(tunnel_map_id, &attr);
    }

    void sai_thrift_get_tunnel_map_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t tunnel_map_id)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_tunnel_api_t *tunnel_api = nullptr;
        uint32_t attr_count = 0;
        sai_attribute_t attr[2];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_TUNNEL_MAP_ATTR_TYPE;
	    attr[1].id = SAI_TUNNEL_MAP_ATTR_ENTRY_LIST;
	    attr[1].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 128);
        attr[1].value.objlist.count = 128;
        attr_count = 2;
        
        status = tunnel_api->get_tunnel_map_attribute(tunnel_map_id, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel map type, status:%d", status);
            return;
        }
        
	    thrift_attr.id = attr[0].id;
	    thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = attr[1].id;
	    thrift_attr.value.objlist.count = attr[1].value.objlist.count;
	    sai_object_list_t *map_entry_list_object;
	    std::vector<sai_thrift_object_id_t>& map_entry_list = thrift_attr.value.objlist.object_id_list;
        map_entry_list_object = &attr[1].value.objlist;
        for (int index = 0; index < attr[1].value.objlist.count; index++)
        {
            map_entry_list.push_back((sai_thrift_object_id_t) map_entry_list_object->list[index]);
        }
        thrift_attr.value.__isset.objlist = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
	    free(attr[1].value.objlist.list);
    }

    sai_thrift_object_id_t sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_tunnel_api_t *tunnel_api = nullptr;
	    sai_object_id_t *mapper_list = NULL;
        auto status = sai_api_query(SAI_API_TUNNEL, reinterpret_cast<void**>(&tunnel_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_tunnel_attributes(thrift_attr_list, attr_list, &mapper_list);
        
        sai_object_id_t tunnel_oid = 0;
        status = tunnel_api->create_tunnel(&tunnel_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (mapper_list) free(mapper_list);
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return tunnel_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_tunnel(const sai_thrift_object_id_t tunnel_id)
    {
        sai_tunnel_api_t *tunnel_api = nullptr;
        sai_status_t status;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return status;
        }
        
        return tunnel_api->remove_tunnel((sai_object_id_t) tunnel_id);
    }

    sai_thrift_status_t sai_thrift_set_tunnel_attribute(const sai_thrift_object_id_t tunnel_id,
                                                        const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_tunnel_api_t *tunnel_api = nullptr;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
	    sai_object_id_t *mapper_list = NULL;
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_tunnel_attributes(thrift_attr_list, &attr, &mapper_list);
	    if (mapper_list) free(mapper_list);
        status = tunnel_api->set_tunnel_attribute(tunnel_id, &attr);
        
	    return status;
    }

    void sai_thrift_get_tunnel_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
  	                                     const sai_thrift_object_id_t tunnel_id,
  	                                     const std::vector < int32_t > & thrift_attr_ids)
    {
	    sai_status_t status = SAI_STATUS_SUCCESS;
	    sai_tunnel_api_t *tunnel_api = nullptr;
	    sai_thrift_attribute_t thrift_attr;
	    int32_t mem_list[3] = {-1,-1,-1};
	    uint32_t a =0;
        
	    SAI_THRIFT_FUNC_LOG();
        
	    thrift_attr_list.attr_count = 0;
        
	    status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
	    if (status != SAI_STATUS_SUCCESS)
        {
	    	SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
	    	return;
	    }

	    uint32_t attr_count = thrift_attr_ids.size();
	    sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_ids.size());
	    memset(attr_list, 0x0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
	    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
        
	    for (uint32_t i = 0; i < attr_count; i++)
	    {
	    	switch(attr_list[i].id)
	    	{
	    		case SAI_TUNNEL_ATTR_TYPE:
	    		case SAI_TUNNEL_ATTR_ENCAP_TTL_MODE:
	    		case SAI_TUNNEL_ATTR_ENCAP_DSCP_MODE:
	    		case SAI_TUNNEL_ATTR_ENCAP_ECN_MODE:
	    		case SAI_TUNNEL_ATTR_DECAP_ECN_MODE:
	    		case SAI_TUNNEL_ATTR_DECAP_TTL_MODE:
	    		case SAI_TUNNEL_ATTR_DECAP_DSCP_MODE:
	    		case SAI_TUNNEL_ATTR_UNDERLAY_INTERFACE:
	    		case SAI_TUNNEL_ATTR_OVERLAY_INTERFACE:
	    		case SAI_TUNNEL_ATTR_ENCAP_SRC_IP:
	    		case SAI_TUNNEL_ATTR_ENCAP_TTL_VAL:
	    		case SAI_TUNNEL_ATTR_ENCAP_DSCP_VAL:
	    		case SAI_TUNNEL_ATTR_ENCAP_GRE_KEY_VALID:
	    		case SAI_TUNNEL_ATTR_ENCAP_GRE_KEY:
                case SAI_TUNNEL_ATTR_ENCAP_NEXTHOP_ID:
                case SAI_TUNNEL_ATTR_DECAP_MPLS_PW_MODE:
                case SAI_TUNNEL_ATTR_DECAP_MPLS_PW_WITH_CW:
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_WITH_CW:
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_TAGGED_VLAN:
                case SAI_TUNNEL_ATTR_DECAP_ESI_LABEL_VALID:
                case SAI_TUNNEL_ATTR_ENCAP_ESI_LABEL_VALID:
                case SAI_TUNNEL_ATTR_DECAP_EXP_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_EXP_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_EXP_VAL:
	    			break;
	    		case SAI_TUNNEL_ATTR_ENCAP_MAPPERS:
	    		case SAI_TUNNEL_ATTR_DECAP_MAPPERS:
	    		case SAI_TUNNEL_ATTR_TERM_TABLE_ENTRY_LIST:
	    			attr_list[i].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * CNT_UNSUPPORT);
	    			mem_list[a] = i;
	    			a++;
	    			attr_list[i].value.objlist.count = CNT_UNSUPPORT;
	    			break;
	    	    default:
	    			return;
	    	}
	    }
        
	    status = tunnel_api->get_tunnel_attribute(tunnel_id, attr_count, attr_list);
	    if (status != SAI_STATUS_SUCCESS)
        {
	    	SAI_THRIFT_LOG_ERR("failed to obtain tunnel type, status:%d", status);
	    	thrift_attr_list.status = status;
	    	for (uint32_t a = 0; a < 3; a++)
	    	{
                if(0 <= mem_list[a])
                {
                    free(attr_list[mem_list[a]].value.objlist.list);
                }
	    	}

	    	free(attr_list);
	    	return;
	    }
        
	    for (uint32_t i = 0; i < attr_count; i++)
	    {
	    	switch(attr_list[i].id)
	    	{
	    		case SAI_TUNNEL_ATTR_TYPE:
                    thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.__set_s32(attr_list[i].value.s32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
	    			break;
	    		case SAI_TUNNEL_ATTR_UNDERLAY_INTERFACE:
	    		case SAI_TUNNEL_ATTR_OVERLAY_INTERFACE:
                case SAI_TUNNEL_ATTR_ENCAP_NEXTHOP_ID:
	    			thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.__set_oid(attr_list[i].value.oid);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
	    			break;
	    		case SAI_TUNNEL_ATTR_ENCAP_SRC_IP:
  	    	  	    thrift_attr.id        = attr_list[i].id;
	    			thrift_attr.value.ipaddr.addr_family = attr_list[i].value.ipaddr.addr_family;
  	    	        if (SAI_IP_ADDR_FAMILY_IPV4 == attr_list[i].value.ipaddr.addr_family)
  	    	        {
  	    	            thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(attr_list[i].value.ipaddr.addr.ip4);
  	    	        }
  	    	        else
  	    	        {
  	    	            //thrift_attr.value.ipaddr.addr.ip6 = sai_thrift_v4_ip_to_string(attr[i].value.ipaddr.addr.ip4);
  	    	        }
                    thrift_attr.value.__isset.ipaddr = true;
                    thrift_attr.value.ipaddr.__isset.addr_family = true;
                    thrift_attr.value.ipaddr.__isset.addr = true;
                    thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
  	    	        thrift_attr_list.attr_list.push_back(thrift_attr);
	    			break;
                case SAI_TUNNEL_ATTR_ENCAP_TTL_MODE:
	    		case SAI_TUNNEL_ATTR_ENCAP_DSCP_MODE:
	    		case SAI_TUNNEL_ATTR_ENCAP_ECN_MODE:
	    		case SAI_TUNNEL_ATTR_DECAP_ECN_MODE:
	    		case SAI_TUNNEL_ATTR_DECAP_TTL_MODE:
	    		case SAI_TUNNEL_ATTR_DECAP_DSCP_MODE:
                case SAI_TUNNEL_ATTR_DECAP_MPLS_PW_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_MODE:
                case SAI_TUNNEL_ATTR_DECAP_EXP_MODE:
                case SAI_TUNNEL_ATTR_ENCAP_EXP_MODE:
	    		case SAI_TUNNEL_ATTR_ENCAP_TTL_VAL:
	    		case SAI_TUNNEL_ATTR_ENCAP_DSCP_VAL:
                case SAI_TUNNEL_ATTR_ENCAP_EXP_VAL:
	    			thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.__set_u8(attr_list[i].value.u8);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
	    			break;
	    		case SAI_TUNNEL_ATTR_ENCAP_GRE_KEY_VALID:
                case SAI_TUNNEL_ATTR_DECAP_MPLS_PW_WITH_CW:
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_WITH_CW:
                case SAI_TUNNEL_ATTR_DECAP_ESI_LABEL_VALID:
                case SAI_TUNNEL_ATTR_ENCAP_ESI_LABEL_VALID:
	    			thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.__set_booldata(attr_list[i].value.booldata);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
	    			break;
                case SAI_TUNNEL_ATTR_ENCAP_MPLS_PW_TAGGED_VLAN:
                    thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.__set_u16(attr_list[i].value.u16);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
	    		case SAI_TUNNEL_ATTR_ENCAP_GRE_KEY:
	    			thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.__set_u32(attr_list[i].value.u32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
	    			break;
	    		case SAI_TUNNEL_ATTR_ENCAP_MAPPERS:
	    		case SAI_TUNNEL_ATTR_DECAP_MAPPERS:
	    		case SAI_TUNNEL_ATTR_TERM_TABLE_ENTRY_LIST:
	    		    {
	    				sai_object_list_t *map_entry_list_object;
	    				thrift_attr.id = attr_list[i].id;
	    				thrift_attr.value.objlist.count = attr_list[i].value.objlist.count;
	    				std::vector<sai_thrift_object_id_t>& map_entry_list = thrift_attr.value.objlist.object_id_list;
	    				map_entry_list_object = &attr_list[i].value.objlist;
	    				for (int index = 0; index < attr_list[i].value.objlist.count; index++)
                        {
	    				    map_entry_list.push_back((sai_thrift_object_id_t) map_entry_list_object->list[index]);
	    				}
                        thrift_attr.value.__isset.objlist = true;
	    				thrift_attr_list.attr_list.push_back(thrift_attr);
	    				free(attr_list[i].value.objlist.list);
	    			}
	    			break;
	    		default:
	    			SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
	    			break;
            }
        }
        
 	    if(attr_list)
 	    {
 	        free(attr_list);
 	    }
	    return;
    }
    
    void sai_thrift_get_tunnel_stats(std::vector<int64_t> & thrift_counters,
                                     const sai_thrift_object_id_t tunnel_id,
                                     const std::vector<sai_thrift_queue_stat_counter_t> & thrift_counter_ids,
                                     const int32_t number_of_counters)
    {
        printf("sai_thrift_get_tunnel_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_tunnel_api_t *tunnel_api = nullptr;
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_tunnel_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_tunnel_stat_t) *it;
        }
        
        status = tunnel_api->get_tunnel_stats(
                               (sai_object_id_t) tunnel_id,
                               number_of_counters,
                               counter_ids,
                               counters);
        
        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }
        free(counter_ids);
        free(counters);
        return;
    }

    sai_thrift_status_t sai_thrift_clear_tunnel_stats(const sai_thrift_object_id_t queue_id,
                                                      const std::vector<sai_thrift_queue_stat_counter_t> & thrift_counter_ids,
                                                      const int32_t number_of_counters)
    {
        printf("sai_thrift_clear_queue_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_tunnel_api_t *tunnel_api=nullptr;
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_tunnel_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_tunnel_stat_t) *it;
        }
        
        status = tunnel_api->clear_tunnel_stats(
                               (sai_object_id_t) queue_id,
                               number_of_counters,
                               counter_ids);
        
        free(counter_ids);
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_tunnel_term_table_entry
    (const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_tunnel_api_t *tunnel_api = nullptr;
        auto status = sai_api_query(SAI_API_TUNNEL, reinterpret_cast<void**>(&tunnel_api));
        
        if (status != SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_ERR("Failed to get API."); return SAI_NULL_OBJECT_ID; }
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_tunnel_term_table_entry_attributes(thrift_attr_list, attr_list);
        
        sai_object_id_t tunnel_term_table_entry_oid = 0;
        status = tunnel_api->create_tunnel_term_table_entry(&tunnel_term_table_entry_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        { SAI_THRIFT_LOG_DBG("Exited."); return tunnel_term_table_entry_oid; }
        
        SAI_THRIFT_LOG_ERR("Failed to create OID.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t tunnel_term_table_entry_id)
    {
        sai_tunnel_api_t *tunnel_api = nullptr;
        sai_status_t status;
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return status;
        }
    
        return tunnel_api->remove_tunnel_term_table_entry((sai_object_id_t) tunnel_term_table_entry_id);
    }

    sai_thrift_status_t sai_thrift_set_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_id,
                                                                         const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_tunnel_api_t *tunnel_api = nullptr;
        sai_attribute_t attr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_tunnel_term_table_entry_attributes(thrift_attr_list, &attr);
        
        return tunnel_api->set_tunnel_term_table_entry_attribute(tunnel_term_table_entry_id, &attr);
    }

    void sai_thrift_get_tunnel_term_table_entry_attribute(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                          const sai_thrift_object_id_t tunnel_term_table_entry_id,
                                                          const std::vector < int32_t > & thrift_attr_ids)
    {
	    sai_status_t status = SAI_STATUS_SUCCESS;
	    sai_tunnel_api_t *tunnel_api = nullptr;
	    sai_thrift_attribute_t thrift_attr;
        
	    SAI_THRIFT_FUNC_LOG();
        
	    thrift_attr_list.attr_count = 0;
        
	    status = sai_api_query(SAI_API_TUNNEL, (void **) &tunnel_api);
	    if (status != SAI_STATUS_SUCCESS)
        {
	    	SAI_THRIFT_LOG_ERR("failed to obtain tunnel_api, status:%d", status);
	    	return;
	    }
        
	    uint32_t attr_count = thrift_attr_ids.size();
	    sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_ids.size());
	    memset(attr_list, 0x0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
	    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
        
	    for (uint32_t i = 0; i < attr_count; i++)
	    {
	    	switch(attr_list[i].id)
	    	{
	    		  case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TYPE:
	    		  case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TUNNEL_TYPE:
	    	      case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_VR_ID:
	    	      case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_ACTION_TUNNEL_ID:
	    		  case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_DST_IP:
	    		  case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_SRC_IP:
	    		  	  break;
	    		  default:
	    			return;
	    	}
	    }
        
	    status = tunnel_api->get_tunnel_term_table_entry_attribute(tunnel_term_table_entry_id, attr_count, attr_list);
	    if (status != SAI_STATUS_SUCCESS)
        {
	    	SAI_THRIFT_LOG_ERR("failed to obtain tunnel term table entry attr, status:%d", status);
	    	return;
	    }

	    for (uint32_t i = 0; i < attr_count; i++)
	    {
		    switch(attr_list[i].id)
		    {
			    case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TYPE:
			    case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TUNNEL_TYPE:
                    thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.__set_s32(attr_list[i].value.s32);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
				    break;
		        case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_VR_ID:
		        case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_ACTION_TUNNEL_ID:
                    thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.__set_oid(attr_list[i].value.oid);
                    thrift_attr_list.attr_list.push_back(thrift_attr);
                    break;
                case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_DST_IP:
                case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_SRC_IP:
                    thrift_attr.id        = attr_list[i].id;
                    thrift_attr.value.ipaddr.addr_family = attr_list[i].value.ipaddr.addr_family;
                    if (SAI_IP_ADDR_FAMILY_IPV4 == attr_list[i].value.ipaddr.addr_family)
                    {
                        thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(attr_list[i].value.ipaddr.addr.ip4);
                    }
                    else
                    {
                        //thrift_attr.value.ipaddr.addr.ip6 = sai_thrift_v4_ip_to_string(attr[i].value.ipaddr.addr.ip4);
                    }
                    thrift_attr.value.__isset.ipaddr = true;
                    thrift_attr.value.ipaddr.__isset.addr_family = true;
                    thrift_attr.value.ipaddr.__isset.addr = true;
                    thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
  		            thrift_attr_list.attr_list.push_back(thrift_attr);
			  	    break;
			    default:
				    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
				    break;
            }
        }

 	    if(attr_list)
 	    {
 	        free(attr_list);
 	    }
	    return;
    }
    
    void sai_thrift_get_cpu_packet_attribute(sai_thrift_attribute_list_t& thrift_attr_list) {
        sai_thrift_attribute_t thrift_attr;
        uint32_t index = 0;
    
        SAI_THRIFT_FUNC_LOG();
    
        thrift_attr_list.attr_count = 0;
        for (index = 0; index< packet_rx_attr_count; index++)
        {
            switch(packet_rx_attr[index].id)
            {
                  case SAI_HOSTIF_PACKET_ATTR_HOSTIF_TRAP_ID:
                  case SAI_HOSTIF_PACKET_ATTR_INGRESS_PORT:
                  case SAI_HOSTIF_PACKET_ATTR_INGRESS_LAG:
                  case SAI_HOSTIF_PACKET_ATTR_BRIDGE_ID:
                      thrift_attr.id = packet_rx_attr[index].id;
                      thrift_attr.value.__set_oid(packet_rx_attr[index].value.oid);
                      thrift_attr_list.attr_list.push_back(thrift_attr);
                      break;
                  case SAI_HOSTIF_PACKET_ATTR_TIMESTAMP:
                      thrift_attr.id = packet_rx_attr[index].id;
                      thrift_attr.value.timespec.tv_sec = packet_rx_attr[index].value.timespec.tv_sec;
                      thrift_attr.value.timespec.__isset.tv_sec= true;
                      thrift_attr.value.timespec.tv_nsec = packet_rx_attr[index].value.timespec.tv_nsec;
                      thrift_attr.value.timespec.__isset.tv_nsec = true;
                      thrift_attr.value.__isset.timespec = true;
                      thrift_attr_list.attr_list.push_back(thrift_attr);
                      break;  
                  case SAI_HOSTIF_PACKET_ATTR_Y1731_RXFCL:
                      thrift_attr.id = packet_rx_attr[index].id;
                      thrift_attr.value.__set_u64(packet_rx_attr[index].value.u64);
                      thrift_attr_list.attr_list.push_back(thrift_attr);
                      break;                     
            }
        }     
    }


    void sai_thrift_get_cpu_packet_count(sai_thrift_result_t &ret)
    {
	    uint32_t index = 0;
        
        SAI_THRIFT_FUNC_LOG();
        
        ret.data.u16 = packets_rx_count;
	    ret.status = SAI_STATUS_SUCCESS;
        
        ret.__isset.status = true;
        ret.__isset.data = true;
        ret.data.__isset.u16 = true;
    }
    
    void sai_thrift_clear_cpu_packet_info(sai_thrift_result_t &ret)
    {
	    sai_thrift_attribute_t thrift_attr;
	    uint32_t index = 0;
        
        SAI_THRIFT_FUNC_LOG();
        
	    packets_rx_count = 0;
	    memset(&packet_rx_attr, 0, sizeof(packet_rx_attr));
        
	    ret.status = SAI_STATUS_SUCCESS;
        ret.__isset.status = true;
    }

    sai_thrift_status_t sai_thrift_log_set(const int32_t sai_api_id,  const int32_t  log_level)
    {
        SAI_THRIFT_FUNC_LOG();
	    return sai_log_set((sai_api_t)sai_api_id, (sai_log_level_t)log_level);
    }

    sai_thrift_object_id_t sai_thrift_create_isolation_group(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        sai_isolation_group_api_t *isolation_group_api = nullptr;
        auto status = sai_api_query(SAI_API_ISOLATION_GROUP, reinterpret_cast < void** > (&isolation_group_api));
        
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get isolation group API.");
            return SAI_NULL_OBJECT_ID;
        }
        
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_isolation_group_attributes(thrift_attr_list, attr_list);
        
        sai_object_id_t isolation_group_oid = 0;
        status = isolation_group_api->create_isolation_group(&isolation_group_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            return isolation_group_oid;
        }
        
        SAI_THRIFT_LOG_ERR("Failed to create isolation group.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_isolation_group(const sai_thrift_object_id_t iso_group_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_isolation_group_api_t *isolation_group_api = nullptr;
        status = sai_api_query(SAI_API_ISOLATION_GROUP, reinterpret_cast < void** > (&isolation_group_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = isolation_group_api->remove_isolation_group(iso_group_oid);
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_isolation_group_member(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_isolation_group_api_t *isolation_group_api = nullptr;
        status = sai_api_query(SAI_API_ISOLATION_GROUP, reinterpret_cast < void** > (&isolation_group_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_isolation_group_member_attributes(thrift_attr_list, attr_list);
        sai_object_id_t isolation_group_member_oid = 0;
        status = isolation_group_api->create_isolation_group_member(&isolation_group_member_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            return isolation_group_member_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create isolation group.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_isolation_group_member(const sai_thrift_object_id_t member_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_isolation_group_api_t *isolation_group_api = nullptr;
        status = sai_api_query(SAI_API_ISOLATION_GROUP, reinterpret_cast < void** > (&isolation_group_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = isolation_group_api->remove_isolation_group_member(member_oid);
        return status;
    }

    void sai_thrift_get_isolation_group_attributes(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                   const sai_thrift_object_id_t iso_group_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_isolation_group_api_t *iso_group_api;
        sai_attribute_t attr[2];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **) &iso_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ISOLATION_GROUP api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_ISOLATION_GROUP_ATTR_TYPE;
        attr[1].id = SAI_ISOLATION_GROUP_ATTR_ISOLATION_MEMBER_LIST;
	    attr[1].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 128);
        
        status = iso_group_api->get_isolation_group_attribute(iso_group_oid, 2, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain vlan member attributes, status:%d", status);
            return;
        }
	    thrift_attr.id = SAI_ISOLATION_GROUP_ATTR_TYPE;
	    thrift_attr.value.__set_s32(attr[0].value.s32);
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    thrift_attr.id = SAI_ISOLATION_GROUP_ATTR_ISOLATION_MEMBER_LIST;
	    thrift_attr.value.objlist.count = attr[1].value.objlist.count;
	    std::vector < sai_thrift_object_id_t > & iso_grp_member_list = thrift_attr.value.objlist.object_id_list;
	    for (int index = 0; index < attr[1].value.objlist.count; index++)
        {
            iso_grp_member_list.push_back((sai_thrift_object_id_t) attr[1].value.objlist.list[index]);
        }
        thrift_attr.value.__isset.objlist = true;
	    thrift_attr_list.attr_list.push_back(thrift_attr);
        
	    free(attr[1].value.objlist.list);
    }

    void sai_thrift_get_isolation_group_member_attributes(sai_thrift_attribute_list_t& thrift_attr_list, 
                                                          const sai_thrift_object_id_t member_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_isolation_group_api_t *iso_group_api;
        sai_attribute_t attr[2];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **) &iso_group_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ISOLATION_GROUP api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_ISOLATION_GROUP_MEMBER_ATTR_ISOLATION_GROUP_ID;
        attr[1].id = SAI_ISOLATION_GROUP_MEMBER_ATTR_ISOLATION_OBJECT;
        
        status = iso_group_api->get_isolation_group_member_attribute(member_oid, 2, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain vlan member attributes, status:%d", status);
            return;
        }
        thrift_attr.id = SAI_ISOLATION_GROUP_MEMBER_ATTR_ISOLATION_GROUP_ID;
        thrift_attr.value.__set_oid(attr[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = SAI_ISOLATION_GROUP_MEMBER_ATTR_ISOLATION_OBJECT;
	    thrift_attr.value.__set_oid(attr[1].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    sai_thrift_object_id_t sai_thrift_create_counter(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_counter_api_t *counter_api = nullptr;
        status = sai_api_query(SAI_API_COUNTER, reinterpret_cast < void** > (&counter_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_counter_attributes(thrift_attr_list, attr_list);
        sai_object_id_t counter_oid = 0;
        status = counter_api->create_counter(&counter_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            return counter_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create counter.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_counter(const sai_thrift_object_id_t counter_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_counter_api_t *counter_api = nullptr;
        status = sai_api_query(SAI_API_COUNTER, reinterpret_cast < void** > (&counter_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = counter_api->remove_counter(counter_oid);
        return status;
    }

    sai_thrift_status_t sai_thrift_set_counter_attribute(const sai_thrift_object_id_t counter_oid,
                                                         const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_counter_api_t *counter_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        
        status = sai_api_query(SAI_API_COUNTER, (void **) &counter_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain counter_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_counter_attributes(thrift_attr_list, attr_list);
        
        return counter_api->set_counter_attribute(counter_oid, attr_list);
    }

    void sai_thrift_get_counter_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t counter_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_counter_api_t *counter_api = nullptr;
        uint32_t attr_count = 1;
        sai_attribute_t attr[SAI_COUNTER_ATTR_END];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_COUNTER, (void **) &counter_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain counter_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_COUNTER_ATTR_TYPE;
        
        status = counter_api->get_counter_attribute(counter_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain counter type, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
	    thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_s32 (attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    void sai_thrift_get_counter_stats(std::vector<int64_t> & thrift_counters,
                                      const sai_thrift_object_id_t counter_id,
                                      const std::vector<sai_thrift_stat_id_t> & thrift_counter_ids,
                                      const int32_t number_of_counters)
    {
        printf("sai_thrift_get_counter_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_counter_api_t *counter_api = nullptr;
        status = sai_api_query(SAI_API_COUNTER, (void **) &counter_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_counter_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_tunnel_stat_t) *it;
        }
        
        status = counter_api->get_counter_stats(
                               (sai_object_id_t) counter_id,
                               number_of_counters,
                               counter_ids,
                               counters);
        
        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }
        free(counter_ids);
        free(counters);
        return;
    }

    void sai_thrift_get_counter_stats_ext(std::vector<int64_t> &thrift_counters,
  	                                      const sai_thrift_object_id_t counter_id,
  	                                      const std::vector<sai_thrift_stat_id_t> &thrift_counter_ids,
  	                                      int8_t mode,
  	                                      int32_t number_of_counters)
  	{
		printf("sai_thrift_get_counter_stats_ext\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_counter_api_t *counter_api = nullptr;
        status = sai_api_query(SAI_API_COUNTER, (void **) &counter_api);

        if (status != SAI_STATUS_SUCCESS) { return; }

        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_counter_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
		memset(counter_ids, 0, sizeof(sai_counter_stat_t) * thrift_counter_ids.size());
		memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());

        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
        	counter_ids[i] = (sai_counter_stat_t) *it;
		}

        status = counter_api->get_counter_stats_ext(counter_id,
                                          number_of_counters,
                                          counter_ids,
                                          (sai_stats_mode_t)mode,
                                          counters);

        for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) { thrift_counters.push_back(counters[i]); }

        free(counter_ids);
        free(counters);

        return;
  	}

    sai_thrift_status_t sai_thrift_clear_counter_stats(const sai_thrift_object_id_t counter_id,
  	                                                   const std::vector<sai_thrift_stat_id_t> &thrift_counter_ids,
  	                                                   int32_t number_of_counters)
    {
        printf("sai_thrift_clear_counter_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_counter_api_t *counter_api = nullptr;
        status = sai_api_query(SAI_API_COUNTER, (void **) &counter_api);
        
        if (status != SAI_STATUS_SUCCESS) { return status; }
        
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_counter_stat_t) * thrift_counter_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
	    memset(counter_ids, 0, sizeof(sai_counter_stat_t) * thrift_counter_ids.size());
	    memset(counters, 0, sizeof(uint64_t) * thrift_counter_ids.size());
        
        for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++)
        {
        	counter_ids[i] = (sai_counter_stat_t) *it;
	    }
        
        status = counter_api->clear_counter_stats(counter_id,
                                          number_of_counters,
                                          counter_ids);
        
        free(counter_ids);
        free(counters);
        
        return status;
    }

    sai_thrift_object_id_t sai_thrift_create_debug_counter(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_debug_counter_api_t *debug_counter_api = nullptr;
        status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **) &debug_counter_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_debug_counter_attributes(thrift_attr_list, attr_list);
        sai_object_id_t counter_oid = 0;
        status = debug_counter_api->create_debug_counter(&counter_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            return counter_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create debug counter object.");
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_debug_counter(const sai_thrift_object_id_t counter_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_debug_counter_api_t *debug_counter_api = nullptr;
        status = sai_api_query(SAI_API_DEBUG_COUNTER, reinterpret_cast < void** > (&debug_counter_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = debug_counter_api->remove_debug_counter(counter_oid);
        return status;
    }

    sai_thrift_status_t sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t counter_oid,
                                                               const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_debug_counter_api_t *debug_counter_api = nullptr;
        sai_attribute_t attr[SAI_DEBUG_COUNTER_ATTR_END];
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
    
        SAI_THRIFT_FUNC_LOG();
    
        status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **) &debug_counter_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain debug_counter_api, status:%d", status);
            return status;
        }
    
        sai_thrift_parse_debug_counter_attributes(thrift_attr_list, attr);
    
        return debug_counter_api->set_debug_counter_attribute(counter_oid, attr);
    }

    void sai_thrift_get_debug_counter_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t counter_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_debug_counter_api_t *debug_counter_api = nullptr;
        uint32_t attr_count = 5, index = 0;
        sai_attribute_t attr[SAI_DEBUG_COUNTER_ATTR_END];
	    sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **) &debug_counter_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain debug_counter_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_DEBUG_COUNTER_ATTR_BIND_METHOD;
        attr[1].id = SAI_DEBUG_COUNTER_ATTR_INDEX;
        attr[2].id = SAI_DEBUG_COUNTER_ATTR_TYPE;
        
        attr[3].id = SAI_DEBUG_COUNTER_ATTR_IN_DROP_REASON_LIST;
        attr[3].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * CNT_UNSUPPORT);
        attr[3].value.s32list.count = CNT_UNSUPPORT;
        
        attr[4].id = SAI_DEBUG_COUNTER_ATTR_OUT_DROP_REASON_LIST;
        attr[4].value.s32list.list = (int32_t *) malloc(sizeof(int32_t) * CNT_UNSUPPORT);
        attr[4].value.s32list.count = CNT_UNSUPPORT;
        
        status = debug_counter_api->get_debug_counter_attribute(counter_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain debug counter attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
	    thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_s32 (attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        thrift_attr.id = attr[1].id;
        thrift_attr.value.__set_u32 (attr[1].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        thrift_attr.id = attr[2].id;
        thrift_attr.value.__set_s32 (attr[2].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        
        thrift_attr.id = attr[3].id;
	    thrift_attr.value.s32list.count = attr[3].value.s32list.count;
        std::vector < sai_int32_t > & bind_point_list = thrift_attr.value.s32list.s32list;
        for (index = 0; index < attr[3].value.s32list.count; index++)
        {
            bind_point_list.push_back((sai_int32_t) attr[3].value.s32list.list[index]);
        }
        thrift_attr.value.__isset.s32list = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = attr[4].id;
	    thrift_attr.value.s32list.count = attr[4].value.s32list.count;
        std::vector < sai_int32_t > & bind_point_list1 = thrift_attr.value.s32list.s32list;
        for (index = 0; index < attr[4].value.s32list.count; index++)
        {
            bind_point_list1.push_back((sai_int32_t) attr[4].value.s32list.list[index]);
        }
        thrift_attr.value.__isset.s32list = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        if(attr[3].value.s32list.list)
        {
            free(attr[3].value.s32list.list);
        }
        if(attr[4].value.s32list.list)
        {
            free(attr[4].value.s32list.list);
        }
    }

    sai_thrift_status_t sai_thrift_create_nat(const sai_thrift_nat_entry_t &thrift_nat_entry, 
                                              const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        printf("sai_thrift_create_nat\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_nat_api_t *nat_api;
        sai_nat_entry_t nat_entry;
        status = sai_api_query(SAI_API_NAT, (void **) &nat_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parse_nat_entry(thrift_nat_entry, &nat_entry);
        sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
        sai_thrift_parse_nat_attributes(thrift_attr_list, attr_list);
        uint32_t attr_count = thrift_attr_list.size();
        status = nat_api->create_nat_entry(&nat_entry, attr_count, attr_list);
        free(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set create nat entry, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_remove_nat(const sai_thrift_nat_entry_t &thrift_nat_entry)
    {
        printf("sai_thrift_remove_nat\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_nat_api_t *nat_api;
        sai_nat_entry_t nat_entry;
        status = sai_api_query(SAI_API_NAT, (void **) &nat_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_parse_nat_entry(thrift_nat_entry, &nat_entry);
        status = nat_api->remove_nat_entry(&nat_entry);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set remove nat entry, status:%d", status);
        }
        return status;
    }

    sai_thrift_status_t sai_thrift_set_nat_attribute(const sai_thrift_nat_entry_t& thrift_nat_entry, 
                                                     const sai_thrift_attribute_t& thrift_attr)
    {
        printf("sai_thrift_set_nat_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        sai_nat_api_t *nat_api;
        sai_nat_entry_t nat_entry;
        sai_attribute_t *attr_list = nullptr;
        status = sai_api_query(SAI_API_NAT, (void **) &nat_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_thrift_alloc_attr(attr_list, 1);
        sai_thrift_parse_nat_entry(thrift_nat_entry, &nat_entry);
        sai_thrift_parse_nat_attributes(thrift_attr_list, attr_list);
        status = nat_api->set_nat_entry_attribute(&nat_entry, attr_list);
        sai_thrift_free_attr(attr_list);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to set nat attributes, status:%d", status);
        }
        return status;
    }

    void sai_thrift_get_nat_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_nat_entry_t& thrift_nat_entry)
    {
        printf("sai_thrift_get_route_attribute\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_nat_api_t *nat_api;
        sai_nat_entry_t nat_entry;
        sai_attribute_t attr[SAI_NAT_ENTRY_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint32_t attr_cnt = 0;
        
        status = sai_api_query(SAI_API_NAT, (void **) &nat_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            thrift_attr_list.status = status;
            return;
        }
        
        sai_thrift_parse_nat_entry(thrift_nat_entry, &nat_entry);
        
        attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_NAT_TYPE;
        attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_SRC_IP;
        //attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_SRC_IP_MASK;
        attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_DST_IP;
        //attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_DST_IP_MASK;
        //attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_VR_ID;
        attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_L4_SRC_PORT;
        attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_L4_DST_PORT;
        attr[attr_cnt++].id = SAI_NAT_ENTRY_ATTR_HIT_BIT;
        
        status = nat_api->get_nat_entry_attribute(&nat_entry, attr_cnt, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("Failed to get nat attributes, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        thrift_attr.id        = attr[0].id;
        thrift_attr.value.__set_s32 (attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[1].id;
        thrift_attr.value.ip4 = sai_thrift_v4_ip_to_string(attr[1].value.ip4);
        thrift_attr.value.__isset.ip4 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[2].id;
        thrift_attr.value.ip4 = sai_thrift_v4_ip_to_string(attr[2].value.ip4);
        thrift_attr.value.__isset.ip4 = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        //thrift_attr.id        = attr[5].id;
        //thrift_attr.value.__set_oid (attr[5].value.oid);
        //thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[3].id;
        thrift_attr.value.__set_u16 (attr[3].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[4].id;
        thrift_attr.value.__set_u16 (attr[4].value.u16);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id        = attr[5].id;
        thrift_attr.value.__set_booldata (attr[5].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }


    void sai_thrift_parse_bfd_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;

            switch (attribute.id)
            {
                case SAI_BFD_SESSION_ATTR_TYPE:
                case SAI_BFD_SESSION_ATTR_BFD_ENCAPSULATION_TYPE:
                case SAI_BFD_SESSION_ATTR_OFFLOAD_TYPE:
                case SAI_BFD_SESSION_ATTR_MPLS_ENCAP_BFD_TYPE:
                case SAI_BFD_SESSION_ATTR_ACH_CHANNEL_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_BFD_SESSION_ATTR_LOCAL_DISCRIMINATOR:
                case SAI_BFD_SESSION_ATTR_REMOTE_DISCRIMINATOR:
                case SAI_BFD_SESSION_ATTR_UDP_SRC_PORT:
                case SAI_BFD_SESSION_ATTR_MIN_TX:
                case SAI_BFD_SESSION_ATTR_MIN_RX:
                case SAI_BFD_SESSION_ATTR_MPLS_IN_LABEL:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_BFD_SESSION_ATTR_HW_LOOKUP_VALID:
                case SAI_BFD_SESSION_ATTR_VLAN_HEADER_VALID:
                case SAI_BFD_SESSION_ATTR_ECHO_ENABLE:
                case SAI_BFD_SESSION_ATTR_MULTIHOP:
                case SAI_BFD_SESSION_ATTR_CBIT:
                case SAI_BFD_SESSION_ATTR_ACH_HEADER_VALID:
                case SAI_BFD_SESSION_ATTR_TP_CV_ENABLE:
                case SAI_BFD_SESSION_ATTR_TP_WITHOUT_GAL:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                case SAI_BFD_SESSION_ATTR_VIRTUAL_ROUTER:
                case SAI_BFD_SESSION_ATTR_PORT:
                case SAI_BFD_SESSION_ATTR_TP_ROUTER_INTERFACE_ID:
                case SAI_BFD_SESSION_ATTR_NEXT_HOP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_BFD_SESSION_ATTR_TC:
                case SAI_BFD_SESSION_ATTR_VLAN_PRI:
                case SAI_BFD_SESSION_ATTR_VLAN_CFI:
                case SAI_BFD_SESSION_ATTR_IPHDR_VERSION:
                case SAI_BFD_SESSION_ATTR_TOS:
                case SAI_BFD_SESSION_ATTR_TTL:
                case SAI_BFD_SESSION_ATTR_TUNNEL_TOS:
                case SAI_BFD_SESSION_ATTR_TUNNEL_TTL:
                case SAI_BFD_SESSION_ATTR_MULTIPLIER:
                case SAI_BFD_SESSION_ATTR_MPLS_TTL:
                case SAI_BFD_SESSION_ATTR_MPLS_EXP:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_BFD_SESSION_ATTR_VLAN_TPID:
                case SAI_BFD_SESSION_ATTR_VLAN_ID:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
                case SAI_BFD_SESSION_ATTR_SRC_IP_ADDRESS:
                case SAI_BFD_SESSION_ATTR_DST_IP_ADDRESS:
                case SAI_BFD_SESSION_ATTR_TUNNEL_SRC_IP_ADDRESS:
                case SAI_BFD_SESSION_ATTR_TUNNEL_DST_IP_ADDRESS:
                    sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                    break;
                case SAI_BFD_SESSION_ATTR_SRC_MAC_ADDRESS:
                case SAI_BFD_SESSION_ATTR_DST_MAC_ADDRESS:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
                case SAI_BFD_SESSION_ATTR_TP_CV_SRC_MEP_ID:
                    //std::memcpy(attr_list[i].value.chardata, attribute.value.chardata.c_str(), attribute.value.chardata.length());
                    std::memcpy(attr_list[i].value.chardata, attribute.value.chardata.c_str(), SAI_BFD_CV_SIZE);                  
                    break;
                default:
                      SAI_THRIFT_LOG_ERR("Failed to parse bfd attributes");
                      break;
            }
        }
    }


    sai_thrift_object_id_t sai_thrift_create_bfd(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bfd_api_t *bfd_api = nullptr;
        status = sai_api_query(SAI_API_BFD, reinterpret_cast < void** > (&bfd_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        memset(attr_list, 0, sizeof(sai_attribute_t) * attr_size);
        sai_thrift_parse_bfd_attributes(thrift_attr_list, attr_list);
        sai_object_id_t sess_oid = 0;
        status = bfd_api->create_bfd_session(&sess_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);

        if (status == SAI_STATUS_SUCCESS)
        {
            return sess_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create bfd, status: %d", status);

        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_bfd(const sai_thrift_object_id_t sess_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bfd_api_t *bfd_api = nullptr;
        status = sai_api_query(SAI_API_BFD, reinterpret_cast < void** > (&bfd_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = bfd_api->remove_bfd_session(sess_oid);
        
        return status;
    }


    sai_thrift_status_t sai_thrift_set_bfd_attribute(const sai_thrift_object_id_t sess_oid,
                                                     const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_bfd_api_t *bfd_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        
        status = sai_api_query(SAI_API_BFD, (void **) &bfd_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bfd_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_bfd_attributes(thrift_attr_list, attr_list);
        
        return bfd_api->set_bfd_session_attribute(sess_oid, attr_list);
    }

    void sai_thrift_get_bfd_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t sess_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        uint32 attr_id = 0, hw_lkp_valid = 0, mpls_encap = 0, ach_header_valid = 0, tp_oam = 0;
        sai_bfd_api_t *bfd_api = nullptr;
        uint32_t attr_count = 0;
        sai_attribute_t attr[SAI_BFD_SESSION_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_BFD, (void **) &bfd_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain counter_api, status:%d", status);
            return;
        }
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_TYPE;
        attr_id++;
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_HW_LOOKUP_VALID;
        attr_id++;
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_BFD_ENCAPSULATION_TYPE;
        attr_id++;
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_ACH_HEADER_VALID;
        attr_id++;
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_MPLS_ENCAP_BFD_TYPE;
        attr_id++;
        
        attr_count = attr_id;
        status = bfd_api->get_bfd_session_attribute(sess_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bfd attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        if(1 == attr[1].value.booldata)
        {
            hw_lkp_valid = 1;
        }
        if(SAI_BFD_ENCAPSULATION_TYPE_MPLS == attr[2].value.s32)
        {
            mpls_encap = 1;
        }
        if(1 == attr[3].value.booldata)
        {
            ach_header_valid = 1;
        }
        if(SAI_BFD_MPLS_TYPE_TP == attr[4].value.s32)
        {
            tp_oam = 1;
        }
        
        attr_id = 0;
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_TYPE;
        attr_id++;
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_HW_LOOKUP_VALID;
        attr_id++;
        
        if(hw_lkp_valid)
        {
            attr[attr_id].id = SAI_BFD_SESSION_ATTR_VIRTUAL_ROUTER;
            attr_id++;
        }
        else
        {
            attr[attr_id].id = SAI_BFD_SESSION_ATTR_PORT;
            attr_id++;
            attr[attr_id].id = SAI_BFD_SESSION_ATTR_SRC_MAC_ADDRESS;
            attr_id++;
            attr[attr_id].id = SAI_BFD_SESSION_ATTR_DST_MAC_ADDRESS;
            attr_id++;
        
        }
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_LOCAL_DISCRIMINATOR;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_REMOTE_DISCRIMINATOR;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_UDP_SRC_PORT;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_BFD_ENCAPSULATION_TYPE;
        attr_id++;
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_IPHDR_VERSION;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_TOS;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_TTL;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_SRC_IP_ADDRESS;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_DST_IP_ADDRESS;
        attr_id++;
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_MULTIHOP;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_MIN_TX;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_MIN_RX;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_MULTIPLIER;
        attr_id++;
        //attr[attr_id].id = SAI_BFD_SESSION_ATTR_REMOTE_MIN_TX;
        //attr_id++;
        //attr[attr_id].id = SAI_BFD_SESSION_ATTR_REMOTE_MIN_RX;
        //attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_STATE;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_OFFLOAD_TYPE;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_NEGOTIATED_TX;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_NEGOTIATED_RX;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_LOCAL_DIAG;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_REMOTE_DIAG;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_REMOTE_MULTIPLIER;
        attr_id++;
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_MPLS_ENCAP_BFD_TYPE;
        attr_id++;
        if(mpls_encap)
        {
            attr[attr_id].id = SAI_BFD_SESSION_ATTR_ACH_HEADER_VALID;
            attr_id++;
            
            attr[attr_id].id = SAI_BFD_SESSION_ATTR_MPLS_IN_LABEL;
            attr_id++;
            
            attr[attr_id].id = SAI_BFD_SESSION_ATTR_MPLS_TTL;
            attr_id++;
            
            attr[attr_id].id = SAI_BFD_SESSION_ATTR_MPLS_EXP;
            attr_id++;
            
            if(ach_header_valid)
            {
                attr[attr_id].id = SAI_BFD_SESSION_ATTR_ACH_CHANNEL_TYPE;
                attr_id++;
            }
        
            if(tp_oam)
            {
                attr[attr_id].id = SAI_BFD_SESSION_ATTR_TP_CV_ENABLE;
                attr_id++;
                attr[attr_id].id = SAI_BFD_SESSION_ATTR_TP_CV_SRC_MEP_ID;
                attr_id++;
                attr[attr_id].id = SAI_BFD_SESSION_ATTR_TP_ROUTER_INTERFACE_ID;
                attr_id++;
                attr[attr_id].id = SAI_BFD_SESSION_ATTR_TP_WITHOUT_GAL;
                attr_id++;
            }
        }
        
        attr[attr_id].id = SAI_BFD_SESSION_ATTR_NEXT_HOP_ID;
        attr_id++;
        
        attr_count = attr_id;
        status = bfd_api->get_bfd_session_attribute(sess_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain bfd attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        attr_id = 0;
        
        //SAI_BFD_SESSION_ATTR_TYPE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_HW_LOOKUP_VALID
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        if(hw_lkp_valid)
        {
            //SAI_BFD_SESSION_ATTR_VIRTUAL_ROUTER
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_oid(attr[attr_id].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
        }
        else
        {
          //SAI_BFD_SESSION_ATTR_PORT
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_oid(attr[attr_id].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
          //SAI_BFD_SESSION_ATTR_SRC_MAC_ADDRESS
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.mac = sai_thrift_mac_to_string(attr[attr_id].value.mac);
            thrift_attr.value.__isset.mac = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
          //SAI_BFD_SESSION_ATTR_DST_MAC_ADDRESS
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.mac = sai_thrift_mac_to_string(attr[attr_id].value.mac);
            thrift_attr.value.__isset.mac = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
        }
        
        //SAI_BFD_SESSION_ATTR_LOCAL_DISCRIMINATOR
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_REMOTE_DISCRIMINATOR
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_UDP_SRC_PORT
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_BFD_ENCAPSULATION_TYPE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_IPHDR_VERSION
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u8(attr[attr_id].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_TOS
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u8(attr[attr_id].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_TTL
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u8(attr[attr_id].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_SRC_IP_ADDRESS
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.ipaddr.addr_family = attr[attr_id].value.ipaddr.addr_family;
        if (SAI_IP_ADDR_FAMILY_IPV4 == thrift_attr.value.ipaddr.addr_family)
        {
            thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(attr[attr_id].value.ipaddr.addr.ip4);
            thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
        }
        else
        {
            thrift_attr.value.ipaddr.addr.ip6 = sai_thrift_v6_ip_to_string(attr[attr_id].value.ipaddr.addr.ip6);
            thrift_attr.value.ipaddr.addr.__isset.ip6 = true;
        }
        thrift_attr.value.__isset.ipaddr = true;
        thrift_attr.value.ipaddr.__isset.addr_family = true;
        thrift_attr.value.ipaddr.__isset.addr = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_DST_IP_ADDRESS
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.ipaddr.addr_family = attr[attr_id].value.ipaddr.addr_family;
        if (SAI_IP_ADDR_FAMILY_IPV4 == thrift_attr.value.ipaddr.addr_family)
        {
            thrift_attr.value.ipaddr.addr.ip4 = sai_thrift_v4_ip_to_string(attr[attr_id].value.ipaddr.addr.ip4);
            thrift_attr.value.ipaddr.addr.__isset.ip4 = true;
        }
        else
        {
            thrift_attr.value.ipaddr.addr.ip6 = sai_thrift_v6_ip_to_string(attr[attr_id].value.ipaddr.addr.ip6);
            thrift_attr.value.ipaddr.addr.__isset.ip6 = true;
        }
        thrift_attr.value.__isset.ipaddr = true;
        thrift_attr.value.ipaddr.__isset.addr_family = true;
        thrift_attr.value.ipaddr.__isset.addr = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_MULTIHOP
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_MIN_TX
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_MIN_RX
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_MULTIPLIER
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u8(attr[attr_id].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_REMOTE_MIN_TX
        //thrift_attr.id = attr[attr_id].id;
        //thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        //thrift_attr_list.attr_list.push_back(thrift_attr);
        //attr_id++;
        
        //SAI_BFD_SESSION_ATTR_REMOTE_MIN_RX
        //thrift_attr.id = attr[attr_id].id;
        //thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        //thrift_attr_list.attr_list.push_back(thrift_attr);
        //attr_id++;
        
        //SAI_BFD_SESSION_ATTR_STATE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_OFFLOAD_TYPE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_NEGOTIATED_TX
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_NEGOTIATED_RX
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_LOCAL_DIAG
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u8(attr[attr_id].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_REMOTE_DIAG
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u8(attr[attr_id].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_REMOTE_MULTIPLIER
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u8(attr[attr_id].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //SAI_BFD_SESSION_ATTR_MPLS_ENCAP_BFD_TYPE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        if(mpls_encap)
        {
        
          //SAI_BFD_SESSION_ATTR_ACH_HEADER_VALID
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
            //SAI_BFD_SESSION_ATTR_MPLS_IN_LABEL
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u32(attr[attr_id].value.u32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
            //SAI_BFD_SESSION_ATTR_MPLS_TTL
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u8(attr[attr_id].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
            //SAI_BFD_SESSION_ATTR_MPLS_EXP
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u8(attr[attr_id].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
            if(ach_header_valid)
            {
                //SAI_BFD_SESSION_ATTR_ACH_CHANNEL_TYPE
                thrift_attr.id = attr[attr_id].id;
                thrift_attr.value.__set_s32(attr[attr_id].value.s32);
                thrift_attr_list.attr_list.push_back(thrift_attr);
                attr_id++;
            }
            
            if(tp_oam)
            {
                //SAI_BFD_SESSION_ATTR_TP_CV_ENABLE
                thrift_attr.id = attr[attr_id].id;
                thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
                thrift_attr_list.attr_list.push_back(thrift_attr);
                attr_id++;
                
                //SAI_BFD_SESSION_ATTR_TP_CV_SRC_MEP_ID
                thrift_attr.id = attr[attr_id].id;
                
                //std::string chardata_str(attr[attr_id].value.chardata);           
                //thrift_attr.value.__set_chardata(chardata_str);
            
                memcpy((void*)thrift_attr.value.chardata.c_str(), (const void*)attr[attr_id].value.chardata, SAI_BFD_CV_SIZE);
                thrift_attr.value.__isset.chardata = true;
            
                
                thrift_attr_list.attr_list.push_back(thrift_attr);
                attr_id++;
            
                //SAI_BFD_SESSION_ATTR_TP_ROUTER_INTERFACE_ID
                thrift_attr.id = attr[attr_id].id;
                thrift_attr.value.__set_oid(attr[attr_id].value.oid);
                thrift_attr_list.attr_list.push_back(thrift_attr);
                attr_id++;
            
                //SAI_BFD_SESSION_ATTR_TP_WITHOUT_GAL
                thrift_attr.id = attr[attr_id].id;
                thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
                thrift_attr_list.attr_list.push_back(thrift_attr);
                attr_id++;
            }
        }
        
        //SAI_BFD_SESSION_ATTR_NEXT_HOP_ID
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_oid(attr[attr_id].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    }

    void sai_thrift_parse_y1731_meg_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");

        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();

        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_Y1731_MEG_ATTR_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_Y1731_MEG_ATTR_LEVEL:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                case SAI_Y1731_MEG_ATTR_NAME:
                    std::memcpy(attr_list[i].value.chardata, attribute.value.chardata.c_str(), SAI_Y1731_MEG_NAME_SIZE);
                    break;
                default:
                      SAI_THRIFT_LOG_ERR("Failed to parse y1731 meg attributes");
                      break;
            }
        }
    }
    
    sai_thrift_object_id_t sai_thrift_create_y1731_meg(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        status = sai_api_query(SAI_API_Y1731, reinterpret_cast < void** > (&y1731_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_y1731_meg_attributes(thrift_attr_list, attr_list);
        sai_object_id_t sess_oid = 0;
        status = y1731_api->create_y1731_meg(&sess_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            return sess_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create y1731 meg, status: %d", status);
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_y1731_meg(const sai_thrift_object_id_t sess_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        status = sai_api_query(SAI_API_Y1731, reinterpret_cast < void** > (&y1731_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = y1731_api->remove_y1731_meg(sess_oid);
    
        return status;
    }


    sai_thrift_status_t sai_thrift_set_y1731_meg_attribute(const sai_thrift_object_id_t sess_oid,
                                                           const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        
        status = sai_api_query(SAI_API_Y1731, (void **) &y1731_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_y1731_meg_attributes(thrift_attr_list, attr_list);
        
        return y1731_api->set_y1731_meg_attribute(sess_oid, attr_list);
    }

    void sai_thrift_get_y1731_meg_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t y1731_meg_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        uint32_t attr_count = 3, index = 0;
        sai_attribute_t attr[SAI_Y1731_MEG_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_Y1731, (void **) &y1731_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731_api, status:%d", status);
            return;
        }
        
        attr[0].id = SAI_Y1731_MEG_ATTR_TYPE;
        attr[1].id = SAI_Y1731_MEG_ATTR_NAME;
        attr[2].id = SAI_Y1731_MEG_ATTR_LEVEL;
        
        status = y1731_api->get_y1731_meg_attribute(y1731_meg_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731 meg attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_s32(attr[0].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = attr[1].id;
        //memcpy((void*)thrift_attr.value.chardata.c_str(), (const void*)attr[1].value.chardata, SAI_Y1731_MEG_NAME_SIZE);
        //thrift_attr.value.__isset.chardata = true;
        std::string chardata_str(attr[1].value.chardata);           
        thrift_attr.value.__set_chardata(chardata_str);
                
        thrift_attr_list.attr_list.push_back(thrift_attr);
        
        thrift_attr.id = attr[2].id;
        thrift_attr.value.__set_u8(attr[2].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    }

    void sai_thrift_parse_y1731_session_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_Y1731_SESSION_ATTR_MEG:
                case SAI_Y1731_SESSION_ATTR_BRIDGE_ID:
                case SAI_Y1731_SESSION_ATTR_PORT_ID:
                case SAI_Y1731_SESSION_ATTR_TP_ROUTER_INTERFACE_ID:
                case SAI_Y1731_SESSION_ATTR_NEXT_HOP_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_Y1731_SESSION_ATTR_DIR:
                case SAI_Y1731_SESSION_ATTR_CCM_PERIOD:
                case SAI_Y1731_SESSION_ATTR_LM_OFFLOAD_TYPE:
                case SAI_Y1731_SESSION_ATTR_LM_TYPE:
                case SAI_Y1731_SESSION_ATTR_DM_OFFLOAD_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_Y1731_SESSION_ATTR_VLAN_ID:
                case SAI_Y1731_SESSION_ATTR_MPLS_IN_LABEL:
                case SAI_Y1731_SESSION_ATTR_LOCAL_MEP_ID:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_Y1731_SESSION_ATTR_CCM_ENABLE:
                case SAI_Y1731_SESSION_ATTR_LM_ENABLE:
                case SAI_Y1731_SESSION_ATTR_DM_ENABLE:
                case SAI_Y1731_SESSION_ATTR_TP_WITHOUT_GAL:
                case SAI_Y1731_SESSION_ATTR_LOCAL_RDI:    
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;                
                case SAI_Y1731_SESSION_ATTR_TTL:
                case SAI_Y1731_SESSION_ATTR_EXP_OR_COS:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse y1731 session attributes");
                    break;
            }
        }
    }
    
    sai_thrift_object_id_t sai_thrift_create_y1731_session(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        status = sai_api_query(SAI_API_Y1731, reinterpret_cast < void** > (&y1731_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_y1731_session_attributes(thrift_attr_list, attr_list);
        sai_object_id_t sess_oid = 0;
        status = y1731_api->create_y1731_session(&sess_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            return sess_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create y1731 session, status: %d", status);
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_y1731_session(const sai_thrift_object_id_t sess_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        status = sai_api_query(SAI_API_Y1731, reinterpret_cast < void** > (&y1731_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = y1731_api->remove_y1731_session(sess_oid);
    
        return status;
    }


    sai_thrift_status_t sai_thrift_set_y1731_session_attribute(const sai_thrift_object_id_t sess_oid,
                                                               const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        
        status = sai_api_query(SAI_API_Y1731, (void **) &y1731_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_y1731_session_attributes(thrift_attr_list, attr_list);
        
        return y1731_api->set_y1731_session_attribute(sess_oid, attr_list);
    }

    void sai_thrift_get_y1731_session_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t y1731_meg_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        uint32_t attr_count = 3, index = 0;
        sai_attribute_t attr[SAI_Y1731_SESSION_ATTR_END];
        sai_attribute_t attr_meg[SAI_Y1731_MEG_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        uint32 attr_id = 0;
        uint8 is_tp = 0;
    
        SAI_THRIFT_FUNC_LOG();
    
        thrift_attr_list.attr_count = 0;
    
        status = sai_api_query(SAI_API_Y1731, (void **) &y1731_api);
        if (status != SAI_STATUS_SUCCESS) {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731_api, status:%d", status);
            return;
        }
    
        // step1:
        attr[0].id = SAI_Y1731_SESSION_ATTR_MEG;
        
        status = y1731_api->get_y1731_session_attribute(y1731_meg_oid, 1, attr);
        if (status != SAI_STATUS_SUCCESS) {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731 session attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        //SAI_Y1731_SESSION_ATTR_MEG
        thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_oid(attr[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
    
        //step2:
        attr_meg[0].id = SAI_Y1731_MEG_ATTR_TYPE;
        status = y1731_api->get_y1731_meg_attribute(thrift_attr.value.oid, 1, attr_meg);
        if (status != SAI_STATUS_SUCCESS) {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731 meg attribute, status:%d", status);
            return;
        }
    
    
        //step3:
        if(attr_meg[0].value.s32 == SAI_Y1731_MEG_TYPE_MPLS_TP)
        {
          is_tp = 1;
        }
    
    
        //step4:      
        attr_id = 0;
        
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_DIR;
        attr_id++;
    
        if(is_tp == 0)
        {
            attr[attr_id].id = SAI_Y1731_SESSION_ATTR_VLAN_ID;
            attr_id++;
    
            attr[attr_id].id = SAI_Y1731_SESSION_ATTR_BRIDGE_ID;
            attr_id++;
    
            attr[attr_id].id = SAI_Y1731_SESSION_ATTR_PORT_ID;
            attr_id++;
        }
        else 
        {
           attr[attr_id].id = SAI_Y1731_SESSION_ATTR_MPLS_IN_LABEL;
           attr_id++;
    
           attr[attr_id].id = SAI_Y1731_SESSION_ATTR_TP_ROUTER_INTERFACE_ID;
           attr_id++;
           
           attr[attr_id].id = SAI_Y1731_SESSION_ATTR_TP_WITHOUT_GAL;
           attr_id++;
                    
           attr[attr_id].id = SAI_Y1731_SESSION_ATTR_TTL;
           attr_id++;
           
           attr[attr_id].id = SAI_Y1731_SESSION_ATTR_NEXT_HOP_ID;
           attr_id++;   
           
        }
        
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_LOCAL_MEP_ID;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_CCM_PERIOD;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_CCM_ENABLE;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_REMOTE_MEP_LIST;
        attr[attr_id].value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * 32);
        attr[attr_id].value.objlist.count = 32;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_LM_OFFLOAD_TYPE;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_LM_ENABLE;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_LM_TYPE;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_DM_OFFLOAD_TYPE;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_DM_ENABLE;
        attr_id++;
        
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_LOCAL_RDI;
        attr_id++;
    
        attr[attr_id].id = SAI_Y1731_SESSION_ATTR_EXP_OR_COS;
        attr_id++;
    
        status = y1731_api->get_y1731_session_attribute(y1731_meg_oid, attr_id, attr);
        if (status != SAI_STATUS_SUCCESS) {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731 session attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        attr_id = 0;
    
        //SAI_Y1731_SESSION_ATTR_DIR
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        if(is_tp == 0)
        {
    
            //SAI_Y1731_SESSION_ATTR_VLAN_ID
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u32(attr[attr_id].value.u32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
    
            //SAI_Y1731_SESSION_ATTR_BRIDGE_ID
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_oid(attr[attr_id].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
    
            //SAI_Y1731_SESSION_ATTR_PORT_ID
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_oid(attr[attr_id].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        
        }
        else
        {
    
            //SAI_Y1731_SESSION_ATTR_MPLS_IN_LABEL
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u32(attr[attr_id].value.u32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;      
    
            //SAI_Y1731_SESSION_ATTR_TP_ROUTER_INTERFACE_ID
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_oid(attr[attr_id].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_Y1731_SESSION_ATTR_TP_WITHOUT_GAL
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
    
            //SAI_Y1731_SESSION_ATTR_TTL
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u8(attr[attr_id].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
                     
            //SAI_Y1731_SESSION_ATTR_NEXT_HOP_ID
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_oid(attr[attr_id].value.oid);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
    
        }
    
        //SAI_Y1731_SESSION_ATTR_LOCAL_MEP_ID
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_CCM_PERIOD
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_CCM_ENABLE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_REMOTE_MEP_LIST
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.objlist.count = attr[attr_id].value.objlist.count;
        std::vector < sai_thrift_object_id_t > & rmep_list = thrift_attr.value.objlist.object_id_list;
        for (int index = 0; index < attr[attr_id].value.objlist.count; index++) {
            rmep_list.push_back((sai_thrift_object_id_t) attr[attr_id].value.objlist.list[index]);
        }
        thrift_attr.value.__isset.objlist = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_LM_OFFLOAD_TYPE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_LM_ENABLE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_LM_TYPE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_DM_OFFLOAD_TYPE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_s32(attr[attr_id].value.s32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_DM_ENABLE
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_LOCAL_RDI
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
        //SAI_Y1731_SESSION_ATTR_EXP_OR_COS
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u8(attr[attr_id].value.u8);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    
    }


    void sai_thrift_parse_y1731_rmep_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");

        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();

        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_Y1731_REMOTE_MEP_ATTR_Y1731_SESSION_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_Y1731_REMOTE_MEP_ATTR_REMOTE_MEP_ID:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_Y1731_REMOTE_MEP_ATTR_REMOTE_MEP_MAC_ADDRESS:
                    sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                    break;
                case SAI_Y1731_REMOTE_MEP_ATTR_CONNECTION_ESTABLISHED:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse y1731 remote mep attributes");
                    break;
            }
        }
    }
    
    sai_thrift_object_id_t sai_thrift_create_y1731_rmep(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        status = sai_api_query(SAI_API_Y1731, reinterpret_cast < void** > (&y1731_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_y1731_rmep_attributes(thrift_attr_list, attr_list);
        sai_object_id_t sess_oid = 0;
        status = y1731_api->create_y1731_remote_mep(&sess_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        if (status == SAI_STATUS_SUCCESS)
        {
            return sess_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create y1731 remote mep, status: %d", status);
        
        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_y1731_rmep(const sai_thrift_object_id_t sess_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        status = sai_api_query(SAI_API_Y1731, reinterpret_cast < void** > (&y1731_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = y1731_api->remove_y1731_remote_mep(sess_oid);
        
        return status;
    }


    sai_thrift_status_t sai_thrift_set_y1731_rmep_attribute(const sai_thrift_object_id_t sess_oid,
                                                            const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
    
        SAI_THRIFT_FUNC_LOG();
    
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
    
        status = sai_api_query(SAI_API_Y1731, (void **) &y1731_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731_api, status:%d", status);
            return status;
        }
    
        sai_thrift_parse_y1731_rmep_attributes(thrift_attr_list, attr_list);
    
        return y1731_api->set_y1731_remote_mep_attribute(sess_oid, attr_list);
    }

    void sai_thrift_get_y1731_rmep_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t y1731_meg_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        uint32_t attr_count = 4, index = 0;
        sai_attribute_t attr[SAI_Y1731_REMOTE_MEP_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
    
        SAI_THRIFT_FUNC_LOG();
    
        thrift_attr_list.attr_count = 0;
    
        status = sai_api_query(SAI_API_Y1731, (void **) &y1731_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731_api, status:%d", status);
            return;
        }
    
        attr[0].id = SAI_Y1731_REMOTE_MEP_ATTR_Y1731_SESSION_ID;
        attr[1].id = SAI_Y1731_REMOTE_MEP_ATTR_REMOTE_MEP_ID;
        attr[2].id = SAI_Y1731_REMOTE_MEP_ATTR_REMOTE_MEP_MAC_ADDRESS;
        attr[3].id = SAI_Y1731_REMOTE_MEP_ATTR_CONNECTION_ESTABLISHED;
    
        status = y1731_api->get_y1731_remote_mep_attribute(y1731_meg_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain y1731 remote mep attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
    
        thrift_attr.id = attr[0].id;
        thrift_attr.value.__set_oid(attr[0].value.oid);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id = attr[1].id;
        thrift_attr.value.__set_u32(attr[1].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id = attr[2].id;
        thrift_attr.value.mac = sai_thrift_mac_to_string(attr[2].value.mac);
        thrift_attr.value.__isset.mac = true;
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
        thrift_attr.id = attr[3].id;
        thrift_attr.value.__set_booldata(attr[3].value.booldata);
        thrift_attr_list.attr_list.push_back(thrift_attr);
    
    }

    void sai_thrift_get_y1731_session_lm_stats(std::vector<int64_t> & thrift_counters,
                                               const sai_thrift_object_id_t y1731_session_oid,
                                               const std::vector<sai_thrift_stat_id_t> & thrift_stats_ids,
                                               const int32_t number_of_stats)
    {
        printf("sai_thrift_get_y1731_session_lm_stats\n");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_y1731_api_t *y1731_api = nullptr;
        status = sai_api_query(SAI_API_Y1731, (void **) &y1731_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }
        sai_stat_id_t *counter_ids = (sai_stat_id_t *) malloc(sizeof(sai_lm_stat_id_t) * thrift_stats_ids.size());
        std::vector<int32_t>::const_iterator it = thrift_stats_ids.begin();
        uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_stats_ids.size());
        for(uint32_t i = 0; i < thrift_stats_ids.size(); i++, it++)
        {
            counter_ids[i] = (sai_lm_stat_id_t) *it;
        }
        
        status = y1731_api->get_y1731_session_lm_stats(
                               (sai_object_id_t) y1731_session_oid,
                               number_of_stats,
                               counter_ids,
                               counters);
        
        for (uint32_t i = 0; i < thrift_stats_ids.size(); i++)
        {
            thrift_counters.push_back(counters[i]);
        }
        free(counter_ids);
        free(counters);
        return;
   }

    void sai_thrift_parser_hostif_packet_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, 
                                                    sai_attribute_t *attr_list)
    {
        if (attr_list == nullptr || thrift_attr_list.empty())
        { SAI_THRIFT_LOG_ERR("Invalid input arguments."); return; }
        
        std::vector<sai_thrift_attribute_t>::const_iterator cit = thrift_attr_list.begin();
        for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_HOSTIF_PACKET_ATTR_HOSTIF_TX_TYPE:
                case SAI_HOSTIF_PACKET_ATTR_CUSTOM_OAM_TX_TYPE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
                case SAI_HOSTIF_PACKET_ATTR_EGRESS_PORT_OR_LAG:
                case SAI_HOSTIF_PACKET_ATTR_CUSTOM_OAM_Y1731_SESSION_ID:
                    attr_list[i].value.oid = attribute.value.oid;
                    break;
                case SAI_HOSTIF_PACKET_ATTR_CUSTOM_TIMESTAMP_OFFSET:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
        
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
                    break;
            }
        }
    }

    int sai_thrift_string_to_packet(const std::string s, unsigned char *m)
    {
        unsigned int i, j=0;
        memset(m, 0, 6);
        for(i=0;i<s.size();i++)
        {
            char let = s.c_str()[i];
            if (let >= '0' && let <= '9')
            {
                m[j/2] = (m[j/2] << 4) + (let - '0'); j++;
            }
            else if (let >= 'a' && let <= 'f')
            {
                m[j/2] = (m[j/2] << 4) + (let - 'a'+10); j++;
            }
            else if (let >= 'A' && let <= 'F')
            {
                m[j/2] = (m[j/2] << 4) + (let - 'A'+10); j++;
            }
            else
            {
                return -1;
            }
        }
        return 0;
    }
   
    sai_thrift_status_t sai_thrift_send_hostif_packet(const sai_thrift_object_id_t thrift_hif_id,
                                                      const std::string& packet_data,
                                                      const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_hostif_api_t *host_api = nullptr;
        unsigned char packet[SAI_THRIFT_MAX_PACKET_LEN] = {0};
        
        sai_thrift_string_to_packet(packet_data, packet);
        
        status = sai_api_query(SAI_API_HOSTIF, reinterpret_cast < void** > (&host_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parser_hostif_packet_attributes(thrift_attr_list, attr_list);
        
        status = host_api->send_hostif_packet(thrift_hif_id,  (sai_size_t)packet_data.length()/2,  (void*)packet, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);
        
        return SAI_STATUS_SUCCESS;

    }

    void sai_thrift_parse_ptp_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_PTP_DOMAIN_ATTR_PTP_ENABLE_BASED_TYPE:
                case SAI_PTP_DOMAIN_ATTR_DEVICE_TYPE:
                case SAI_PTP_DOMAIN_ATTR_TOD_INTF_FORMAT_TYPE:
                case SAI_PTP_DOMAIN_ATTR_TOD_INTF_MODE:
                    attr_list[i].value.s32 = attribute.value.s32;
                    break;
        
                case SAI_PTP_DOMAIN_ATTR_TOD_INTF_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;

                case SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_DRIFT_OFFSET:
                case SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_TIME_OFFSET:
                    attr_list[i].value.timeoffset.flag = attribute.value.timeoffset.flag;
                    attr_list[i].value.timeoffset.value = attribute.value.timeoffset.value;
                    break;
        
                case SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_STATUS:
                case SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_ACCURACY:
                    attr_list[i].value.u8 = attribute.value.u8;
                    break;

                case SAI_PTP_DOMAIN_ATTR_TOD_INTF_GPS_WEEK:
                    attr_list[i].value.u8 = attribute.value.u16;
                    break;
                case SAI_PTP_DOMAIN_ATTR_TOD_INTF_GPS_SECOND_OF_WEEK:
                    attr_list[i].value.u8 = attribute.value.u32;
                    break;

                case SAI_PTP_DOMAIN_ATTR_TOD_INTF_LEAP_SECOND:
                    attr_list[i].value.s8 = attribute.value.s8;
                    break;
        
                case SAI_PTP_DOMAIN_ATTR_TAI_TIMESTAMP:
                    attr_list[i].value.timespec.tv_sec = attribute.value.timespec.tv_sec;
                    attr_list[i].value.timespec.tv_nsec = attribute.value.timespec.tv_nsec;
                    break;
        
                case SAI_PTP_DOMAIN_ATTR_CAPTURED_TIMESTAMP:
                    attr_list[i].value.captured_timespec.port_id = attribute.value.captured_timespec.port_id;
                    attr_list[i].value.captured_timespec.secquence_id = attribute.value.captured_timespec.secquence_id;
                    attr_list[i].value.captured_timespec.timestamp.tv_nsec = attribute.value.captured_timespec.timestamp.tv_nsec;
                    attr_list[i].value.captured_timespec.timestamp.tv_sec = attribute.value.captured_timespec.timestamp.tv_sec ;
                    break;
        
                default:
                      SAI_THRIFT_LOG_ERR("Failed to parse ptp attributes");
                      break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_ptp_domain(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ptp_api_t *ptp_api = nullptr;
        status = sai_api_query(SAI_API_PTP, reinterpret_cast < void** > (&ptp_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_ptp_attributes(thrift_attr_list, attr_list);
        sai_object_id_t ptp_domain_oid = 0;
        status = ptp_api->create_ptp_domain(&ptp_domain_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);

        if (status == SAI_STATUS_SUCCESS)
        {
            return ptp_domain_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create ptp domain, status: %d", status);

        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_ptp_domain(const sai_thrift_object_id_t ptp_domain_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ptp_api_t *ptp_api = nullptr;
        status = sai_api_query(SAI_API_PTP, reinterpret_cast < void** > (&ptp_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = ptp_api->remove_ptp_domain(ptp_domain_oid);
        
        return status;
    }


    sai_thrift_status_t sai_thrift_set_ptp_domain_attribute(const sai_thrift_object_id_t ptp_domain_oid,
                                                            const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ptp_api_t *ptp_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        
        status = sai_api_query(SAI_API_PTP, (void **) &ptp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ptp_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_ptp_attributes(thrift_attr_list, attr_list);
        
        return ptp_api->set_ptp_domain_attribute(ptp_domain_oid, attr_list);
    }


    void sai_thrift_get_ptp_domain_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t ptp_domain_oid) 
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_ptp_api_t *ptp_api = nullptr;
        uint32_t attr_count = 0;
        uint32 attr_id = 0;
        sai_attribute_t attr[SAI_PTP_DOMAIN_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_PTP, (void **) &ptp_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ptp_api, status:%d", status);
            return;
        }
        attr[0].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_MODE;
        
        status = ptp_api->get_ptp_domain_attribute(ptp_domain_oid, 1, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain ptp attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        if(SAI_PTP_TOD_INTERFACE_INPUT == attr[attr_id].value.s32)
        {
        
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_PTP_ENABLE_BASED_TYPE;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_DEVICE_TYPE;
            attr_id++;

            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_DRIFT_OFFSET;
            attr_id++;

            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_TIME_OFFSET;
            attr_id++;
    		
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_FORMAT_TYPE;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_ENABLE;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_MODE;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_LEAP_SECOND;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_STATUS;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_ACCURACY;
            attr_id++;

            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_GPS_WEEK;
            attr_id++;

            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_GPS_SECOND_OF_WEEK;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TAI_TIMESTAMP;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_CAPTURED_TIMESTAMP;
            attr_id++;
            attr_count = attr_id;
            
            
            status = ptp_api->get_ptp_domain_attribute(ptp_domain_oid, attr_count, attr);
            if (status != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("failed to obtain ptp attribute, status:%d", status);
                thrift_attr_list.status = status;
                return;
            }
            
            attr_id = 0;
            
            //SAI_PTP_DOMAIN_ATTR_PTP_ENABLE_BASED_TYPE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s32(attr[attr_id].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_DEVICE_TYPE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s32(attr[attr_id].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //?SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_DRIFT_OFFSET
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.timeoffset.flag = attr[attr_id].value.timeoffset.flag;
            thrift_attr.value.timeoffset.__isset.flag = true;
            thrift_attr.value.timeoffset.value = attr[attr_id].value.timeoffset.value;
            thrift_attr.value.timeoffset.__isset.value = true;
            thrift_attr.value.__isset.timeoffset = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;

            //?SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_TIME_OFFSET
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.timeoffset.flag = attr[attr_id].value.timeoffset.flag;
            thrift_attr.value.timeoffset.__isset.flag = true;
            thrift_attr.value.timeoffset.value = attr[attr_id].value.timeoffset.value;
            thrift_attr.value.timeoffset.__isset.value = true;
            thrift_attr.value.__isset.timeoffset = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
    		
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_FORMAT_TYPE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s32(attr[attr_id].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_ENABLE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_MODE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s32(attr[attr_id].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_LEAP_SECOND
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s8(attr[attr_id].value.s8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_STATUS
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u8(attr[attr_id].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_ACCURACY
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u8(attr[attr_id].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;

    	    //SAI_PTP_DOMAIN_ATTR_TOD_INTF_GPS_WEEK
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u16(attr[attr_id].value.u16);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;

    	    //SAI_PTP_DOMAIN_ATTR_TOD_INTF_GPS_SECOND_OF_WEEK
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u32(attr[attr_id].value.u32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //?SAI_PTP_DOMAIN_ATTR_TAI_TIMESTAMP
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.timespec.tv_sec = attr[attr_id].value.timespec.tv_sec;
            thrift_attr.value.timespec.__isset.tv_sec= true;
            thrift_attr.value.timespec.tv_nsec = attr[attr_id].value.timespec.tv_nsec;
            thrift_attr.value.timespec.__isset.tv_nsec = true;
            thrift_attr.value.__isset.timespec = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //?SAI_PTP_DOMAIN_ATTR_CAPTURED_TIMESTAMP
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.captured_timespec.port_id= attr[attr_id].value.captured_timespec.port_id;
            thrift_attr.value.captured_timespec.__isset.port_id = true;
            thrift_attr.value.captured_timespec.secquence_id = attr[attr_id].value.captured_timespec.secquence_id;
            thrift_attr.value.captured_timespec.__isset.secquence_id = true;
            thrift_attr.value.captured_timespec.timestamp.tv_sec = attr[attr_id].value.captured_timespec.timestamp.tv_sec;
            thrift_attr.value.captured_timespec.timestamp.__isset.tv_sec = true;
            thrift_attr.value.captured_timespec.timestamp.tv_nsec = attr[attr_id].value.captured_timespec.timestamp.tv_nsec;
            thrift_attr.value.captured_timespec.timestamp.__isset.tv_nsec = true;
            thrift_attr.value.captured_timespec.__isset.timestamp = true;
            thrift_attr.value.__isset.captured_timespec = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        }

        else
        {
        
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_PTP_ENABLE_BASED_TYPE;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_DEVICE_TYPE;
            attr_id++;

            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_DRIFT_OFFSET;
            attr_id++;

            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_TIME_OFFSET;
            attr_id++;
    		
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_FORMAT_TYPE;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_ENABLE;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_MODE;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_LEAP_SECOND;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_STATUS;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_ACCURACY;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_TAI_TIMESTAMP;
            attr_id++;
            
            attr[attr_id].id = SAI_PTP_DOMAIN_ATTR_CAPTURED_TIMESTAMP;
            attr_id++;
            attr_count = attr_id;
            
            
            status = ptp_api->get_ptp_domain_attribute(ptp_domain_oid, attr_count, attr);
            if (status != SAI_STATUS_SUCCESS)
            {
                SAI_THRIFT_LOG_ERR("failed to obtain ptp attribute, status:%d", status);
                thrift_attr_list.status = status;
                return;
            }
            
            attr_id = 0;
            
            //SAI_PTP_DOMAIN_ATTR_PTP_ENABLE_BASED_TYPE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s32(attr[attr_id].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_DEVICE_TYPE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s32(attr[attr_id].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //?SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_DRIFT_OFFSET
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.timeoffset.flag = attr[attr_id].value.timeoffset.flag;
            thrift_attr.value.timeoffset.__isset.flag = true;
            thrift_attr.value.timeoffset.value = attr[attr_id].value.timeoffset.value;
            thrift_attr.value.timeoffset.__isset.value = true;
            thrift_attr.value.__isset.timeoffset = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;

            //?SAI_PTP_DOMAIN_ATTR_ADJUEST_CLOCK_TIME_OFFSET
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.timeoffset.flag = attr[attr_id].value.timeoffset.flag;
            thrift_attr.value.timeoffset.__isset.flag = true;
            thrift_attr.value.timeoffset.value = attr[attr_id].value.timeoffset.value;
            thrift_attr.value.timeoffset.__isset.value = true;
            thrift_attr.value.__isset.timeoffset = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
    		
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_FORMAT_TYPE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s32(attr[attr_id].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_ENABLE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_MODE
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s32(attr[attr_id].value.s32);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_LEAP_SECOND
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_s8(attr[attr_id].value.s8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_STATUS
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u8(attr[attr_id].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //SAI_PTP_DOMAIN_ATTR_TOD_INTF_PPS_ACCURACY
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.__set_u8(attr[attr_id].value.u8);
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //?SAI_PTP_DOMAIN_ATTR_TAI_TIMESTAMP
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.timespec.tv_sec = attr[attr_id].value.timespec.tv_sec;
            thrift_attr.value.timespec.__isset.tv_sec= true;
            thrift_attr.value.timespec.tv_nsec = attr[attr_id].value.timespec.tv_nsec;
            thrift_attr.value.timespec.__isset.tv_nsec = true;
            thrift_attr.value.__isset.timespec = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
            
            //?SAI_PTP_DOMAIN_ATTR_CAPTURED_TIMESTAMP
            thrift_attr.id = attr[attr_id].id;
            thrift_attr.value.captured_timespec.port_id= attr[attr_id].value.captured_timespec.port_id;
            thrift_attr.value.captured_timespec.__isset.port_id = true;
            thrift_attr.value.captured_timespec.secquence_id = attr[attr_id].value.captured_timespec.secquence_id;
            thrift_attr.value.captured_timespec.__isset.secquence_id = true;
            thrift_attr.value.captured_timespec.timestamp.tv_sec = attr[attr_id].value.captured_timespec.timestamp.tv_sec;
            thrift_attr.value.captured_timespec.timestamp.__isset.tv_sec = true;
            thrift_attr.value.captured_timespec.timestamp.tv_nsec = attr[attr_id].value.captured_timespec.timestamp.tv_nsec;
            thrift_attr.value.captured_timespec.timestamp.__isset.tv_nsec = true;
            thrift_attr.value.captured_timespec.__isset.timestamp = true;
            thrift_attr.value.__isset.captured_timespec = true;
            thrift_attr_list.attr_list.push_back(thrift_attr);
            attr_id++;
        }        


    }

    void sai_thrift_parse_synce_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_SYNCE_ATTR_RECOVERED_PORT:
	            case SAI_SYNCE_ATTR_CLOCK_DIVIDER:
                    attr_list[i].value.u16 = attribute.value.u16;
                    break;
	    
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse syncE attributes");
                    break;
            }
        }
    }

    sai_thrift_object_id_t sai_thrift_create_synce(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_synce_api_t *synce_api = nullptr;
        status = sai_api_query(SAI_API_SYNCE, reinterpret_cast < void** > (&synce_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_synce_attributes(thrift_attr_list, attr_list);
        sai_object_id_t synce_oid = 0;
        status = synce_api->create_synce(&synce_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);

        if (status == SAI_STATUS_SUCCESS)
        {
            return synce_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create syncE, status: %d", status);

        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_synce(const sai_thrift_object_id_t synce_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_synce_api_t *synce_api = nullptr;
        status = sai_api_query(SAI_API_SYNCE, reinterpret_cast < void** > (&synce_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = synce_api->remove_synce(synce_oid);
        
        return status;
    }
	
    sai_thrift_status_t sai_thrift_set_synce_attribute(const sai_thrift_object_id_t synce_oid,
                                                       const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_synce_api_t *synce_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        
        status = sai_api_query(SAI_API_SYNCE, (void **) &synce_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain syncE_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_synce_attributes(thrift_attr_list, attr_list);
        
        return synce_api->set_synce_attribute(synce_oid, attr_list);
    }

    void sai_thrift_get_synce_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t synce_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_synce_api_t *synce_api = nullptr;
        uint32_t attr_count = 0;
        uint32 attr_id = 0;
        sai_attribute_t attr[SAI_SYNCE_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_SYNCE, (void **) &synce_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain synce_api, status:%d", status);
            return;
        }
        
        attr[attr_id].id = SAI_SYNCE_ATTR_RECOVERED_PORT;
        attr_id++;
        
        attr[attr_id].id = SAI_SYNCE_ATTR_CLOCK_DIVIDER;
        attr_id++;
        
        attr_count = attr_id;  
	    
        
        status = synce_api->get_synce_attribute(synce_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain syncE attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }
        
        attr_id = 0;
        
        
        //SAI_SYNCE_ATTR_RECOVERED_PORT
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u16(attr[attr_id].value.u16);  
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
        
        //?SAI_SYNCE_ATTR_CLOCK_DIVIDER
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u16(attr[attr_id].value.u16);  
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    }

  
    void sai_thrift_parse_es_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
      SAI_THRIFT_LOG_DBG("Called.");

      std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();

      for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
      {
          sai_thrift_attribute_t attribute = *cit;
          attr_list[i].id = attribute.id;

          switch (attribute.id)
          {
              case SAI_ES_ATTR_ESI_LABEL:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;

              default:
                    SAI_THRIFT_LOG_ERR("Failed to parse es attributes");
                    break;
          }
      }
    }
    
    sai_thrift_object_id_t sai_thrift_create_es(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_es_api_t *es_api = nullptr;
        status = sai_api_query(SAI_API_ES, reinterpret_cast < void** > (&es_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_es_attributes(thrift_attr_list, attr_list);
        sai_object_id_t es_oid = 0;
        status = es_api->create_es(&es_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);

        if (status == SAI_STATUS_SUCCESS)
        {
            return es_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create ES, status: %d", status);

        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_es(const sai_thrift_object_id_t es_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_es_api_t *es_api = nullptr;
        status = sai_api_query(SAI_API_ES, reinterpret_cast < void** > (&es_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = es_api->remove_es(es_oid);
        
        return status;
    }

    sai_thrift_status_t sai_thrift_set_es_attribute(const sai_thrift_object_id_t es_oid,
                                                    const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_es_api_t *es_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };

        SAI_THRIFT_FUNC_LOG();

        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);

        status = sai_api_query(SAI_API_ES, (void **) &es_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain es_api, status:%d", status);
            return status;
        }

        sai_thrift_parse_es_attributes(thrift_attr_list, attr_list);

        return es_api->set_es_attribute(es_oid, attr_list);
    }


    void sai_thrift_get_es_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t es_oid)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_es_api_t *es_api = nullptr;
        uint32_t attr_count = 0;
        uint32 attr_id = 0;
        sai_attribute_t attr[SAI_ES_ATTR_END];
        sai_thrift_attribute_t thrift_attr;

        SAI_THRIFT_FUNC_LOG();

        thrift_attr_list.attr_count = 0;

        status = sai_api_query(SAI_API_ES, (void **) &es_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain es_api, status:%d", status);
            return;
        }

        attr[attr_id].id = SAI_ES_ATTR_ESI_LABEL;
        attr_id++;

        attr_count = attr_id;


        status = es_api->get_es_attribute(es_oid, attr_count, attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain es attribute, status:%d", status);
            thrift_attr_list.status = status;
            return;
        }

        attr_id = 0;

        //SAI_ES_ATTR_ESI_LABEL
        thrift_attr.id = attr[attr_id].id;
        thrift_attr.value.__set_u32(attr[attr_id].value.u32);
        thrift_attr_list.attr_list.push_back(thrift_attr);
        attr_id++;
    }

    void sai_thrift_parse_monitor_buffer_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_INGRESS_PORT_PERIODIC_MONITOR_ENABLE:
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_PERIODIC_MONITOR_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;

                
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_MB_PORT_THRESHOLD_MIN:
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_MB_PORT_THRESHOLD_MAX:
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_UNICAST_WATERMARK:
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_MULTICAST_WATERMARK:
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_TOTAL_WATERMARK:
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_INGRESS_PORT_TOTAL_WATERMARK:
			attr_list[i].value.u32 = attribute.value.u32;
			break;
                case SAI_MONITOR_BUFFER_MONITOR_ATTR_PORT:
			attr_list[i].value.oid = attribute.value.oid;
                default:
                      SAI_THRIFT_LOG_ERR("Failed to parse monitor buffer attributes");
                      break;
            }
        }
    }
    sai_thrift_object_id_t sai_thrift_create_monitor_buffer(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_monitor_api_t *monitor_api = nullptr;
        status = sai_api_query(SAI_API_MONITOR, reinterpret_cast < void** > (&monitor_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_monitor_buffer_attributes(thrift_attr_list, attr_list);
        sai_object_id_t monitor_buffer_oid = 0;
        status = monitor_api->create_monitor_buffer(&monitor_buffer_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);

        if (status == SAI_STATUS_SUCCESS)
        {
            return monitor_buffer_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create monitor buffer oid, status: %d", status);

        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_monitor_buffer(const sai_thrift_object_id_t monitor_buffer_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_monitor_api_t *monitor_api = nullptr;
        status = sai_api_query(SAI_API_MONITOR, reinterpret_cast < void** > (&monitor_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = monitor_api->remove_monitor_buffer(monitor_buffer_oid);
        
        return status;
    }

    sai_thrift_status_t sai_thrift_set_monitor_buffer_attribute(const sai_thrift_object_id_t monitor_buffer_oid,
                                                            const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_monitor_api_t *monitor_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        
        status = sai_api_query(SAI_API_MONITOR, (void **) &monitor_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain monitor_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_monitor_buffer_attributes(thrift_attr_list, attr_list);
        
        return monitor_api->set_monitor_buffer_attribute(monitor_buffer_oid, attr_list);
    }


    void sai_thrift_get_monitor_buffer_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t monitor_buffer_oid) 
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_monitor_api_t *monitor_api = nullptr;
        uint32_t attr_count = 0;
        uint32 attr_id = 0;
        sai_attribute_t attr[SAI_MONITOR_BUFFER_MONITOR_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_MONITOR, (void **) &monitor_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain monitor_api, status:%d", status);
            return;
        }

	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_PORT;
	attr_id++;
            
	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_MB_PORT_THRESHOLD_MIN;
       attr_id++;

	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_MB_PORT_THRESHOLD_MAX;
	attr_id++;

	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_INGRESS_PORT_PERIODIC_MONITOR_ENABLE;
	attr_id++;
    		
	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_PERIODIC_MONITOR_ENABLE;
	attr_id++;
            
	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_UNICAST_WATERMARK;
	attr_id++;
            
	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_MULTICAST_WATERMARK;
	attr_id++;
            
	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_TOTAL_WATERMARK;
       attr_id++;

	attr[attr_id].id = SAI_MONITOR_BUFFER_MONITOR_ATTR_INGRESS_PORT_TOTAL_WATERMARK;
	attr_id++;

       attr_count = attr_id;
            
            
	status = monitor_api->get_monitor_buffer_attribute(monitor_buffer_oid, attr_count, attr);
	if (status != SAI_STATUS_SUCCESS)
	{
		SAI_THRIFT_LOG_ERR("failed to obtain monitor buffer attribute, status:%d", status);
		thrift_attr_list.status = status;
		return;
	}
            
	attr_id = 0;
            
	//SAI_MONITOR_BUFFER_MONITOR_ATTR_PORT
	thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
	thrift_attr_list.attr_list.push_back(thrift_attr);
	attr_id++;
            
	//SAI_MONITOR_BUFFER_MONITOR_ATTR_MB_PORT_THRESHOLD_MIN
       thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
       thrift_attr_list.attr_list.push_back(thrift_attr);
       attr_id++;
            
	//SAI_MONITOR_BUFFER_MONITOR_ATTR_MB_PORT_THRESHOLD_MAX
       thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
       thrift_attr_list.attr_list.push_back(thrift_attr);
       attr_id++;

	//SAI_MONITOR_BUFFER_MONITOR_ATTR_INGRESS_PORT_PERIODIC_MONITOR_ENABLE
	thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
	thrift_attr_list.attr_list.push_back(thrift_attr);
	attr_id++;
    		
	//SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_PERIODIC_MONITOR_ENABLE
	thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
	thrift_attr_list.attr_list.push_back(thrift_attr);
	attr_id++;
            
	//SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_UNICAST_WATERMARK
       thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
       thrift_attr_list.attr_list.push_back(thrift_attr);
       attr_id++;
            
	//SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_MULTICAST_WATERMARK
       thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
       thrift_attr_list.attr_list.push_back(thrift_attr);
       attr_id++;
            
	//SAI_MONITOR_BUFFER_MONITOR_ATTR_EGRESS_PORT_TOTAL_WATERMARK
       thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
       thrift_attr_list.attr_list.push_back(thrift_attr);
       attr_id++;
            
	//SAI_MONITOR_BUFFER_MONITOR_ATTR_INGRESS_PORT_TOTAL_WATERMARK
       thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
       thrift_attr_list.attr_list.push_back(thrift_attr);
       attr_id++;
            
    }

    void sai_thrift_parse_monitor_latency_attributes(const std_sai_thrift_attr_vctr_t &thrift_attr_list, sai_attribute_t *attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        
        std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();
        
        for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++)
        {
            sai_thrift_attribute_t attribute = *cit;
            attr_list[i].id = attribute.id;
        
            switch (attribute.id)
            {
                case SAI_MONITOR_LATENCY_MONITOR_ATTR_ENABLE:
                case SAI_MONITOR_LATENCY_MONITOR_ATTR_PERIODIC_MONITOR_ENABLE:
                    attr_list[i].value.booldata = attribute.value.booldata;
                    break;

                case SAI_MONITOR_LATENCY_MONITOR_ATTR_PORT_WATERMARK:
                    attr_list[i].value.u32 = attribute.value.u32;
                    break;
                case SAI_MONITOR_LATENCY_MONITOR_ATTR_PORT:
			attr_list[i].value.oid = attribute.value.oid;		
			break;			
                case SAI_MONITOR_LATENCY_MONITOR_ATTR_LEVEL_OVERTHRD_EVENT:
                case SAI_MONITOR_LATENCY_MONITOR_ATTR_LEVEL_DISCARD:
                    {
				int count = attribute.value.boollist.boollist.size();
				bool *bool_list = NULL;
				std::vector<bool>::const_iterator it = attribute.value.boollist.boollist.begin();
				bool_list = (bool *) malloc(sizeof(bool) * count);
				for(int j = 0; j < count; j++, it++)
				    *(bool_list + j) = (bool) *it;
				attr_list[i].value.boollist.list = bool_list;
				attr_list[i].value.boollist.count = count;
                    }
                    break;
			
                default:
                    SAI_THRIFT_LOG_ERR("Failed to parse monitor latency attributes");
                    break;
										  
            }
        }
}	
    sai_thrift_object_id_t sai_thrift_create_monitor_latency(const std_sai_thrift_attr_vctr_t &thrift_attr_list)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_monitor_api_t *monitor_api = nullptr;
        status = sai_api_query(SAI_API_MONITOR, reinterpret_cast < void** > (&monitor_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        sai_attribute_t *attr_list = nullptr;
        sai_uint32_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        sai_thrift_parse_monitor_latency_attributes(thrift_attr_list, attr_list);
        sai_object_id_t monitor_latency_oid = 0;
        status = monitor_api->create_monitor_latency(&monitor_latency_oid, gSwitchId, attr_size, attr_list);
        sai_thrift_free_attr(attr_list);

        if (status == SAI_STATUS_SUCCESS)
        {
            return monitor_latency_oid;
        }
        SAI_THRIFT_LOG_ERR("Failed to create monitor_latency_oid, status: %d", status);

        return SAI_NULL_OBJECT_ID;
    }

    sai_thrift_status_t sai_thrift_remove_monitor_latency(const sai_thrift_object_id_t monitor_latency_oid)
    {
        SAI_THRIFT_LOG_DBG("Called.");
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_monitor_api_t *monitor_api = nullptr;
        status = sai_api_query(SAI_API_MONITOR, reinterpret_cast < void** > (&monitor_api));
        if (status != SAI_STATUS_SUCCESS)
        {
            return status;
        }
        status = monitor_api->remove_monitor_latency(monitor_latency_oid);
        
        return status;
    }


    sai_thrift_status_t sai_thrift_set_monitor_latency_attribute(const sai_thrift_object_id_t monitor_latency_oid,
                                                            const sai_thrift_attribute_t& thrift_attr)
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_monitor_api_t *monitor_api = nullptr;
        const std::vector<sai_thrift_attribute_t> thrift_attr_list = { thrift_attr };
        
        SAI_THRIFT_FUNC_LOG();
        
        sai_attribute_t *attr_list = nullptr;
        sai_size_t attr_size = thrift_attr_list.size();
        sai_thrift_alloc_attr(attr_list, attr_size);
        
        status = sai_api_query(SAI_API_MONITOR, (void **) &monitor_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain monitor_api, status:%d", status);
            return status;
        }
        
        sai_thrift_parse_monitor_latency_attributes(thrift_attr_list, attr_list);
        
        return monitor_api->set_monitor_latency_attribute(monitor_latency_oid, attr_list);
    }


    void sai_thrift_get_monitor_latency_attribute(sai_thrift_attribute_list_t& thrift_attr_list, const sai_thrift_object_id_t monitor_latency_oid) 
    {
        sai_status_t status = SAI_STATUS_SUCCESS;
        sai_monitor_api_t *monitor_api = nullptr;
        uint32_t attr_count = 0;
        uint32 attr_id = 0;
        sai_attribute_t attr[SAI_MONITOR_LATENCY_MONITOR_ATTR_END];
        sai_thrift_attribute_t thrift_attr;
        
        SAI_THRIFT_FUNC_LOG();
        
        thrift_attr_list.attr_count = 0;
        
        status = sai_api_query(SAI_API_MONITOR, (void **) &monitor_api);
        if (status != SAI_STATUS_SUCCESS)
        {
            SAI_THRIFT_LOG_ERR("failed to obtain monitor_api, status:%d", status);
            return;
        }
		
	attr[attr_id].id = SAI_MONITOR_LATENCY_MONITOR_ATTR_PORT;
	attr_id++;
            
	attr[attr_id].id = SAI_MONITOR_LATENCY_MONITOR_ATTR_ENABLE;
       attr_id++;

	attr[attr_id].id = SAI_MONITOR_LATENCY_MONITOR_ATTR_LEVEL_OVERTHRD_EVENT;
	attr[attr_id].value.boollist.count = 8;
	attr[attr_id].value.boollist.list = (bool *) malloc(sizeof(bool) *8);
	attr_id++;

	attr[attr_id].id = SAI_MONITOR_LATENCY_MONITOR_ATTR_PERIODIC_MONITOR_ENABLE;
	attr_id++;
    		
	attr[attr_id].id = SAI_MONITOR_LATENCY_MONITOR_ATTR_LEVEL_DISCARD;
	attr[attr_id].value.boollist.count = 8;
	attr[attr_id].value.boollist.list = (bool *) malloc(sizeof(bool) *8);
	attr_id++;
            
	attr[attr_id].id = SAI_MONITOR_LATENCY_MONITOR_ATTR_PORT_WATERMARK;
	attr_id++;
            
       attr_count = attr_id;
            
	status = monitor_api->get_monitor_latency_attribute(monitor_latency_oid, attr_count, attr);
	if (status != SAI_STATUS_SUCCESS)
	{
		SAI_THRIFT_LOG_ERR("failed to obtain monitor latency attribute, status:%d", status);
		thrift_attr_list.status = status;
		return;
	}
            
	attr_id = 0;
            
	//SAI_MONITOR_LATENCY_MONITOR_ATTR_PORT
	thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
	thrift_attr_list.attr_list.push_back(thrift_attr);
	attr_id++;
            
	//SAI_MONITOR_LATENCY_MONITOR_ATTR_MB_ENABLE
	thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
	thrift_attr_list.attr_list.push_back(thrift_attr);
       attr_id++;
            
	//SAI_MONITOR_LATENCY_MONITOR_ATTR_MB_LEVEL_OVERTHRD_EVENT
	thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.boollist.count = attr[attr_id].value.boollist.count;
	std::vector < bool > & event_list = thrift_attr.value.boollist.boollist;
	for (int index = 0; index < attr[attr_id].value.boollist.count; index++)
	{
            event_list.push_back((bool) attr[attr_id].value.boollist.list[index]);
	}
	thrift_attr.value.__isset.boollist = true;
	thrift_attr_list.attr_list.push_back(thrift_attr);
	attr_id++;

	//SAI_MONITOR_LATENCY_MONITOR_ATTR_PERIODIC_MONITOR_ENABLE
	thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_booldata(attr[attr_id].value.booldata);
	thrift_attr_list.attr_list.push_back(thrift_attr);
	attr_id++;
    		
	//SAI_MONITOR_LATENCY_MONITOR_ATTR_LEVEL_DISCARD
	thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.boollist.count = attr[attr_id].value.boollist.count;
	std::vector < bool > & discard_list = thrift_attr.value.boollist.boollist;
	for (int index = 0; index < attr[attr_id].value.boollist.count; index++)
	{
            discard_list.push_back((bool) attr[attr_id].value.boollist.list[index]);
	}
	thrift_attr.value.__isset.boollist = true;
	thrift_attr_list.attr_list.push_back(thrift_attr);
	attr_id++;
            
	//SAI_MONITOR_LATENCY_MONITOR_ATTR_PORT_WATERMARK
       thrift_attr.id = attr[attr_id].id;
	thrift_attr.value.__set_u32(attr[attr_id].value.u32);
       thrift_attr_list.attr_list.push_back(thrift_attr);
       attr_id++;
      
	};
};

#define SWITCH_SAI_THRIFT_RPC_SERVER_PORT 9092
#define SAI_CPU_PACKET_MAX_ATTR_COUNT 6
sai_switch_api_t* sai_switch_api;
sai_attribute_t packet_rx_attr[SAI_CPU_PACKET_MAX_ATTR_COUNT];
int packet_rx_attr_count;
int packets_rx_count;

std::map<std::string, std::string> gProfileMap;
std::map<std::set<int>, std::string> gPortMap;

sai_object_id_t gSwitchId; ///< SAI switch global object ID.

void on_switch_state_change(_In_ sai_object_id_t switch_id,
                            _In_ sai_switch_oper_status_t switch_oper_status)//
{
}


void on_fdb_event(_In_ uint32_t count,
                  _In_ sai_fdb_event_notification_data_t *data)
{
    int i = 0;
    sai_fdb_event_notification_data_t* event_tmp = 0;
    if (0 == count)
    {
        return;
    }
    event_tmp = &data[0];
    printf ("\r\n===process fdb %s event===\r\n",
                      (SAI_FDB_EVENT_AGED == event_tmp->event_type )?"aging"
                      :((SAI_FDB_EVENT_LEARNED == event_tmp->event_type )?"learning":"flush"));
}

void on_port_state_change(_In_ uint32_t count,
                          _In_ sai_port_oper_status_notification_t *data)
{
}

void on_shutdown_request(_In_ sai_object_id_t switch_id)//
{
}

void on_packet_event(_In_ sai_object_id_t switch_id,
                     _In_ sai_size_t buffer_size,
                     _In_ const void *buffer,
                     _In_ uint32_t attr_count,
                     _In_ const sai_attribute_t *attr_list)
{
    int index = 0, i = 0;

    printf ("\r\n===receive cpu packet ===\r\n");
    packet_rx_attr_count = 0;
    packets_rx_count++; /*packet stats num*/
    for (index = 0; index < attr_count ; index++)
    {
        if (SAI_HOSTIF_PACKET_ATTR_HOSTIF_TRAP_ID == attr_list[index].id)
        {
            packet_rx_attr[packet_rx_attr_count].id = attr_list[index].id;
            packet_rx_attr[packet_rx_attr_count].value.oid = attr_list[index].value.oid;
            printf ("\r\n===cpu receive trap id 0x%lx ===\r\n", packet_rx_attr[packet_rx_attr_count].value.oid);
            packet_rx_attr_count++;
        }
        if (SAI_HOSTIF_PACKET_ATTR_INGRESS_PORT == attr_list[index].id)
        {
            packet_rx_attr[packet_rx_attr_count].id = attr_list[index].id;
            packet_rx_attr[packet_rx_attr_count].value.oid = attr_list[index].value.oid;
            printf ("\r\n===cpu receive ingress port 0x%lx ===\r\n", packet_rx_attr[packet_rx_attr_count].value.oid);
            packet_rx_attr_count++;
        }
        if (SAI_HOSTIF_PACKET_ATTR_INGRESS_LAG == attr_list[index].id)
        {
            packet_rx_attr[packet_rx_attr_count].id = attr_list[index].id;
            packet_rx_attr[packet_rx_attr_count].value.oid = attr_list[index].value.oid;
            printf ("\r\n===cpu receive ingress lag 0x%lx ===\r\n", packet_rx_attr[packet_rx_attr_count].value.oid);
            packet_rx_attr_count++;
        }
        if (SAI_HOSTIF_PACKET_ATTR_BRIDGE_ID == attr_list[index].id)
        {
            packet_rx_attr[packet_rx_attr_count].id = attr_list[index].id;
            packet_rx_attr[packet_rx_attr_count].value.oid = attr_list[index].value.oid;
            printf ("\r\n===cpu receive bridge id 0x%lx ===\r\n", packet_rx_attr[packet_rx_attr_count].value.oid);
            packet_rx_attr_count++;
        }

        if (SAI_HOSTIF_PACKET_ATTR_TIMESTAMP == attr_list[index].id)
        {
            packet_rx_attr[packet_rx_attr_count].id = attr_list[index].id;
            packet_rx_attr[packet_rx_attr_count].value.timespec.tv_sec = attr_list[index].value.timespec.tv_sec;
            packet_rx_attr[packet_rx_attr_count].value.timespec.tv_nsec = attr_list[index].value.timespec.tv_nsec;
            printf ("\r\n===cpu receive timestamp second 0x%lx ===\r\n", packet_rx_attr[packet_rx_attr_count].value.timespec.tv_sec);
            printf ("\r\n===cpu receive timestamp nanosecond 0x%lx ===\r\n", packet_rx_attr[packet_rx_attr_count].value.timespec.tv_nsec);
            packet_rx_attr_count++;
        }

        if (SAI_HOSTIF_PACKET_ATTR_Y1731_RXFCL == attr_list[index].id)
        {
            packet_rx_attr[packet_rx_attr_count].id = attr_list[index].id;
            packet_rx_attr[packet_rx_attr_count].value.u64 = attr_list[index].value.u64;
            printf ("\r\n===cpu receive lm fcl 0x%lx ===\r\n", packet_rx_attr[packet_rx_attr_count].value.u64);
            packet_rx_attr_count++;
        }
    }

    printf ("\r\n===cpu receive packet, length %d ===\r\n", buffer_size);
    for(i = 0; i < buffer_size; i++)
    {
        printf("%02x", ((uint8*)buffer)[i]);
        if((i+1)%16 == 0)
        {
            printf ("\n");
        }
    }
    printf ("\r\n===receive packet End ===\r\n");

}

void on_bfd_event(_In_ uint32_t count,
                  _In_ sai_bfd_session_state_notification_t *data)
{
    int index = 0;

    printf ("\r\n===bfd event occur ===\r\n");

    for(index = 0; index < count ; index++)
    {
        printf("\r\n===bfd session id 0x%lx, state change to %d ===\r\n", data[index].bfd_session_id, data[index].session_state);
    }
}

void on_y1731_event(_In_ uint32_t count,
                    _In_ sai_y1731_session_event_notification_t *data)
{
    int index = 0, j = 0;

    printf ("\r\n===y1731 event occur ===\r\n");

    for(index = 0; index < count ; index++)
    {
        printf("\r\n===y1731 session id 0x%lx ===\r\n", data[index].y1731_oid);

        for(j = 0; j < data[index].session_event_list.count; j++)
        {
             printf("=== event num:%d, event id: %d ===\r\n", j, data[index].session_event_list.list[j]);
        }
    }
}

// Profile services
/* Get variable value given its name */
const char* test_profile_get_value(_In_ sai_switch_profile_id_t profile_id,
                                   _In_ const char* variable)
{
    UNREFERENCED_PARAMETER(profile_id);

    if (variable == NULL)
    {
        printf("variable is null\n");
        return NULL;
    }

    std::map<std::string, std::string>::const_iterator it = gProfileMap.find(variable);
    if (it == gProfileMap.end())
    {
        printf("%s: NULL\n", variable);
        return NULL;
    }

    return it->second.c_str();
}

std::map<std::string, std::string>::iterator gProfileIter = gProfileMap.begin();
/* Enumerate all the K/V pairs in a profile.
   Pointer to NULL passed as variable restarts enumeration.
   Function returns 0 if next value exists, -1 at the end of the list. */
int test_profile_get_next_value(_In_ sai_switch_profile_id_t profile_id,
                                _Out_ const char** variable,
                                _Out_ const char** value)
{
    UNREFERENCED_PARAMETER(profile_id);

    if (value == NULL)
    {
        printf("resetting profile map iterator");

        gProfileIter = gProfileMap.begin();
        return 0;
    }

    if (variable == NULL)
    {
        printf("variable is null");
        return -1;
    }

    if (gProfileIter == gProfileMap.end())
    {
        printf("iterator reached end");
        return -1;
    }

    *variable = gProfileIter->first.c_str();
    *value = gProfileIter->second.c_str();

    printf("key: %s:%s", *variable, *value);

    gProfileIter++;

    return 0;
}

const sai_service_method_table_t test_services = {
    test_profile_get_value,
    test_profile_get_next_value
};

void sai_diag_shell()
{
    sai_status_t status;

    while (true)
    {
        sai_attribute_t attr;
        attr.id = SAI_SWITCH_ATTR_SWITCH_SHELL_ENABLE;
        attr.value.booldata = true;
        status = sai_switch_api->set_switch_attribute(gSwitchId, &attr);
        if (status != SAI_STATUS_SUCCESS)
        {
            return;
        }

        sleep(1);
    }
}


struct cmdOptions
{
    std::string profileMapFile;
    std::string portMapFile;
    std::string initScript;
    std::string sockPath;
    std::string dutname;
    std::string  thriftport;
};

cmdOptions handleCmdLine(int argc, char **argv)
{

    cmdOptions options = {};


    while(1)
    {
        static struct option long_options[] =
        {
            { "profile",          required_argument, 0, 'p' },
            { "portmap",        required_argument, 0, 'f' },
            { "init-script",      required_argument, 0, 'S' },
             { "sockPath",      required_argument, 0, 'h' },
            	{"dutname",        required_argument,0, 'n'},
            	{"thriftport",        required_argument,0, 't'},
            { 0,                  0,                 0,  0  }
        };

        int option_index = 0;

        int c = getopt_long(argc, argv, "p:f:S:h:n:t:", long_options, &option_index);

        if (c == -1)
            break;

        switch (c)
        {
            case 'p':
                printf("profile map file: %s\n", optarg);
                options.profileMapFile = std::string(optarg);
                break;
            case 'f':
                printf("port map file: %s\n", optarg);
                options.portMapFile = std::string(optarg);
                break;
            case 'S':
                printf("init script: %s\n", optarg);
                options.initScript = std::string(optarg);
                break;
            case 'h':
                printf("sockPath: %s\n",optarg);
                options.sockPath = std::string(optarg);
                break;
            case 'n':
                printf("dutname: %s\n", optarg);
                options.dutname = std::string(optarg);
                break;
            case 't':
                printf("thriftport: %s\n", optarg);
                options.thriftport = std::string(optarg);
                break;
            default:
                printf("getopt_long failure\n");
                exit(EXIT_FAILURE);
        }
    }

    return options;
}


void help_print( )
{
     printf(" \n");
     printf(" \n");
     printf("MUST Paras:\n")	;
     printf("    -h The unix sock path for packet switch.\n");
     printf("    -n The name of the test device, DUTX.\n");
     printf("    -t  The thriftport server listen port , DUTX.\n");
     printf("Option Paras:\n")	;
     printf("    -p The profile file path.\n");
     printf("    -S  The init scipy.\n");
     printf(" \n");
     printf(" \n");
}

void handleProfileMap(const std::string& profileMapFile)
{

    if (profileMapFile.size() == 0)
        return;

    std::ifstream profile(profileMapFile);

    if (!profile.is_open())
    {
        printf("failed to open profile map file: %s : %s\n", profileMapFile.c_str(), strerror(errno));
        exit(EXIT_FAILURE);
    }

    std::string line;

    while(getline(profile, line))
    {
        if (line.size() > 0 && (line[0] == '#' || line[0] == ';'))
            continue;

        size_t pos = line.find("=");

        if (pos == std::string::npos)
        {
            printf("not found '=' in line %s\n", line.c_str());
            continue;
        }

        std::string key = line.substr(0, pos);
        std::string value = line.substr(pos + 1);

        gProfileMap[key] = value;

        printf("insert: %s:%s\n", key.c_str(), value.c_str());
    }
}


void handlePortMap(const std::string& portMapFile)
{

    if (portMapFile.size() == 0)
        return;

    std::ifstream portmap(portMapFile);

    if (!portmap.is_open())
    {
        printf("failed to open port map file: %s : %s\n", portMapFile.c_str(), strerror(errno));
        exit(EXIT_FAILURE);
    }

    std::string line;

    while(getline(portmap, line))
    {
        if (line.size() > 0 && (line[0] == '#' || line[0] == ';'))
            continue;

        size_t pos = line.find(" ");

        if (pos == std::string::npos)
        {
            printf("not found ' ' in line %s\n", line.c_str());
            continue;
        }

        std::string fp_value = line.substr(0, pos);
        std::string lanes    = line.substr(pos + 1);

        // ::isspace : C-Style white space predicate. Locale independent.
        lanes.erase(std::remove_if(lanes.begin(), lanes.end(), ::isspace), lanes.end());

        std::istringstream iss(lanes);
        std::string lane_str;
        std::set<int> lane_set;

        while (getline(iss, lane_str, ','))
        {
            int lane = stoi(lane_str);
            lane_set.insert(lane);
        }

        gPortMap.insert(std::pair<std::set<int>,std::string>(lane_set,fp_value));
    }
}


void switchRpcThread( int portNum)
{
    int iIOThreadNum = 1, iTaskThreadNum = 0;
    //if (3 == argc)
    //{
    //iIOThreadNum = ::strtol(argv[1], NULL, 10);
    //iTaskThreadNum = ::strtol(argv[2], NULL, 10);
    //}
    
    int port = portNum;
    //
    std::shared_ptr<switch_sai_rpcHandler> testHandler(new switch_sai_rpcHandler());
    //
    std::shared_ptr<TProcessor> testProcessor(new switch_sai_rpcProcessor(testHandler));
    // protocol
    //std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactoryT<TBufferBase>());
    
    
    //std::shared_ptr<TProtocolFactory> protocolFactory(new TJSONProtocolFactory());
    //std::shared_ptr<TProtocolFactory> protocolFactory(new TDebugProtocolFactory());
     std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
    
    
    // transport
    std::shared_ptr<TNonblockingServerTransport> nbSocket(new transport::TNonblockingServerSocket(port));
    //I/O server
    std::shared_ptr<TNonblockingServer> nonblockingServer(new TNonblockingServer(testProcessor, protocolFactory, nbSocket));
    nonblockingServer->setNumIOThreads(iIOThreadNum); //
    
    //
    if (iTaskThreadNum > 0)
    {
        std::shared_ptr<ThreadManager> pThreadManager = ThreadManager::newSimpleThreadManager(iTaskThreadNum);//
        pThreadManager->threadFactory(std::shared_ptr<ThreadFactory>(new ThreadFactory));
        pThreadManager->start();
        nonblockingServer->setThreadManager(pThreadManager);
    }

    //
    nonblockingServer->run();
}

extern "C" {
    extern ctc_cli_start(int);
    extern ctc_master_cli(int);
     extern ctc_cli_read(int);

int32 ctc_pkt_agent_start(struct cmdOptions  option)
{
#if (SDK_WORK_PLATFORM==1)
    uint8 bUmlBased =0;
    char *dut_name =option.dutname.c_str();
    char *sock_path =option.sockPath.c_str();;
    uint8 testSetupMode = 1;
    extern void set_process_based_env(int bEnable);
    uint8 loop = 0;

    if (!bUmlBased)
        {
            if (NULL == sock_path || NULL == dut_name)
            {
                exit(-1);
            }
            set_process_based_env(testSetupMode);

            signal(SIGPIPE, SIG_IGN);
            set_dut_name(dut_name);
            set_sock_path_prefix(sock_path);
            if (start_packet_thread() != 0)
            {
                printf("start_packet_thread failed sock=%s\n",sock_path);
                return -1;
            }
    }


    extern int isProcessBaseEnv(void);

   /*
    if (isProcessBaseEnv()==1)
    {
            int ppid;
            ppid = getppid();
             signal(SIGUSR2, SIG_IGN);
            kill(ppid, SIGUSR2);
            signal(SIGUSR1, ctc_pkt_in_engine_check);
    }
    */

#endif    

    return 0;
}

}

void myexit(int signo)
{
     _exit(0);
}


void handleInitScript(const std::string& initScript)
{

    if (initScript.size() == 0)
        return;

    printf("Running %s ...\n", initScript.c_str());
    system(initScript.c_str());
}


int
main(int argc, char* argv[])
{
    int rv = 0;

    //argv
    auto options = handleCmdLine(argc, argv);
    if (options.sockPath.size()==0 || options.dutname.size()==0 ||  options.thriftport.size() == 0  )
    {
        help_print();
        return 1;
    }
    int port = std::stoi(options.thriftport, 0 , 10);
    
    #if (SDK_WORK_PLATFORM==1)    
    ctc_pkt_agent_start(options);
    #endif
    
    handleProfileMap(options.profileMapFile);
    gPortMapFile = options.profileMapFile;

    int ctc_shell_mode = 0;
    handlePortMap(options.portMapFile);

    sai_api_initialize(0, &test_services);
    sai_api_query(SAI_API_SWITCH, (void**)&sai_switch_api);

    constexpr std::uint32_t attrSz = 8;

    sai_attribute_t attr[attrSz];
    std::memset(attr, '\0', sizeof(attr));

    attr[0].id = SAI_SWITCH_ATTR_INIT_SWITCH;
    attr[0].value.booldata = true;

    attr[1].id = SAI_SWITCH_ATTR_SWITCH_STATE_CHANGE_NOTIFY;
    attr[1].value.ptr = reinterpret_cast<sai_pointer_t>(&on_switch_state_change);

    attr[2].id = SAI_SWITCH_ATTR_SHUTDOWN_REQUEST_NOTIFY;
    attr[2].value.ptr = reinterpret_cast<sai_pointer_t>(&on_shutdown_request);

    attr[3].id = SAI_SWITCH_ATTR_FDB_EVENT_NOTIFY;
    attr[3].value.ptr = reinterpret_cast<sai_pointer_t>(&on_fdb_event);

    attr[4].id = SAI_SWITCH_ATTR_PORT_STATE_CHANGE_NOTIFY;
    attr[4].value.ptr = reinterpret_cast<sai_pointer_t>(&on_port_state_change);

    attr[5].id = SAI_SWITCH_ATTR_PACKET_EVENT_NOTIFY;
    attr[5].value.ptr = reinterpret_cast<sai_pointer_t>(&on_packet_event);

    attr[6].id = SAI_SWITCH_ATTR_BFD_SESSION_STATE_CHANGE_NOTIFY;
    attr[6].value.ptr = reinterpret_cast<sai_pointer_t>(&on_bfd_event);

    attr[7].id = SAI_SWITCH_ATTR_Y1731_SESSION_EVENT_NOTIFY;
    attr[7].value.ptr = reinterpret_cast<sai_pointer_t>(&on_y1731_event);

    sai_status_t status = sai_switch_api->create_switch(&gSwitchId, attrSz, attr);
    if (status != SAI_STATUS_SUCCESS)
    {
        exit(EXIT_FAILURE);
    }


    handleInitScript(options.initScript);

    //std::thread bcm_diag_shell_thread = std::thread(sai_diag_shell);
    //bcm_diag_shell_thread.detach();

    //start_sai_thrift_rpc_server(SWITCH_SAI_THRIFT_RPC_SERVER_PORT);

    sai_log_set(SAI_API_SWITCH, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_BRIDGE, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_FDB, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_PORT, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_VLAN, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_ROUTE, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_VIRTUAL_ROUTER, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_ROUTER_INTERFACE, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_NEXT_HOP, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_NEXT_HOP_GROUP, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_NEIGHBOR, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_ACL, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_MIRROR, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_LAG, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_BUFFER, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_POLICER, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_WRED, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_QOS_MAP, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_L2MC, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_IPMC, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_RPF_GROUP, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_L2MC_GROUP, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_IPMC_GROUP, SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_MCAST_FDB, SAI_LOG_LEVEL_NOTICE);

    printf("The ThirftServer start with listen port %d\n", port);
    std::shared_ptr<thread>  mythread(new thread(switchRpcThread,port));
    signal(SIGINT, myexit);
    mythread->detach();

    ctc_master_cli(ctc_shell_mode);
    ctc_cli_read(ctc_shell_mode);
    rv= ctc_cli_start(ctc_shell_mode);

    //rv = ctc_cli_start(ctc_shell_mode);
    //mythread->join();
    return rv;

}

